
==================== Tidy Core ====================
2018-08-29 18:14:16.331631 UTC

Result size of Tidy Core
  = {terms: 32,343,
     types: 45,021,
     coercions: 45,394,
     joins: 144/1,177}

-- RHS size: {terms: 3, types: 4, coercions: 2, joins: 0/0}
fromLocTrail
  :: forall t. FromTrail t => Located (Trail (V t) (N t)) -> t
fromLocTrail = \ (@ t) (v :: FromTrail t) -> v `cast` <Co:2>

-- RHS size: {terms: 16, types: 9, coercions: 1, joins: 0/0}
$WLCD :: Crossings -> Double -> Double -> LCD
$WLCD
  = \ (dt :: Crossings) (dt :: Double) (dt :: Double) ->
      case dt `cast` <Co:1> of { I# dt ->
      case dt of { D# dt -> case dt of { D# dt -> LCD dt dt dt } }
      }

-- RHS size: {terms: 21, types: 12, coercions: 0, joins: 0/0}
$WLE2D :: Double -> Double -> Double -> Double -> LE2D
$WLE2D
  = \ (dt :: Double) (dt :: Double) (dt :: Double) (dt :: Double) ->
      case dt of { D# dt ->
      case dt of { D# dt ->
      case dt of { D# dt -> case dt of { D# dt -> LE2D dt dt dt dt } }
      }
      }

-- RHS size: {terms: 13, types: 10, coercions: 0, joins: 0/0}
$WPair :: forall a b. a -> b -> Pair a b
$WPair
  = \ (@ a) (@ b) (dt :: a[sk:1]) (dt :: b[sk:1]) ->
      case dt of dt { __DEFAULT ->
      case dt of dt { __DEFAULT -> Pair dt dt }
      }

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
$WOpenTrail :: forall (v :: * -> *) n. Line v n -> Trail v n
$WOpenTrail
  = \ (@ (v :: * -> *)) (@ n) (dt :: Line v[sk:1] n[sk:1]) ->
      case dt of dt { __DEFAULT -> OpenTrail dt }

-- RHS size: {terms: 8, types: 14, coercions: 0, joins: 0/0}
$WClosedTrail :: forall (v :: * -> *) n. Loop v n -> Trail v n
$WClosedTrail
  = \ (@ (v :: * -> *)) (@ n) (dt :: Loop v[sk:1] n[sk:1]) ->
      case dt of dt { __DEFAULT -> ClosedTrail dt }

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
$WLoop
  :: forall (v :: * -> *) n.
     Line v n -> ClosingSegment v n -> Loop v n
$WLoop
  = \ (@ (v :: * -> *))
      (@ n)
      (dt :: Line v[sk:1] n[sk:1])
      (dt :: ClosingSegment v[sk:1] n[sk:1]) ->
      case dt of dt { __DEFAULT ->
      case dt of dt { __DEFAULT -> Loop dt dt }
      }

-- RHS size: {terms: 13, types: 20, coercions: 0, joins: 0/0}
$WLine
  :: forall (v :: * -> *) n. Seq (Segment v n) -> v n -> Line v n
$WLine
  = \ (@ (v :: * -> *))
      (@ n)
      (dt :: Seq (Segment v[sk:1] n[sk:1]))
      (dt :: v[sk:1] n[sk:1]) ->
      case dt of dt { __DEFAULT ->
      case dt of dt { __DEFAULT -> Line dt dt }
      }

-- RHS size: {terms: 246, types: 158, coercions: 10, joins: 0/0}
$fTransformableLine_$s$fTransformableSegment_$ctransform
  :: Transformation (V (Segment V3 Double)) (N (Segment V3 Double))
     -> Segment V3 Double -> Segment V3 Double
$fTransformableLine_$s$fTransformableSegment_$ctransform
  = \ (t :: Transformation
              (V (Segment V3 Double)) (N (Segment V3 Double)))
      (ds :: Segment V3 Double) ->
      case t of { T ipv ipv1 ipv2 ->
      case ipv `cast` <Co:10> of { V3 a1 b1 c ->
      case a1 of { V3 a2 b2 c1 ->
      case a2 of { D# x ->
      case b2 of { D# x1 ->
      case c1 of { D# x2 ->
      case b1 of { V3 a3 b3 c2 ->
      case a3 of { D# x3 ->
      case b3 of { D# x4 ->
      case c2 of { D# x5 ->
      case c of { V3 a4 b4 c3 ->
      case a4 of { D# x6 ->
      case b4 of { D# x7 ->
      case c3 of { D# x8 ->
      case ds of {
        Linear v1 ->
          case v1 of { V3 d e f3 ->
          case d of { D# y ->
          case e of { D# y1 ->
          case f3 of { D# y2 ->
          Linear
            (V3
               (D# (+## (+## (*## x y) (*## x1 y1)) (*## x2 y2)))
               (D# (+## (+## (*## x3 y) (*## x4 y1)) (*## x5 y2)))
               (D# (+## (+## (*## x6 y) (*## x7 y1)) (*## x8 y2))))
          }
          }
          }
          };
        Cubic v1 v2 v3 ->
          case v1 of { V3 d e f3 ->
          case d of { D# y ->
          case e of { D# y1 ->
          case f3 of { D# y2 ->
          case v2 of { V3 d1 e1 f4 ->
          case d1 of { D# y3 ->
          case e1 of { D# y4 ->
          case f4 of { D# y5 ->
          case v3 of { V3 d2 e2 f5 ->
          case d2 of { D# y6 ->
          case e2 of { D# y7 ->
          case f5 of { D# y8 ->
          Cubic
            (V3
               (D# (+## (+## (*## x y) (*## x1 y1)) (*## x2 y2)))
               (D# (+## (+## (*## x3 y) (*## x4 y1)) (*## x5 y2)))
               (D# (+## (+## (*## x6 y) (*## x7 y1)) (*## x8 y2))))
            (V3
               (D# (+## (+## (*## x y3) (*## x1 y4)) (*## x2 y5)))
               (D# (+## (+## (*## x3 y3) (*## x4 y4)) (*## x5 y5)))
               (D# (+## (+## (*## x6 y3) (*## x7 y4)) (*## x8 y5))))
            (V3
               (D# (+## (+## (*## x y6) (*## x1 y7)) (*## x2 y8)))
               (D# (+## (+## (*## x3 y6) (*## x4 y7)) (*## x5 y8)))
               (D# (+## (+## (*## x6 y6) (*## x7 y7)) (*## x8 y8))))
          }
          }
          }
          }
          }
          }
          }
          }
          }
          }
          }
          }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 136, types: 127, coercions: 10, joins: 0/0}
$fTransformableLine_$s$fTransformableSegment_$ctransform1
  :: Transformation (V (Segment V2 Double)) (N (Segment V2 Double))
     -> Segment V2 Double -> Segment V2 Double
$fTransformableLine_$s$fTransformableSegment_$ctransform1
  = \ (t :: Transformation
              (V (Segment V2 Double)) (N (Segment V2 Double)))
      (ds :: Segment V2 Double) ->
      case t of { T ipv ipv1 ipv2 ->
      case ipv `cast` <Co:10> of { V2 a1 b1 ->
      case a1 of { V2 a2 b2 ->
      case a2 of { D# x ->
      case b2 of { D# x1 ->
      case b1 of { V2 a3 b3 ->
      case a3 of { D# x2 ->
      case b3 of { D# x3 ->
      case ds of {
        Linear v1 ->
          case v1 of { V2 d e ->
          case d of { D# y ->
          case e of { D# y1 ->
          Linear
            (V2
               (D# (+## (*## x y) (*## x1 y1))) (D# (+## (*## x2 y) (*## x3 y1))))
          }
          }
          };
        Cubic v1 v2 v3 ->
          case v1 of { V2 d e ->
          case d of { D# y ->
          case e of { D# y1 ->
          case v2 of { V2 d1 e1 ->
          case d1 of { D# y2 ->
          case e1 of { D# y3 ->
          case v3 of { V2 d2 e2 ->
          case d2 of { D# y4 ->
          case e2 of { D# y5 ->
          Cubic
            (V2
               (D# (+## (*## x y) (*## x1 y1))) (D# (+## (*## x2 y) (*## x3 y1))))
            (V2
               (D# (+## (*## x y2) (*## x1 y3)))
               (D# (+## (*## x2 y2) (*## x3 y3))))
            (V2
               (D# (+## (*## x y4) (*## x1 y5)))
               (D# (+## (*## x2 y4) (*## x3 y5))))
          }
          }
          }
          }
          }
          }
          }
          }
          }
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 82, types: 181, coercions: 52, joins: 1/1}
$fEqLine_$c==
  :: forall (v :: * -> *) n.
     (Eq1 v, Eq n) =>
     Line v n -> Line v n -> Bool
$fEqLine_$c==
  = \ (@ (v :: * -> *))
      (@ n)
      ($dEq1 :: Eq1 v)
      ($dEq :: Eq n)
      (eta :: Line v n)
      (eta1 :: Line v n) ->
      case eta of { Line s1 ds ->
      case eta1 of { Line s2 ds1 ->
      join {
        $j :: Bool
        $j
          = $fEq1[]_$cliftEq
              ($fEqSegment_$c== $dEq1 $dEq)
              ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (s1 `cast` <Co:4>))
              ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (s2 `cast` <Co:4>)) } in
      case s1 `cast` <Co:4> of {
        EmptyT ->
          case s2 `cast` <Co:4> of {
            EmptyT -> jump $j;
            Single x -> False;
            Deep dt7 ds2 ds3 ds4 ->
              case dt7 of {
                __DEFAULT -> False;
                0# -> jump $j
              }
          };
        Single x ->
          case s2 `cast` <Co:4> of {
            EmptyT -> False;
            Single x1 -> jump $j;
            Deep dt7 ds2 ds3 ds4 ->
              case dt7 of {
                __DEFAULT -> False;
                1# -> jump $j
              }
          };
        Deep dt7 ds2 ds3 ds4 ->
          case s2 `cast` <Co:4> of {
            EmptyT ->
              case dt7 of {
                __DEFAULT -> False;
                0# -> jump $j
              };
            Single x ->
              case dt7 of {
                __DEFAULT -> False;
                1# -> jump $j
              };
            Deep dt8 ds5 ds6 ds7 ->
              case tagToEnum# (==# dt7 dt8) of {
                False -> False;
                True -> jump $j
              }
          }
      }
      }
      }

-- RHS size: {terms: 87, types: 182, coercions: 52, joins: 1/1}
$fEqLine_$c/=
  :: forall (v :: * -> *) n.
     (Eq1 v, Eq n) =>
     Line v n -> Line v n -> Bool
$fEqLine_$c/=
  = \ (@ (v :: * -> *))
      (@ n)
      ($dEq1 :: Eq1 v)
      ($dEq :: Eq n)
      (eta :: Line v n)
      (eta1 :: Line v n) ->
      case eta of { Line s1 ds ->
      case eta1 of { Line s2 ds1 ->
      join {
        $j :: Bool
        $j
          = case $fEq1[]_$cliftEq
                   ($fEqSegment_$c== $dEq1 $dEq)
                   ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (s1 `cast` <Co:4>))
                   ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (s2 `cast` <Co:4>))
            of {
              False -> True;
              True -> False
            } } in
      case s1 `cast` <Co:4> of {
        EmptyT ->
          case s2 `cast` <Co:4> of {
            EmptyT -> jump $j;
            Single x -> True;
            Deep dt7 ds2 ds3 ds4 ->
              case dt7 of {
                __DEFAULT -> True;
                0# -> jump $j
              }
          };
        Single x ->
          case s2 `cast` <Co:4> of {
            EmptyT -> True;
            Single x1 -> jump $j;
            Deep dt7 ds2 ds3 ds4 ->
              case dt7 of {
                __DEFAULT -> True;
                1# -> jump $j
              }
          };
        Deep dt7 ds2 ds3 ds4 ->
          case s2 `cast` <Co:4> of {
            EmptyT ->
              case dt7 of {
                __DEFAULT -> True;
                0# -> jump $j
              };
            Single x ->
              case dt7 of {
                __DEFAULT -> True;
                1# -> jump $j
              };
            Deep dt8 ds5 ds6 ds7 ->
              case tagToEnum# (==# dt7 dt8) of {
                False -> True;
                True -> jump $j
              }
          }
      }
      }
      }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fEqLine :: forall (v :: * -> *) n. (Eq1 v, Eq n) => Eq (Line v n)
$fEqLine
  = \ (@ (v :: * -> *)) (@ n) ($dEq1 :: Eq1 v) ($dEq :: Eq n) ->
      C:Eq ($fEqLine_$c== $dEq1 $dEq) ($fEqLine_$c/= $dEq1 $dEq)

-- RHS size: {terms: 27, types: 48, coercions: 5, joins: 0/0}
$fMonoidLine_$c<>
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Line v n -> Line v n -> Line v n
$fMonoidLine_$c<>
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (eta :: Line v n)
      (eta1 :: Line v n) ->
      case eta of { Line s1 o1 ->
      case eta1 of { Line s2 o2 ->
      case $fAlternativeSeq2 s1 s2 of nt { __DEFAULT ->
      case ^+^ $dAdditive $dNum o1 o2 of dt7 { __DEFAULT ->
      Line (nt `cast` <Co:5>) dt7
      }
      }
      }
      }

-- RHS size: {terms: 46, types: 112, coercions: 5, joins: 0/1}
$w$csconcat
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Seq (Segment v n)
     -> v n -> [Line v n] -> (# Seq (Segment v n), v n #)
$w$csconcat
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (ww
         :: Seq (Segment v n)
         Unf=OtherCon [])
      (ww1
         :: v n
         Unf=OtherCon [])
      (ww2 :: [Line v n]) ->
      letrec {
        $wgo
          :: Seq (Segment v n)
             -> v n -> [Line v n] -> (# Seq (Segment v n), v n #)
        $wgo
          = \ (ww3
                 :: Seq (Segment v n)
                 Unf=OtherCon [])
              (ww4
                 :: v n
                 Unf=OtherCon [])
              (w2 :: [Line v n]) ->
              case w2 of {
                [] -> (# ww3, ww4 #);
                : c cs ->
                  case c of { Line ww6 ww7 ->
                  case $wgo ww6 ww7 cs of { (# ww9, ww10 #) ->
                  case $fAlternativeSeq2 ww3 ww9 of nt { __DEFAULT ->
                  case ^+^ w w1 ww4 ww10 of dt7 { __DEFAULT ->
                  (# nt `cast` <Co:5>, dt7 #)
                  }
                  }
                  }
                  }
              }; } in
      $wgo ww ww1 ww2

-- RHS size: {terms: 22, types: 53, coercions: 0, joins: 0/0}
$fSemigroupLine_$csconcat
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     NonEmpty (Line v n) -> Line v n
$fSemigroupLine_$csconcat
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (w2 :: NonEmpty (Line v n)) ->
      case w2 of { :| ww1 ww2 ->
      case ww1 of { Line ww4 ww5 ->
      case $w$csconcat w w1 ww4 ww5 ww2 of { (# ww7, ww8 #) ->
      Line ww7 ww8
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl :: Integer
lvl = 2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lineVertices3 :: Integer
lineVertices3 = 1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl1 :: Addr#
lvl1 = "stimes: positive multiplier expected"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl2 :: [Char]
lvl2 = unpackCString# lvl1

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
lvl3 :: forall (v :: * -> *) n. Line v n
lvl3 = \ (@ (v :: * -> *)) (@ n) -> errorWithoutStackTrace lvl2

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl4 :: Integer
lvl4 = 0

-- RHS size: {terms: 201, types: 214, coercions: 30, joins: 2/9}
$w$cstimes
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     forall b.
     Integral b =>
     b -> Seq (Segment v n) -> v n -> (# Seq (Segment v n), v n #)
$w$cstimes
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (@ b)
      (w2 :: Integral b)
      (w3 :: b)
      (ww
         :: Seq (Segment v n)
         Unf=OtherCon [])
      (ww1
         :: v n
         Unf=OtherCon []) ->
      let {
        $dReal :: Real b
        $dReal = $p1Integral w2 } in
      case <= ($p2Real $dReal) w3 (fromInteger ($p1Real $dReal) lvl4)
      of {
        False ->
          let {
            $dNum1 :: Num b
            $dNum1 = $p1Real $dReal } in
          let {
            lvl77 :: b
            lvl77 = fromInteger $dNum1 lvl } in
          let {
            lvl78 :: b
            lvl78 = fromInteger $dNum1 lineVertices3 } in
          let {
            $dEq :: Ord b
            $dEq = $p2Real $dReal } in
          let {
            $dEq1 :: Eq b
            $dEq1 = $p1Ord $dEq } in
          let {
            $dEnum :: Enum b
            $dEnum = $p2Integral w2 } in
          joinrec {
            $wf
              :: Seq (Segment v n) -> v n -> b -> (# Seq (Segment v n), v n #)
            $wf (ww2
                   :: Seq (Segment v n)
                   Unf=OtherCon [])
                (ww3
                   :: v n
                   Unf=OtherCon [])
                (w4 :: b)
              = case even w2 w4 of {
                  False ->
                    case == $dEq1 w4 lvl78 of {
                      False ->
                        case $fAlternativeSeq2 ww2 ww2 of nt { __DEFAULT ->
                        case ^+^ w w1 ww3 ww3 of dt7 { __DEFAULT ->
                        joinrec {
                          $wg
                            :: Seq (Segment v n)
                               -> v n
                               -> b
                               -> Seq (Segment v n)
                               -> v n
                               -> (# Seq (Segment v n), v n #)
                          $wg (ww4
                                 :: Seq (Segment v n)
                                 Unf=OtherCon [])
                              (ww5
                                 :: v n
                                 Unf=OtherCon [])
                              (w5 :: b)
                              (ww6
                                 :: Seq (Segment v n)
                                 Unf=OtherCon [])
                              (ww7
                                 :: v n
                                 Unf=OtherCon [])
                            = case even w2 w5 of {
                                False ->
                                  case == $dEq1 w5 lvl78 of {
                                    False ->
                                      case $fAlternativeSeq2 ww4 ww4 of nt1 { __DEFAULT ->
                                      case ^+^ w w1 ww5 ww5 of dt8 { __DEFAULT ->
                                      case $fAlternativeSeq2 ww4 ww6 of nt2 { __DEFAULT ->
                                      case ^+^ w w1 ww5 ww7 of dt9 { __DEFAULT ->
                                      jump $wg
                                        (nt1 `cast` <Co:5>)
                                        dt8
                                        (quot w2 (pred $dEnum w5) lvl77)
                                        (nt2 `cast` <Co:5>)
                                        dt9
                                      }
                                      }
                                      }
                                      };
                                    True ->
                                      case $fAlternativeSeq2 ww4 ww6 of nt1 { __DEFAULT ->
                                      case ^+^ w w1 ww5 ww7 of dt8 { __DEFAULT ->
                                      (# nt1 `cast` <Co:5>, dt8 #)
                                      }
                                      }
                                  };
                                True ->
                                  case $fAlternativeSeq2 ww4 ww4 of nt1 { __DEFAULT ->
                                  case ^+^ w w1 ww5 ww5 of dt8 { __DEFAULT ->
                                  jump $wg (nt1 `cast` <Co:5>) dt8 (quot w2 w5 lvl77) ww6 ww7
                                  }
                                  }
                              }; } in
                        jump $wg
                          (nt `cast` <Co:5>) dt7 (quot w2 (pred $dEnum w4) lvl77) ww2 ww3
                        }
                        };
                      True -> (# ww2, ww3 #)
                    };
                  True ->
                    case $fAlternativeSeq2 ww2 ww2 of nt { __DEFAULT ->
                    case ^+^ w w1 ww3 ww3 of dt7 { __DEFAULT ->
                    jump $wf (nt `cast` <Co:5>) dt7 (quot w2 w4 lvl77)
                    }
                    }
                }; } in
          jump $wf ww ww1 w3;
        True -> case lvl3 of wild1 { }
      }

-- RHS size: {terms: 23, types: 47, coercions: 0, joins: 0/0}
$fSemigroupLine_$cstimes
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     forall b. Integral b => b -> Line v n -> Line v n
$fSemigroupLine_$cstimes
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (@ b)
      (w2 :: Integral b)
      (w3 :: b)
      (w4 :: Line v n) ->
      case w4 of { Line ww1 ww2 ->
      case $w$cstimes w w1 w2 w3 ww1 ww2 of { (# ww4, ww5 #) ->
      Line ww4 ww5
      }
      }

-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
$fSemigroupLine
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Semigroup (Line v n)
$fSemigroupLine
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      C:Semigroup
        ($fMonoidLine_$c<> $dAdditive $dNum)
        ($fSemigroupLine_$csconcat $dAdditive $dNum)
        ($fSemigroupLine_$cstimes $dAdditive $dNum)

-- RHS size: {terms: 12, types: 20, coercions: 5, joins: 0/0}
$fConsLineLineSegmentSegment_$cmempty
  :: forall (v :: * -> *) n. (Additive v, Num n) => Line v n
$fConsLineLineSegmentSegment_$cmempty
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      case zero $dAdditive $dNum of dt7 { __DEFAULT ->
      Line (EmptyT `cast` <Co:5>) dt7
      }

-- RHS size: {terms: 43, types: 77, coercions: 10, joins: 0/2}
$fMonoidLine_$cmconcat
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     [Line v n] -> Line v n
$fMonoidLine_$cmconcat
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      let {
        z :: Line v n
        z = case zero $dAdditive $dNum of dt7 { __DEFAULT ->
            Line (EmptyT `cast` <Co:5>) dt7
            } } in
      letrec {
        go1 :: [Line v n] -> Line v n
        go1
          = \ (ds :: [Line v n]) ->
              case ds of {
                [] -> z;
                : y ys ->
                  case y of { Line s1 o1 ->
                  case go1 ys of { Line s2 o2 ->
                  case $fAlternativeSeq2 s1 s2 of nt { __DEFAULT ->
                  case ^+^ $dAdditive $dNum o1 o2 of dt7 { __DEFAULT ->
                  Line (nt `cast` <Co:5>) dt7
                  }
                  }
                  }
                  }
              }; } in
      go1

-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
$fMonoidLine
  :: forall (v :: * -> *) n. (Additive v, Num n) => Monoid (Line v n)
$fMonoidLine
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      C:Monoid
        ($fConsLineLineSegmentSegment_$cmempty $dAdditive $dNum)
        ($fMonoidLine_$c<> $dAdditive $dNum)
        ($fMonoidLine_$cmconcat $dAdditive $dNum)

-- RHS size: {terms: 15, types: 44, coercions: 4, joins: 0/0}
$fHasSegmentsLine_$cnumSegments
  :: forall (v :: * -> *) n. Line v n -> Int
$fHasSegmentsLine_$cnumSegments
  = \ (@ (v :: * -> *)) (@ n) (eta :: Line v n) ->
      case eta of { Line ss ds ->
      case ss `cast` <Co:4> of {
        EmptyT -> $fApplicativeSeq2;
        Single x -> $fApplicativeSeq1;
        Deep dt7 ds1 ds2 ds3 -> I# dt7
      }
      }

-- RHS size: {terms: 7, types: 18, coercions: 9, joins: 0/0}
$fHasSegmentsLine_$coffset
  :: forall (v :: * -> *) n. Line v n -> Vn (Line v n)
$fHasSegmentsLine_$coffset
  = \ (@ (v :: * -> *)) (@ n) (eta :: Line v n) ->
      case eta of { Line ds o -> o `cast` <Co:9> }

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
lvl5 :: forall (v :: * -> *) n. Either (Line v n) ()
lvl5 = \ (@ (v :: * -> *)) (@ n) -> Right ()

-- RHS size: {terms: 13, types: 29, coercions: 4, joins: 0/0}
lvl6 :: forall (v :: * -> *) n. Line v n -> Either (Line v n) ()
lvl6
  = \ (@ (v :: * -> *)) (@ n) (s :: Line v n) ->
      case s of wild { Line s1 ds ->
      case s1 `cast` <Co:4> of {
        __DEFAULT -> Left wild;
        EmptyT -> lvl5
      }
      }

-- RHS size: {terms: 46, types: 125, coercions: 5, joins: 0/3}
$fAsEmptyLine_$c_Empty
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Prism' (Line v n) ()
$fAsEmptyLine_$c_Empty
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (@ (p :: * -> * -> *))
      (@ (f3 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f3) ->
      let {
        f4
          :: p (Either (Line v n) ()) (Either (Line v n) (f3 ()))
             -> p (Line v n) (f3 (Line v n))
        f4
          = dimap
              ($p1Choice $dChoice)
              lvl6
              (let {
                 ds :: f3 () -> f3 (Line v n)
                 ds
                   = let {
                       dk :: Line v n
                       dk
                         = case zero $dAdditive $dNum of dt7 { __DEFAULT ->
                           Line (EmptyT `cast` <Co:5>) dt7
                           } } in
                     fmap
                       ($p1Applicative $dApplicative)
                       (\ (ds1 :: ()) -> case ds1 of { () -> dk }) } in
               \ (ds1 :: Either (Line v n) (f3 ())) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p () (f3 ())) -> f4 (right' $dChoice x)

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
$fAsEmptyLine
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     AsEmpty (Line v n)
$fAsEmptyLine = $fAsEmptyLine_$c_Empty `cast` <Co:19>

-- RHS size: {terms: 171, types: 477, coercions: 1,440, joins: 1/5}
$fConsLineLineSegmentSegment_$c_Cons
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Prism
       (Line v n)
       (Line v n)
       (Segment v n, Line v n)
       (Segment v n, Line v n)
$fConsLineLineSegmentSegment_$c_Cons
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (@ (p :: * -> * -> *))
      (@ (f3 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f3) ->
      let {
        f4
          :: p (Either (Line v n) (Segment v n, Line v n)) (Either
                                                              (Line v n)
                                                              (f3 (Segment v n, Line v n)))
             -> p (Line v n) (f3 (Line v n))
        f4
          = let {
              lvl77 :: Line v n
              lvl77
                = case zero $dAdditive $dNum of dt7 { __DEFAULT ->
                  Line (EmptyT `cast` <Co:5>) dt7
                  } } in
            let {
              lvl78 :: Either (Line v n) (Segment v n, Line v n)
              lvl78 = Left lvl77 } in
            dimap
              ($p1Choice $dChoice)
              (\ (ds :: Line v n) ->
                 case ds of { Line ss o ->
                 case $m:<|_$sviewLTree (ss `cast` <Co:4>) of {
                   ConsLTree ds1 xs' ->
                     Right
                       (ds1 `cast` <Co:4>,
                        case xs' of nt { __DEFAULT ->
                        case ^-^
                               $dAdditive
                               $dNum
                               o
                               (case ds1 `cast` <Co:4> of {
                                  Linear v1 -> v1;
                                  Cubic ds2 ds3 v1 -> v1
                                })
                        of dt7
                        { __DEFAULT ->
                        Line (nt `cast` <Co:5>) dt7
                        }
                        });
                   EmptyLTree -> lvl78
                 }
                 })
              (let {
                 ds :: f3 (Segment v n, Line v n) -> f3 (Line v n)
                 ds
                   = fmap
                       ($p1Applicative $dApplicative)
                       (\ (ds1 :: (Segment v n, Line v n)) ->
                          case ds1 of { (s, ds2) ->
                          case ds2 of { Line ss o ->
                          join {
                            $j :: Seq (Segment v n) -> Line v n
                            $j (dt7 :: Seq (Segment v n))
                              = case ^+^
                                       $dAdditive
                                       $dNum
                                       o
                                       (case s of {
                                          Linear v1 -> v1;
                                          Cubic ds3 ds4 v1 -> v1
                                        })
                                of dt8
                                { __DEFAULT ->
                                Line dt7 dt8
                                } } in
                          case ss `cast` <Co:32> of {
                            EmptyT -> jump $j ((Single (s `cast` <Co:31>)) `cast` <Co:200>);
                            Single b ->
                              jump $j
                                ((Deep 2# (One (s `cast` <Co:31>)) EmptyT (One b))
                                 `cast` <Co:200>);
                            Deep dt7 ds3 m sf ->
                              case ds3 of {
                                One b ->
                                  jump $j
                                    ((Deep (+# 1# dt7) (Two (s `cast` <Co:31>) b) m sf)
                                     `cast` <Co:200>);
                                Two b c ->
                                  jump $j
                                    ((Deep (+# 1# dt7) (Three (s `cast` <Co:31>) b c) m sf)
                                     `cast` <Co:200>);
                                Three b c d ->
                                  jump $j
                                    ((Deep (+# 1# dt7) (Four (s `cast` <Co:31>) b c d) m sf)
                                     `cast` <Co:200>);
                                Four b c d e ->
                                  case m of m1 { __DEFAULT ->
                                  jump $j
                                    ((Deep
                                        (+# 1# dt7)
                                        (Two (s `cast` <Co:31>) b)
                                        ($b:<|_$s$sconsTree m1 3# c d e)
                                        sf)
                                     `cast` <Co:200>)
                                  }
                              }
                          }
                          }
                          }) } in
               \ (ds1 :: Either (Line v n) (f3 (Segment v n, Line v n))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (Segment v n, Line v n) (f3 (Segment v n, Line v n))) ->
        f4 (right' $dChoice x)

-- RHS size: {terms: 1, types: 0, coercions: 28, joins: 0/0}
$fConsLineLineSegmentSegment
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Cons (Line v n) (Line v n) (Segment v n) (Segment v n)
$fConsLineLineSegmentSegment
  = $fConsLineLineSegmentSegment_$c_Cons `cast` <Co:28>

-- RHS size: {terms: 171, types: 477, coercions: 1,445, joins: 1/5}
$fSnocLineLineSegmentSegment_$c_Snoc
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Prism
       (Line v n)
       (Line v n)
       (Line v n, Segment v n)
       (Line v n, Segment v n)
$fSnocLineLineSegmentSegment_$c_Snoc
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (@ (p :: * -> * -> *))
      (@ (f3 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f3) ->
      let {
        f4
          :: p (Either (Line v n) (Line v n, Segment v n)) (Either
                                                              (Line v n)
                                                              (f3 (Line v n, Segment v n)))
             -> p (Line v n) (f3 (Line v n))
        f4
          = let {
              lvl77 :: Line v n
              lvl77
                = case zero $dAdditive $dNum of dt7 { __DEFAULT ->
                  Line (EmptyT `cast` <Co:5>) dt7
                  } } in
            let {
              lvl78 :: Either (Line v n) (Line v n, Segment v n)
              lvl78 = Left lvl77 } in
            dimap
              ($p1Choice $dChoice)
              (\ (ds :: Line v n) ->
                 case ds of { Line ss o ->
                 case $m:|>_$sviewRTree (ss `cast` <Co:4>) of {
                   SnocRTree xs' ds1 ->
                     Right
                       (case xs' of nt { __DEFAULT ->
                        case ^-^
                               $dAdditive
                               $dNum
                               o
                               (case ds1 `cast` <Co:4> of {
                                  Linear v1 -> v1;
                                  Cubic ds2 ds3 v1 -> v1
                                })
                        of dt7
                        { __DEFAULT ->
                        Line (nt `cast` <Co:5>) dt7
                        }
                        },
                        ds1 `cast` <Co:4>);
                   EmptyRTree -> lvl78
                 }
                 })
              (let {
                 ds :: f3 (Line v n, Segment v n) -> f3 (Line v n)
                 ds
                   = fmap
                       ($p1Applicative $dApplicative)
                       (\ (ds1 :: (Line v n, Segment v n)) ->
                          case ds1 of { (ds2, s) ->
                          case ds2 of { Line ss o ->
                          join {
                            $j :: Seq (Segment v n) -> Line v n
                            $j (dt7 :: Seq (Segment v n))
                              = case ^+^
                                       $dAdditive
                                       $dNum
                                       o
                                       (case s of {
                                          Linear v1 -> v1;
                                          Cubic ds3 ds4 v1 -> v1
                                        })
                                of dt8
                                { __DEFAULT ->
                                Line dt7 dt8
                                } } in
                          case ss `cast` <Co:31> of {
                            EmptyT -> jump $j ((Single (s `cast` <Co:32>)) `cast` <Co:200>);
                            Single a2 ->
                              jump $j
                                ((Deep 2# (One a2) EmptyT (One (s `cast` <Co:32>)))
                                 `cast` <Co:200>);
                            Deep dt7 pr m ds3 ->
                              case ds3 of {
                                One a2 ->
                                  jump $j
                                    ((Deep (+# dt7 1#) pr m (Two a2 (s `cast` <Co:32>)))
                                     `cast` <Co:200>);
                                Two a2 b ->
                                  jump $j
                                    ((Deep (+# dt7 1#) pr m (Three a2 b (s `cast` <Co:32>)))
                                     `cast` <Co:200>);
                                Three a2 b c ->
                                  jump $j
                                    ((Deep (+# dt7 1#) pr m (Four a2 b c (s `cast` <Co:32>)))
                                     `cast` <Co:200>);
                                Four a2 b c d ->
                                  case m of m1 { __DEFAULT ->
                                  jump $j
                                    ((Deep
                                        (+# dt7 1#)
                                        pr
                                        ($b:|>_$s$ssnocTree 3# a2 b c m1)
                                        (Two d (s `cast` <Co:32>)))
                                     `cast` <Co:200>)
                                  }
                              }
                          }
                          }
                          }) } in
               \ (ds1 :: Either (Line v n) (f3 (Line v n, Segment v n))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (Line v n, Segment v n) (f3 (Line v n, Segment v n))) ->
        f4 (right' $dChoice x)

-- RHS size: {terms: 1, types: 0, coercions: 28, joins: 0/0}
$fSnocLineLineSegmentSegment
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Snoc (Line v n) (Line v n) (Segment v n) (Segment v n)
$fSnocLineLineSegmentSegment
  = $fSnocLineLineSegmentSegment_$c_Snoc `cast` <Co:28>

-- RHS size: {terms: 30, types: 42, coercions: 33, joins: 0/0}
$fNFDataLine_$crnf
  :: forall (v :: * -> *) n. NFData (v n) => Line v n -> ()
$fNFDataLine_$crnf
  = \ (@ (v :: * -> *))
      (@ n)
      ($dNFData :: NFData (v n))
      (eta :: Line v n) ->
      case eta of { Line ss o ->
      case $fNFDataFingerTree_$crnf
             ((\ (ds :: Segment v n) ->
                 case ds of {
                   Linear v1 -> ($dNFData `cast` <Co:3>) v1;
                   Cubic c1 c2 c3 ->
                     case ($dNFData `cast` <Co:3>) c1 of { () ->
                     case ($dNFData `cast` <Co:3>) c2 of { () ->
                     ($dNFData `cast` <Co:3>) c3
                     }
                     }
                 })
              `cast` <Co:14>)
             (ss `cast` <Co:4>)
      of
      { () ->
      ($dNFData `cast` <Co:3>) o
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 17, joins: 0/0}
$fNFDataLine
  :: forall (v :: * -> *) n. NFData (v n) => NFData (Line v n)
$fNFDataLine = $fNFDataLine_$crnf `cast` <Co:17>

-- RHS size: {terms: 75, types: 132, coercions: 9, joins: 0/4}
$fSerial1Line_$cdeserializeWith
  :: forall (v :: * -> *).
     Serial1 v =>
     forall (m :: * -> *) a. MonadGet m => m a -> m (Line v a)
$fSerial1Line_$cdeserializeWith
  = \ (@ (v :: * -> *))
      ($dSerial1 :: Serial1 v)
      (@ (m :: * -> *))
      (@ a)
      (eta :: MonadGet m)
      (eta1 :: m a) ->
      let {
        lvl77 :: m (v a)
        lvl77 = deserializeWith $dSerial1 eta eta1 } in
      let {
        $dMonad :: Monad m
        $dMonad = $p2MonadGet eta } in
      >>=
        $dMonad
        ($fSerial1Seq_$cdeserializeWith
           eta
           (let {
              lvl78 :: m (Segment v a)
              lvl78
                = ap
                    $dMonad
                    (ap
                       $dMonad
                       (>>= $dMonad lvl77 (\ (x1 :: v a) -> return $dMonad ($WCubic x1)))
                       lvl77)
                    lvl77 } in
            let {
              lvl79 :: m (Segment v a)
              lvl79
                = >>=
                    $dMonad
                    lvl77
                    (\ (x1 :: v a) ->
                       return $dMonad (case x1 of dt7 { __DEFAULT -> Linear dt7 })) } in
            >>=
              $dMonad
              (getWord8 eta)
              (\ (ds :: Word8) ->
                 case ds of { W8# x ->
                 case x of {
                   __DEFAULT -> lvl78;
                   0## -> lvl79
                 }
                 })))
        (\ (ss :: Seq (Segment v a)) ->
           >>=
             $dMonad
             lvl77
             (\ (o :: v a) ->
                return
                  $dMonad
                  (case ss `cast` <Co:4> of nt { __DEFAULT ->
                   case o of dt7 { __DEFAULT -> Line (nt `cast` <Co:5>) dt7 }
                   })))

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl7 :: Word8
lvl7 = W8# 0##

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl8 :: Word8
lvl8 = W8# 1##

-- RHS size: {terms: 63, types: 96, coercions: 18, joins: 0/4}
$fSerial1Line_$cserializeWith
  :: forall (v :: * -> *).
     Serial1 v =>
     forall (m :: * -> *) a.
     MonadPut m =>
     (a -> m ()) -> Line v a -> m ()
$fSerial1Line_$cserializeWith
  = \ (@ (v :: * -> *))
      ($dSerial1 :: Serial1 v)
      (@ (m :: * -> *))
      (@ a)
      (eta :: MonadPut m)
      (eta1 :: a -> m ())
      (eta2 :: Line v a) ->
      case eta2 of { Line ss o ->
      >>
        ($p2MonadPut eta)
        ($fSerial1HashMap_$cserializeWith1
           eta
           (let {
              lvl77 :: m ()
              lvl77 = putWord8 eta lvl7 } in
            let {
              lvl78 :: m ()
              lvl78 = putWord8 eta lvl8 } in
            let {
              $dMonad :: Monad m
              $dMonad = $p2MonadPut eta } in
            let {
              fv :: v a -> m ()
              fv = serializeWith $dSerial1 eta eta1 } in
            \ (ds :: Segment v a) ->
              case ds of {
                Linear v1 -> >> $dMonad lvl77 (fv v1);
                Cubic c1 c2 c3 ->
                  >> $dMonad (>> $dMonad (>> $dMonad lvl78 (fv c1)) (fv c2)) (fv c3)
              })
           ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
        (serializeWith $dSerial1 eta eta1 o)
      }

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
$fSerial1Line
  :: forall (v :: * -> *). Serial1 v => Serial1 (Line v)
$fSerial1Line
  = \ (@ (v :: * -> *)) ($dSerial1 :: Serial1 v) ->
      C:Serial1
        ($fSerial1Line_$cserializeWith $dSerial1)
        ($fSerial1Line_$cdeserializeWith $dSerial1)

-- RHS size: {terms: 77, types: 134, coercions: 9, joins: 0/4}
$fSerialLine_$cdeserialize
  :: forall (v :: * -> *) n.
     (Serial1 v, Serial n) =>
     forall (m :: * -> *). MonadGet m => m (Line v n)
$fSerialLine_$cdeserialize
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerial :: Serial n)
      (@ (m :: * -> *))
      ($dMonadGet :: MonadGet m) ->
      let {
        $dMonad :: Monad m
        $dMonad = $p2MonadGet $dMonadGet } in
      let {
        lvl77 :: m (v n)
        lvl77
          = deserializeWith
              $dSerial1 $dMonadGet (deserialize $dSerial $dMonadGet) } in
      >>=
        $dMonad
        ($fSerial1Seq_$cdeserializeWith
           $dMonadGet
           (let {
              lvl78 :: m (Segment v n)
              lvl78
                = ap
                    $dMonad
                    (ap
                       $dMonad
                       (>>= $dMonad lvl77 (\ (x1 :: v n) -> return $dMonad ($WCubic x1)))
                       lvl77)
                    lvl77 } in
            let {
              lvl79 :: m (Segment v n)
              lvl79
                = >>=
                    $dMonad
                    lvl77
                    (\ (x1 :: v n) ->
                       return $dMonad (case x1 of dt7 { __DEFAULT -> Linear dt7 })) } in
            >>=
              $dMonad
              (getWord8 $dMonadGet)
              (\ (ds :: Word8) ->
                 case ds of { W8# x ->
                 case x of {
                   __DEFAULT -> lvl78;
                   0## -> lvl79
                 }
                 })))
        (\ (ss :: Seq (Segment v n)) ->
           >>=
             $dMonad
             lvl77
             (\ (o :: v n) ->
                return
                  $dMonad
                  (case ss `cast` <Co:4> of nt { __DEFAULT ->
                   case o of dt7 { __DEFAULT -> Line (nt `cast` <Co:5>) dt7 }
                   })))

-- RHS size: {terms: 68, types: 104, coercions: 18, joins: 0/6}
$fSerialLine_$cserialize
  :: forall (v :: * -> *) n.
     (Serial1 v, Serial n) =>
     forall (m :: * -> *). MonadPut m => Line v n -> m ()
$fSerialLine_$cserialize
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerial :: Serial n)
      (@ (m :: * -> *))
      ($dMonadPut :: MonadPut m) ->
      let {
        $dMonad :: Monad m
        $dMonad = $p2MonadPut $dMonadPut } in
      let {
        lvl77 :: m ()
        lvl77 = putWord8 $dMonadPut lvl7 } in
      let {
        lvl78 :: m ()
        lvl78 = putWord8 $dMonadPut lvl8 } in
      let {
        f3 :: n -> m ()
        f3 = serialize $dSerial $dMonadPut } in
      let {
        fv :: v n -> m ()
        fv = serializeWith $dSerial1 $dMonadPut f3 } in
      let {
        lvl79 :: Segment v n -> m ()
        lvl79
          = \ (ds :: Segment v n) ->
              case ds of {
                Linear v1 -> >> $dMonad lvl77 (fv v1);
                Cubic c1 c2 c3 ->
                  >> $dMonad (>> $dMonad (>> $dMonad lvl78 (fv c1)) (fv c2)) (fv c3)
              } } in
      \ (ds :: Line v n) ->
        case ds of { Line ss o ->
        >>
          $dMonad
          ($fSerial1HashMap_$cserializeWith1
             $dMonadPut
             lvl79
             ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
          (serializeWith $dSerial1 $dMonadPut f3 o)
        }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fSerialLine
  :: forall (v :: * -> *) n.
     (Serial1 v, Serial n) =>
     Serial (Line v n)
$fSerialLine
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerial :: Serial n) ->
      C:Serial
        ($fSerialLine_$cserialize $dSerial1 $dSerial)
        ($fSerialLine_$cdeserialize $dSerial1 $dSerial)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl9 :: Int
lvl9 = I# 1#

-- RHS size: {terms: 24, types: 21, coercions: 0, joins: 0/0}
lvl10 :: Int -> ByteString -> Either Int (ByteString, ByteString)
lvl10
  = \ (n2 :: Int) (str2 :: ByteString) ->
      case str2 of wild { PS dt7 dt8 dt9 dt10 ->
      case n2 of { I# y ->
      case tagToEnum# (>=# dt10 y) of {
        False -> Left (I# (-# y dt10));
        True -> Right (wild, empty)
      }
      }
      }

-- RHS size: {terms: 5, types: 3, coercions: 0, joins: 0/0}
lvl11 :: [ByteString] -> ByteString
lvl11 = \ (x :: [ByteString]) -> concat (dropWhile null x)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl12 :: Addr#
lvl12 = "not enough bytes"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl13 :: [Char]
lvl13 = unpackCString# lvl12

-- RHS size: {terms: 11, types: 14, coercions: 0, joins: 0/0}
lvl14
  :: [ByteString]
     -> forall r. ByteString -> Success ByteString r -> Decoder r
lvl14
  = \ (bss :: [ByteString]) (@ r) _ _ ->
      case concat bss of dt7 { PS ipv1 ipv2 ipv3 ipv4 -> Fail dt7 lvl13 }

-- RHS size: {terms: 160, types: 142, coercions: 42, joins: 0/5}
$fBinaryLine_$cget
  :: forall (v :: * -> *) n. (Serial1 v, Binary n) => Get (Line v n)
$fBinaryLine_$cget
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dBinary :: Binary n) ->
      let {
        m :: Get n
        m = get $dBinary } in
      let {
        ds :: Get (Seq (Segment v n))
        ds
          = $fSerial1Seq_$cdeserializeWith
              $fMonadGetGet0
              (let {
                 mv :: Get (v n)
                 mv = deserializeWith $dSerial1 $fMonadGetGet0 m } in
               (\ (@ r) (i :: ByteString) (ks :: Success (Segment v n) r) ->
                  case i of wild { PS dt7 dt8 dt9 dt10 ->
                  let {
                    lvl77 :: ByteString -> v n -> Decoder r
                    lvl77
                      = \ (i' :: ByteString) (a1 :: v n) -> ks i' ($WLinear a1) } in
                  let {
                    lvl78 :: ByteString -> v n -> Decoder r
                    lvl78
                      = \ (i' :: ByteString) (a1 :: v n) ->
                          (mv `cast` <Co:3>)
                            i'
                            (\ (i'1 :: ByteString) (a2 :: v n) ->
                               (mv `cast` <Co:3>)
                                 i'1
                                 (\ (i'2 :: ByteString) (a3 :: v n) ->
                                    ks i'2 ($WCubic a1 a2 a3))) } in
                  case tagToEnum# (>=# dt10 1#) of {
                    False ->
                      readN1
                        lvl9
                        lvl10
                        lvl11
                        (lvl14 `cast` <Co:6>)
                        wild
                        (\ _ (a1 :: ByteString) ->
                           case a1 of { PS dt11 dt12 dt13 dt14 ->
                           case readWord8OffAddr# (plusAddr# dt11 dt13) 0# realWorld# of
                           { (# ipv, ipv1 #) ->
                           case touch# dt12 ipv of { __DEFAULT ->
                           case ipv1 of {
                             __DEFAULT ->
                               (mv `cast` <Co:3>) (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) lvl78;
                             0## ->
                               (mv `cast` <Co:3>) (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) lvl77
                           }
                           }
                           }
                           });
                    True ->
                      case readWord8OffAddr# (plusAddr# dt7 dt9) 0# realWorld# of
                      { (# ipv, ipv1 #) ->
                      case touch# dt8 ipv of { __DEFAULT ->
                      case ipv1 of {
                        __DEFAULT ->
                          (mv `cast` <Co:3>) (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) lvl78;
                        0## ->
                          (mv `cast` <Co:3>) (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) lvl77
                      }
                      }
                      }
                  }
                  })
               `cast` <Co:5>) } in
      (\ (@ r) (i :: ByteString) (ks :: Success (Line v n) r) ->
         (ds `cast` <Co:5>)
           i
           (\ (i' :: ByteString) (a1 :: Seq (Segment v n)) ->
              ((deserializeWith $dSerial1 $fMonadGetGet0 m) `cast` <Co:3>)
                i' (\ (i'1 :: ByteString) (a2 :: v n) -> ks i'1 ($WLine a1 a2))))
      `cast` <Co:5>

-- RHS size: {terms: 204, types: 229, coercions: 93, joins: 0/12}
$fBinaryLine_$cput
  :: forall (v :: * -> *) n. (Serial1 v, Binary n) => Line v n -> Put
$fBinaryLine_$cput
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dBinary :: Binary n)
      (eta :: Line v n) ->
      case eta of { Line ss o ->
      let {
        f3 :: n -> PutM ()
        f3 = put $dBinary } in
      let {
        k :: PutM ()
        k = serializeWith $dSerial1 $fMonadPutPutM0 f3 o } in
      (PairS
         (case k `cast` <Co:2> of { PairS b1 w' -> b1 })
         ((\ (@ r) ->
             let {
               f4 :: BuildStep r -> BuildStep r
               f4
                 = case ($fSerial1HashMap_$cserializeWith1
                           $fMonadPutPutM0
                           (let {
                              fv :: v n -> PutM ()
                              fv = serializeWith $dSerial1 $fMonadPutPutM0 f3 } in
                            \ (ds :: Segment v n) ->
                              case ds of {
                                Linear v1 ->
                                  let {
                                    k1 :: PutM ()
                                    k1 = fv v1 } in
                                  (PairS
                                     (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                     ((\ (@ r1) (x :: BuildStep r1) ->
                                         let {
                                           x1 :: BuildStep r1
                                           x1
                                             = case k1 `cast` <Co:2> of { PairS b1 w' ->
                                               (w' `cast` <Co:1>) x
                                               } } in
                                         let {
                                           lvl77
                                             :: BufferRange
                                                -> State# RealWorld
                                                -> (# State# RealWorld, BuildSignal r1 #)
                                           lvl77
                                             = \ (ds1 :: BufferRange) (eta1 :: State# RealWorld) ->
                                                 case ds1 of { BufferRange dt7 dt8 ->
                                                 case writeWord8OffAddr# dt7 0# 0## eta1 of s2
                                                 { __DEFAULT ->
                                                 ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                  `cast` <Co:3>)
                                                   s2
                                                 }
                                                 } } in
                                         (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                                            case eta1 of { BufferRange dt7 dt8 ->
                                            case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                              False ->
                                                case writeWord8OffAddr# dt7 0# 0## eta2 of s2
                                                { __DEFAULT ->
                                                ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                 `cast` <Co:3>)
                                                  s2
                                                };
                                              True ->
                                                (# eta2, BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                            }
                                            })
                                         `cast` <Co:6>)
                                      `cast` <Co:2>))
                                  `cast` <Co:3>;
                                Cubic c1 c2 c3 ->
                                  let {
                                    k1 :: PutM ()
                                    k1 = fv c3 } in
                                  (PairS
                                     (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                     ((\ (@ r1) ->
                                         let {
                                           g :: BuildStep r1 -> BuildStep r1
                                           g = case (fv c1) `cast` <Co:2> of { PairS b1 w' ->
                                               (w' `cast` <Co:1>)
                                               } } in
                                         let {
                                           g1 :: BuildStep r1 -> BuildStep r1
                                           g1
                                             = case (fv c2) `cast` <Co:2> of { PairS b1 w' ->
                                               (w' `cast` <Co:1>)
                                               } } in
                                         \ (x :: BuildStep r1) ->
                                           let {
                                             x1 :: BuildStep r1
                                             x1
                                               = g (g1
                                                      (case k1 `cast` <Co:2> of { PairS b1 w' ->
                                                       (w' `cast` <Co:1>) x
                                                       })) } in
                                           let {
                                             lvl77
                                               :: BufferRange
                                                  -> State# RealWorld
                                                  -> (# State# RealWorld, BuildSignal r1 #)
                                             lvl77
                                               = \ (ds1 :: BufferRange)
                                                   (eta1 :: State# RealWorld) ->
                                                   case ds1 of { BufferRange dt7 dt8 ->
                                                   case writeWord8OffAddr# dt7 0# 1## eta1 of s2
                                                   { __DEFAULT ->
                                                   ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                    `cast` <Co:3>)
                                                     s2
                                                   }
                                                   } } in
                                           (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                                              case eta1 of { BufferRange dt7 dt8 ->
                                              case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                                False ->
                                                  case writeWord8OffAddr# dt7 0# 1## eta2 of s2
                                                  { __DEFAULT ->
                                                  ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                   `cast` <Co:3>)
                                                    s2
                                                  };
                                                True ->
                                                  (# eta2,
                                                     BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                              }
                                              })
                                           `cast` <Co:6>)
                                      `cast` <Co:2>))
                                  `cast` <Co:3>
                              })
                           ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
                        `cast` <Co:2>
                   of
                   { PairS ds w ->
                   (w `cast` <Co:1>)
                   } } in
             \ (x :: BuildStep r) ->
               f4
                 (case k `cast` <Co:2> of { PairS b1 w' -> (w' `cast` <Co:1>) x }))
          `cast` <Co:2>))
      `cast` <Co:3>
      }

Rec {
-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
$fBinaryLine
  :: forall (v :: * -> *) n.
     (Serial1 v, Binary n) =>
     Binary (Line v n)
$fBinaryLine
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dBinary :: Binary n) ->
      C:Binary
        ($fBinaryLine_$cput $dSerial1 $dBinary)
        ($fBinaryLine_$cget $dSerial1 $dBinary)
        ($fBinaryLine_$cputList $dSerial1 $dBinary)

-- RHS size: {terms: 8, types: 15, coercions: 0, joins: 0/0}
$fBinaryLine_$cputList
  :: forall (v :: * -> *) n.
     (Serial1 v, Binary n) =>
     [Line v n] -> Put
$fBinaryLine_$cputList
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dBinary :: Binary n) ->
      defaultPutList ($fBinaryLine $dSerial1 $dBinary)
end Rec }

-- RHS size: {terms: 21, types: 17, coercions: 0, joins: 0/0}
finalBuffer1 :: Buffer -> ByteString -> [ByteString] -> Buffer
finalBuffer1
  = \ (b0 :: Buffer) (s0 :: ByteString) (ss :: [ByteString]) ->
      case b0 of {
        Nothing -> Nothing;
        Just x ->
          case mappend
                 $fMonoidByteString x (concat (reverse1 (init1 s0 ss) []))
          of vx
          { PS ipv ipv1 ipv2 ipv3 ->
          Just vx
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl15 :: Addr#
lvl15 = "too few bytes"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl16 :: [Char]
lvl16 = unpackCString# lvl15

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl17 :: Addr#
lvl17 = "demandInput"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl18 :: [Char]
lvl18 = unpackCString# lvl17

-- RHS size: {terms: 3, types: 4, coercions: 0, joins: 0/0}
lvl19 :: [[Char]]
lvl19 = : lvl18 []

Rec {
-- RHS size: {terms: 103, types: 77, coercions: 0, joins: 1/4}
$s$wgetMore
  :: forall r.
     (ByteString -> Maybe ByteString -> More -> ByteString -> Result r)
     -> (ByteString
         -> Maybe ByteString -> More -> [[Char]] -> [Char] -> Result r)
     -> Maybe Int
     -> Maybe ByteString
     -> [ByteString]
     -> ByteString
     -> Int#
     -> Result r
$s$wgetMore
  = \ (@ r)
      (sc
         :: ByteString
            -> Maybe ByteString -> More -> ByteString -> Result r)
      (sc1
         :: ByteString
            -> Maybe ByteString -> More -> [[Char]] -> [Char] -> Result r)
      (sc2 :: Maybe Int)
      (sc3 :: Maybe ByteString)
      (sc4 :: [ByteString])
      (sc5 :: ByteString)
      (sc6 :: Int#) ->
      let {
        tooFewBytes :: Result r
        tooFewBytes
          = case finalBuffer1 sc3 sc5 sc4 of b { __DEFAULT ->
            case concat (reverse1 (: sc5 sc4) []) of s
            { PS ipv1 ipv2 ipv3 ipv4 ->
            sc1 s b (Incomplete sc2) lvl19 lvl16
            }
            } } in
      let {
        ss1 :: [ByteString]
        ss1 = : sc5 sc4 } in
      Partial
        (\ (s :: ByteString) ->
           case s of wild2 { PS dt7 dt8 dt9 dt10 ->
           case tagToEnum# (<=# dt10 0#) of {
             False ->
               join {
                 $j :: Maybe Int -> Result r
                 $j (mb' :: Maybe Int)
                   = let {
                       n' :: Int#
                       n' = -# sc6 dt10 } in
                     case tagToEnum# (<=# n' 0#) of {
                       False -> $s$wgetMore sc sc1 mb' sc3 ss1 wild2 n';
                       True ->
                         case finalBuffer1 sc3 wild2 ss1 of b { __DEFAULT ->
                         case concat (reverse1 (: wild2 ss1) []) of s1
                         { PS ipv1 ipv2 ipv3 ipv4 ->
                         sc s1 b (Incomplete mb') s1
                         }
                         }
                     } } in
               case sc2 of {
                 Nothing -> jump $j Nothing;
                 Just l -> case l of { I# x -> jump $j (Just (I# (-# x dt10))) }
               };
             True -> tooFewBytes
           }
           })
end Rec }

-- RHS size: {terms: 294, types: 222, coercions: 30, joins: 1/12}
$fSerializeLine_$cget
  :: forall (v :: * -> *) n.
     (Serial1 v, Serialize n) =>
     Get (Line v n)
$fSerializeLine_$cget
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerialize :: Serialize n) ->
      let {
        m :: Get n
        m = get $dSerialize } in
      let {
        m1 :: Get (Seq (Segment v n))
        m1
          = $fSerial1Seq_$cdeserializeWith
              $fMonadGetGet
              (let {
                 mv :: Get (v n)
                 mv = deserializeWith $dSerial1 $fMonadGetGet m } in
               (\ (@ r)
                  (s0 :: Input)
                  (b0 :: Buffer)
                  (m0 :: More)
                  (kf :: Failure r)
                  (ks :: Success (Segment v n) r) ->
                  case s0 of wild1 { PS dt7 dt8 dt9 dt10 ->
                  let {
                    x :: Int#
                    x = -# 1# dt10 } in
                  let {
                    lvl77 :: Input -> Buffer -> More -> v n -> Result r
                    lvl77
                      = \ (s1 :: Input) (b1 :: Buffer) (m2 :: More) (a1 :: v n) ->
                          ks s1 b1 m2 ($WLinear a1) } in
                  let {
                    lvl78 :: Input -> Buffer -> More -> v n -> Result r
                    lvl78
                      = \ (s1 :: Input) (b1 :: Buffer) (m2 :: More) (a1 :: v n) ->
                          (mv `cast` <Co:3>)
                            s1
                            b1
                            m2
                            kf
                            (\ (s2 :: Input) (b2 :: Buffer) (m3 :: More) (a2 :: v n) ->
                               (mv `cast` <Co:3>)
                                 s2
                                 b2
                                 m3
                                 kf
                                 (\ (s3 :: Input) (b3 :: Buffer) (m4 :: More) (a3 :: v n) ->
                                    ks s3 b3 m4 ($WCubic a1 a2 a3))) } in
                  let {
                    $wkarg
                      :: Input
                         -> Buffer
                         -> More
                         -> Addr#
                         -> ForeignPtrContents
                         -> Int#
                         -> Result r
                    $wkarg
                      = \ (w :: Input)
                          (w1 :: Buffer)
                          (w2 :: More)
                          (ww :: Addr#)
                          (ww1 :: ForeignPtrContents)
                          (ww2 :: Int#) ->
                          case readWord8OffAddr# (plusAddr# ww ww2) 0# realWorld# of
                          { (# ipv, ipv1 #) ->
                          case touch# ww1 ipv of { __DEFAULT ->
                          case ipv1 of {
                            __DEFAULT -> (mv `cast` <Co:3>) w w1 w2 kf lvl78;
                            0## -> (mv `cast` <Co:3>) w w1 w2 kf lvl77
                          }
                          }
                          } } in
                  case tagToEnum# (<=# x 0#) of {
                    False ->
                      let {
                        w :: ByteString -> Buffer -> More -> ByteString -> Result r
                        w = \ _ (b1 :: Buffer) (m2 :: More) (a :: ByteString) ->
                              case a of { PS dt11 dt12 dt13 dt14 ->
                              $wkarg
                                (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) b1 m2 dt11 dt12 dt13
                              } } in
                      let {
                        tooFewBytes :: Result r
                        tooFewBytes
                          = case finalBuffer1 b0 wild1 [] of b { __DEFAULT ->
                            case concat (reverse1 (: wild1 []) []) of s
                            { PS ipv1 ipv2 ipv3 ipv4 ->
                            kf s b m0 lvl19 lvl16
                            }
                            } } in
                      case m0 of {
                        Complete -> tooFewBytes;
                        Incomplete mb ->
                          let {
                            ss1 :: [ByteString]
                            ss1 = : wild1 [] } in
                          Partial
                            (\ (s :: ByteString) ->
                               case s of wild4 { PS dt11 dt12 dt13 dt14 ->
                               case tagToEnum# (<=# dt14 0#) of {
                                 False ->
                                   join {
                                     $j :: Maybe Int -> Result r
                                     $j (mb' :: Maybe Int)
                                       = let {
                                           n' :: Int#
                                           n' = -# x dt14 } in
                                         case tagToEnum# (<=# n' 0#) of {
                                           False -> $s$wgetMore w kf mb' b0 ss1 wild4 n';
                                           True ->
                                             case finalBuffer1 b0 wild4 ss1 of b { __DEFAULT ->
                                             case concat (reverse1 (: wild4 ss1) []) of
                                             { PS ipv1 ipv2 ipv3 ipv4 ->
                                             $wkarg
                                               (PS ipv1 ipv2 (+# ipv3 1#) (-# ipv4 1#))
                                               b
                                               (Incomplete mb')
                                               ipv1
                                               ipv2
                                               ipv3
                                             }
                                             }
                                         } } in
                                   case mb of {
                                     Nothing -> jump $j Nothing;
                                     Just l ->
                                       case l of { I# x1 -> jump $j (Just (I# (-# x1 dt14))) }
                                   };
                                 True -> tooFewBytes
                               }
                               })
                      };
                    True ->
                      $wkarg (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) b0 m0 dt7 dt8 dt9
                  }
                  })
               `cast` <Co:5>) } in
      (\ (@ r)
         (s0 :: Input)
         (b0 :: Buffer)
         (m0 :: More)
         (kf :: Failure r)
         (ks :: Success (Line v n) r) ->
         (m1 `cast` <Co:5>)
           s0
           b0
           m0
           kf
           (\ (s1 :: Input)
              (b1 :: Buffer)
              (m2 :: More)
              (a1 :: Seq (Segment v n)) ->
              ((deserializeWith $dSerial1 $fMonadGetGet m) `cast` <Co:3>)
                s1
                b1
                m2
                kf
                (\ (s2 :: Input) (b2 :: Buffer) (m3 :: More) (a2 :: v n) ->
                   ks s2 b2 m3 ($WLine a1 a2))))
      `cast` <Co:5>

-- RHS size: {terms: 204, types: 229, coercions: 93, joins: 0/12}
$fSerializeLine_$cput
  :: forall (v :: * -> *) n.
     (Serial1 v, Serialize n) =>
     Putter (Line v n)
$fSerializeLine_$cput
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerialize :: Serialize n)
      (eta :: Line v n) ->
      case eta of { Line ss o ->
      let {
        f3 :: n -> PutM ()
        f3 = put $dSerialize } in
      let {
        k :: PutM ()
        k = serializeWith $dSerial1 $fMonadPutPutM f3 o } in
      (PairS
         (case k `cast` <Co:2> of { PairS b1 w' -> b1 })
         ((\ (@ r) ->
             let {
               f4 :: BuildStep r -> BuildStep r
               f4
                 = case ($fSerial1HashMap_$cserializeWith1
                           $fMonadPutPutM
                           (let {
                              fv :: v n -> PutM ()
                              fv = serializeWith $dSerial1 $fMonadPutPutM f3 } in
                            \ (ds :: Segment v n) ->
                              case ds of {
                                Linear v1 ->
                                  let {
                                    k1 :: PutM ()
                                    k1 = fv v1 } in
                                  (PairS
                                     (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                     ((\ (@ r1) (x :: BuildStep r1) ->
                                         let {
                                           x1 :: BuildStep r1
                                           x1
                                             = case k1 `cast` <Co:2> of { PairS b1 w' ->
                                               (w' `cast` <Co:1>) x
                                               } } in
                                         let {
                                           lvl77
                                             :: BufferRange
                                                -> State# RealWorld
                                                -> (# State# RealWorld, BuildSignal r1 #)
                                           lvl77
                                             = \ (ds1 :: BufferRange) (eta1 :: State# RealWorld) ->
                                                 case ds1 of { BufferRange dt7 dt8 ->
                                                 case writeWord8OffAddr# dt7 0# 0## eta1 of s2
                                                 { __DEFAULT ->
                                                 ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                  `cast` <Co:3>)
                                                   s2
                                                 }
                                                 } } in
                                         (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                                            case eta1 of { BufferRange dt7 dt8 ->
                                            case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                              False ->
                                                case writeWord8OffAddr# dt7 0# 0## eta2 of s2
                                                { __DEFAULT ->
                                                ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                 `cast` <Co:3>)
                                                  s2
                                                };
                                              True ->
                                                (# eta2, BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                            }
                                            })
                                         `cast` <Co:6>)
                                      `cast` <Co:2>))
                                  `cast` <Co:3>;
                                Cubic c1 c2 c3 ->
                                  let {
                                    k1 :: PutM ()
                                    k1 = fv c3 } in
                                  (PairS
                                     (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                     ((\ (@ r1) ->
                                         let {
                                           g :: BuildStep r1 -> BuildStep r1
                                           g = case (fv c1) `cast` <Co:2> of { PairS b1 w' ->
                                               (w' `cast` <Co:1>)
                                               } } in
                                         let {
                                           g1 :: BuildStep r1 -> BuildStep r1
                                           g1
                                             = case (fv c2) `cast` <Co:2> of { PairS b1 w' ->
                                               (w' `cast` <Co:1>)
                                               } } in
                                         \ (x :: BuildStep r1) ->
                                           let {
                                             x1 :: BuildStep r1
                                             x1
                                               = g (g1
                                                      (case k1 `cast` <Co:2> of { PairS b1 w' ->
                                                       (w' `cast` <Co:1>) x
                                                       })) } in
                                           let {
                                             lvl77
                                               :: BufferRange
                                                  -> State# RealWorld
                                                  -> (# State# RealWorld, BuildSignal r1 #)
                                             lvl77
                                               = \ (ds1 :: BufferRange)
                                                   (eta1 :: State# RealWorld) ->
                                                   case ds1 of { BufferRange dt7 dt8 ->
                                                   case writeWord8OffAddr# dt7 0# 1## eta1 of s2
                                                   { __DEFAULT ->
                                                   ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                    `cast` <Co:3>)
                                                     s2
                                                   }
                                                   } } in
                                           (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                                              case eta1 of { BufferRange dt7 dt8 ->
                                              case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                                False ->
                                                  case writeWord8OffAddr# dt7 0# 1## eta2 of s2
                                                  { __DEFAULT ->
                                                  ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                   `cast` <Co:3>)
                                                    s2
                                                  };
                                                True ->
                                                  (# eta2,
                                                     BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                              }
                                              })
                                           `cast` <Co:6>)
                                      `cast` <Co:2>))
                                  `cast` <Co:3>
                              })
                           ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
                        `cast` <Co:2>
                   of
                   { PairS ds w ->
                   (w `cast` <Co:1>)
                   } } in
             \ (x :: BuildStep r) ->
               f4
                 (case k `cast` <Co:2> of { PairS b1 w' -> (w' `cast` <Co:1>) x }))
          `cast` <Co:2>))
      `cast` <Co:3>
      }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fSerializeLine
  :: forall (v :: * -> *) n.
     (Serial1 v, Serialize n) =>
     Serialize (Line v n)
$fSerializeLine
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerialize :: Serialize n) ->
      C:Serialize
        ($fSerializeLine_$cput $dSerial1 $dSerialize)
        ($fSerializeLine_$cget $dSerial1 $dSerialize)

-- RHS size: {terms: 9, types: 22, coercions: 9, joins: 0/0}
$fEndValuesLine_$catEnd
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Line v n -> Codomain (Line v n) (N (Line v n))
$fEndValuesLine_$catEnd
  = \ (@ (v :: * -> *)) (@ n) _ _ (eta :: Line v n) ->
      case eta of { Line ds o -> o `cast` <Co:9> }

-- RHS size: {terms: 10, types: 17, coercions: 13, joins: 0/1}
$fEndValuesLine_$catStart
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Line v n -> Codomain (Line v n) (N (Line v n))
$fEndValuesLine_$catStart
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      let {
        x :: v n
        x = zero $dAdditive $dNum } in
      (\ _ -> x) `cast` <Co:13>

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fEndValuesLine
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     EndValues (Line v n)
$fEndValuesLine
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      C:EndValues
        ($fEndValuesLine_$catStart $dAdditive $dNum)
        ($fEndValuesLine_$catEnd $dAdditive $dNum)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl20 :: Integer
lvl20 = 3

-- RHS size: {terms: 34, types: 60, coercions: 35, joins: 0/0}
$fTangentEndValuesLine_$ctangentAtEnd
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Line v n -> Vn (Line v n)
$fTangentEndValuesLine_$ctangentAtEnd
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (ds :: Line v n) ->
      case ds of { Line ss o ->
      case $m:|>_$sviewRTree (ss `cast` <Co:4>) of {
        SnocRTree xs' ds1 ->
          case ds1 `cast` <Co:4> of {
            Linear v1 -> v1 `cast` <Co:9>;
            Cubic ds2 c2 c3 ->
              (fmap
                 ($p1Additive $dAdditive)
                 (* $dNum (fromInteger $dNum lvl20))
                 (^-^ $dAdditive $dNum c3 c2))
              `cast` <Co:9>
          };
        EmptyRTree -> (zero $dAdditive $dNum) `cast` <Co:9>
      }
      }

-- RHS size: {terms: 30, types: 58, coercions: 35, joins: 0/0}
$fTangentEndValuesLine_$ctangentAtStart
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Line v n -> Vn (Line v n)
$fTangentEndValuesLine_$ctangentAtStart
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (ds :: Line v n) ->
      case ds of { Line ss o ->
      case $m:<|_$sviewLTree (ss `cast` <Co:4>) of {
        ConsLTree ds1 xs' ->
          case ds1 `cast` <Co:4> of {
            Linear v1 -> v1 `cast` <Co:9>;
            Cubic c1 ds2 ds3 ->
              (fmap
                 ($p1Additive $dAdditive) (* $dNum (fromInteger $dNum lvl20)) c1)
              `cast` <Co:9>
          };
        EmptyLTree -> (zero $dAdditive $dNum) `cast` <Co:9>
      }
      }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fTangentEndValuesLine
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     TangentEndValues (Line v n)
$fTangentEndValuesLine
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      C:TangentEndValues
        ($fTangentEndValuesLine_$ctangentAtStart $dAdditive $dNum)
        ($fTangentEndValuesLine_$ctangentAtEnd $dAdditive $dNum)

-- RHS size: {terms: 24, types: 46, coercions: 20, joins: 0/0}
$w$creversing
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Seq (Segment v n) -> v n -> (# Seq (Segment v n), v n #)
$w$creversing
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (ww
         :: Seq (Segment v n)
         Unf=OtherCon [])
      (ww1
         :: v n
         Unf=OtherCon []) ->
      case fmapReverseTree
             (($fReversingSegment_$creversing w w1) `cast` <Co:11>)
             (ww `cast` <Co:4>)
      of nt
      { __DEFAULT ->
      case fmap ($p1Additive w) (negate w1) ww1 of dt7 { __DEFAULT ->
      (# nt `cast` <Co:5>, dt7 #)
      }
      }

-- RHS size: {terms: 18, types: 41, coercions: 0, joins: 0/0}
$fReversingLine_$creversing
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Line v n -> Line v n
$fReversingLine_$creversing
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (w2 :: Line v n) ->
      case w2 of { Line ww1 ww2 ->
      case $w$creversing w w1 ww1 ww2 of { (# ww4, ww5 #) ->
      Line ww4 ww5
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
$fReversingLine
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Reversing (Line v n)
$fReversingLine = $fReversingLine_$creversing `cast` <Co:19>

-- RHS size: {terms: 10, types: 17, coercions: 13, joins: 0/1}
$fHasSegmentsLoop_$coffset
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Loop v n -> Vn (Loop v n)
$fHasSegmentsLoop_$coffset
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      let {
        x :: v n
        x = zero $dAdditive $dNum } in
      (\ _ -> x) `cast` <Co:13>

-- RHS size: {terms: 46, types: 60, coercions: 39, joins: 0/0}
$fNFDataLoop_$crnf
  :: forall (v :: * -> *) n. NFData (v n) => Loop v n -> ()
$fNFDataLoop_$crnf
  = \ (@ (v :: * -> *))
      (@ n)
      ($dNFData :: NFData (v n))
      (eta :: Loop v n) ->
      case eta of { Loop l c ->
      case l of { Line ss o ->
      case $fNFDataFingerTree_$crnf
             ((\ (ds :: Segment v n) ->
                 case ds of {
                   Linear v1 -> ($dNFData `cast` <Co:3>) v1;
                   Cubic c1 c2 c3 ->
                     case ($dNFData `cast` <Co:3>) c1 of { () ->
                     case ($dNFData `cast` <Co:3>) c2 of { () ->
                     ($dNFData `cast` <Co:3>) c3
                     }
                     }
                 })
              `cast` <Co:14>)
             (ss `cast` <Co:4>)
      of
      { () ->
      case ($dNFData `cast` <Co:3>) o of { () ->
      case c of {
        LinearClosing -> ();
        CubicClosing c1 c2 ->
          case ($dNFData `cast` <Co:3>) c1 of { () ->
          ($dNFData `cast` <Co:3>) c2
          }
      }
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 17, joins: 0/0}
$fNFDataLoop
  :: forall (v :: * -> *) n. NFData (v n) => NFData (Loop v n)
$fNFDataLoop = $fNFDataLoop_$crnf `cast` <Co:17>

-- RHS size: {terms: 129, types: 228, coercions: 9, joins: 0/8}
$fSerial1Loop_$cdeserializeWith
  :: forall (v :: * -> *).
     Serial1 v =>
     forall (m :: * -> *) a. MonadGet m => m a -> m (Loop v a)
$fSerial1Loop_$cdeserializeWith
  = \ (@ (v :: * -> *))
      ($dSerial1 :: Serial1 v)
      (@ (m :: * -> *))
      (@ a)
      (eta :: MonadGet m)
      (eta1 :: m a) ->
      let {
        $dMonad :: Monad m
        $dMonad = $p2MonadGet eta } in
      let {
        lvl77 :: m (ClosingSegment v a)
        lvl77
          = let {
              lvl78 :: m (ClosingSegment v a)
              lvl78 = return $dMonad LinearClosing } in
            let {
              lvl79 :: m (ClosingSegment v a)
              lvl79
                = let {
                    mv :: m (v a)
                    mv = deserializeWith $dSerial1 eta eta1 } in
                  ap
                    $dMonad
                    (>>=
                       $dMonad mv (\ (x1 :: v a) -> return $dMonad ($WCubicClosing x1)))
                    mv } in
            >>=
              $dMonad
              (getWord8 eta)
              (\ (ds :: Word8) ->
                 case ds of { W8# x ->
                 case x of {
                   __DEFAULT -> lvl79;
                   0## -> lvl78
                 }
                 }) } in
      >>=
        $dMonad
        (let {
           lvl78 :: m (v a)
           lvl78 = deserializeWith $dSerial1 eta eta1 } in
         >>=
           $dMonad
           ($fSerial1Seq_$cdeserializeWith
              eta
              (let {
                 lvl79 :: m (Segment v a)
                 lvl79
                   = ap
                       $dMonad
                       (ap
                          $dMonad
                          (>>= $dMonad lvl78 (\ (x1 :: v a) -> return $dMonad ($WCubic x1)))
                          lvl78)
                       lvl78 } in
               let {
                 lvl80 :: m (Segment v a)
                 lvl80
                   = >>=
                       $dMonad
                       lvl78
                       (\ (x1 :: v a) ->
                          return $dMonad (case x1 of dt7 { __DEFAULT -> Linear dt7 })) } in
               >>=
                 $dMonad
                 (getWord8 eta)
                 (\ (ds :: Word8) ->
                    case ds of { W8# x ->
                    case x of {
                      __DEFAULT -> lvl79;
                      0## -> lvl80
                    }
                    })))
           (\ (ss :: Seq (Segment v a)) ->
              >>=
                $dMonad
                lvl78
                (\ (o :: v a) ->
                   return
                     $dMonad
                     (case ss `cast` <Co:4> of nt { __DEFAULT ->
                      case o of dt7 { __DEFAULT -> Line (nt `cast` <Co:5>) dt7 }
                      }))))
        (\ (l :: Line v a) ->
           >>=
             $dMonad
             lvl77
             (\ (c :: ClosingSegment v a) ->
                return
                  $dMonad
                  (case l of dt7 { Line ipv ipv1 ->
                   case c of dt8 { __DEFAULT -> Loop dt7 dt8 }
                   })))

-- RHS size: {terms: 95, types: 134, coercions: 18, joins: 0/6}
$fSerial1Loop_$cserializeWith
  :: forall (v :: * -> *).
     Serial1 v =>
     forall (m :: * -> *) a.
     MonadPut m =>
     (a -> m ()) -> Loop v a -> m ()
$fSerial1Loop_$cserializeWith
  = \ (@ (v :: * -> *))
      ($dSerial1 :: Serial1 v)
      (@ (m :: * -> *))
      (@ a)
      (eta :: MonadPut m)
      (eta1 :: a -> m ())
      (eta2 :: Loop v a) ->
      case eta2 of { Loop l c ->
      case l of { Line ss o ->
      >>
        ($p2MonadPut eta)
        (>>
           ($p2MonadPut eta)
           ($fSerial1HashMap_$cserializeWith1
              eta
              (let {
                 lvl77 :: m ()
                 lvl77 = putWord8 eta lvl7 } in
               let {
                 lvl78 :: m ()
                 lvl78 = putWord8 eta lvl8 } in
               let {
                 $dMonad :: Monad m
                 $dMonad = $p2MonadPut eta } in
               let {
                 fv :: v a -> m ()
                 fv = serializeWith $dSerial1 eta eta1 } in
               \ (ds :: Segment v a) ->
                 case ds of {
                   Linear v1 -> >> $dMonad lvl77 (fv v1);
                   Cubic c1 c2 c3 ->
                     >> $dMonad (>> $dMonad (>> $dMonad lvl78 (fv c1)) (fv c2)) (fv c3)
                 })
              ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
           (serializeWith $dSerial1 eta eta1 o))
        (case c of {
           LinearClosing -> putWord8 eta lvl7;
           CubicClosing c1 c2 ->
             let {
               $dMonad :: Monad m
               $dMonad = $p2MonadPut eta } in
             let {
               fv :: v a -> m ()
               fv = serializeWith $dSerial1 eta eta1 } in
             >> $dMonad (>> $dMonad (putWord8 eta lvl8) (fv c1)) (fv c2)
         })
      }
      }

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
$fSerial1Loop
  :: forall (v :: * -> *). Serial1 v => Serial1 (Loop v)
$fSerial1Loop
  = \ (@ (v :: * -> *)) ($dSerial1 :: Serial1 v) ->
      C:Serial1
        ($fSerial1Loop_$cserializeWith $dSerial1)
        ($fSerial1Loop_$cdeserializeWith $dSerial1)

-- RHS size: {terms: 136, types: 235, coercions: 9, joins: 0/10}
$fSerialLoop_$cdeserialize
  :: forall (v :: * -> *) n.
     (Serial1 v, Serial n) =>
     forall (m :: * -> *). MonadGet m => m (Loop v n)
$fSerialLoop_$cdeserialize
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerial :: Serial n)
      (@ (m :: * -> *))
      ($dMonadGet :: MonadGet m) ->
      let {
        $dMonad :: Monad m
        $dMonad = $p2MonadGet $dMonadGet } in
      let {
        m1 :: m n
        m1 = deserialize $dSerial $dMonadGet } in
      let {
        lvl77 :: m (ClosingSegment v n)
        lvl77
          = let {
              $dMonad1 :: Monad m
              $dMonad1 = $p2MonadGet $dMonadGet } in
            let {
              lvl78 :: m (ClosingSegment v n)
              lvl78 = return $dMonad1 LinearClosing } in
            let {
              lvl79 :: m (ClosingSegment v n)
              lvl79
                = let {
                    mv :: m (v n)
                    mv = deserializeWith $dSerial1 $dMonadGet m1 } in
                  ap
                    $dMonad1
                    (>>=
                       $dMonad1 mv (\ (x1 :: v n) -> return $dMonad1 ($WCubicClosing x1)))
                    mv } in
            >>=
              $dMonad1
              (getWord8 $dMonadGet)
              (\ (ds :: Word8) ->
                 case ds of { W8# x ->
                 case x of {
                   __DEFAULT -> lvl79;
                   0## -> lvl78
                 }
                 }) } in
      >>=
        $dMonad
        (let {
           lvl78 :: m (v n)
           lvl78 = deserializeWith $dSerial1 $dMonadGet m1 } in
         >>=
           $dMonad
           ($fSerial1Seq_$cdeserializeWith
              $dMonadGet
              (let {
                 lvl79 :: m (Segment v n)
                 lvl79
                   = ap
                       $dMonad
                       (ap
                          $dMonad
                          (>>= $dMonad lvl78 (\ (x1 :: v n) -> return $dMonad ($WCubic x1)))
                          lvl78)
                       lvl78 } in
               let {
                 lvl80 :: m (Segment v n)
                 lvl80
                   = >>=
                       $dMonad
                       lvl78
                       (\ (x1 :: v n) ->
                          return $dMonad (case x1 of dt7 { __DEFAULT -> Linear dt7 })) } in
               >>=
                 $dMonad
                 (getWord8 $dMonadGet)
                 (\ (ds :: Word8) ->
                    case ds of { W8# x ->
                    case x of {
                      __DEFAULT -> lvl79;
                      0## -> lvl80
                    }
                    })))
           (\ (ss :: Seq (Segment v n)) ->
              >>=
                $dMonad
                lvl78
                (\ (o :: v n) ->
                   return
                     $dMonad
                     (case ss `cast` <Co:4> of nt { __DEFAULT ->
                      case o of dt7 { __DEFAULT -> Line (nt `cast` <Co:5>) dt7 }
                      }))))
        (\ (l :: Line v n) ->
           >>=
             $dMonad
             lvl77
             (\ (c :: ClosingSegment v n) ->
                return
                  $dMonad
                  (case l of dt7 { Line ipv ipv1 ->
                   case c of dt8 { __DEFAULT -> Loop dt7 dt8 }
                   })))

-- RHS size: {terms: 87, types: 129, coercions: 18, joins: 0/6}
$fSerialLoop_$cserialize
  :: forall (v :: * -> *) n.
     (Serial1 v, Serial n) =>
     forall (m :: * -> *). MonadPut m => Loop v n -> m ()
$fSerialLoop_$cserialize
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerial :: Serial n)
      (@ (m :: * -> *))
      ($dMonadPut :: MonadPut m) ->
      let {
        f3 :: n -> m ()
        f3 = serialize $dSerial $dMonadPut } in
      let {
        fv :: v n -> m ()
        fv = serializeWith $dSerial1 $dMonadPut f3 } in
      let {
        $dMonad :: Monad m
        $dMonad = $p2MonadPut $dMonadPut } in
      let {
        lvl77 :: m ()
        lvl77 = putWord8 $dMonadPut lvl8 } in
      let {
        lvl78 :: m ()
        lvl78 = putWord8 $dMonadPut lvl7 } in
      let {
        lvl79 :: Segment v n -> m ()
        lvl79
          = \ (ds :: Segment v n) ->
              case ds of {
                Linear v1 -> >> $dMonad lvl78 (fv v1);
                Cubic c1 c2 c3 ->
                  >> $dMonad (>> $dMonad (>> $dMonad lvl77 (fv c1)) (fv c2)) (fv c3)
              } } in
      \ (ds :: Loop v n) ->
        case ds of { Loop l c ->
        case l of { Line ss o ->
        >>
          $dMonad
          (>>
             $dMonad
             ($fSerial1HashMap_$cserializeWith1
                $dMonadPut
                lvl79
                ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
             (serializeWith $dSerial1 $dMonadPut f3 o))
          (case c of {
             LinearClosing -> lvl78;
             CubicClosing c1 c2 -> >> $dMonad (>> $dMonad lvl77 (fv c1)) (fv c2)
           })
        }
        }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fSerialLoop
  :: forall (v :: * -> *) n.
     (Serial1 v, Serial n) =>
     Serial (Loop v n)
$fSerialLoop
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerial :: Serial n) ->
      C:Serial
        ($fSerialLoop_$cserialize $dSerial1 $dSerial)
        ($fSerialLoop_$cdeserialize $dSerial1 $dSerial)

-- RHS size: {terms: 299, types: 244, coercions: 75, joins: 0/8}
$fBinaryLoop_$cget
  :: forall (v :: * -> *) n. (Serial1 v, Binary n) => Get (Loop v n)
$fBinaryLoop_$cget
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dBinary :: Binary n) ->
      let {
        m :: Get n
        m = get $dBinary } in
      let {
        mv :: Get (v n)
        mv = deserializeWith $dSerial1 $fMonadGetGet0 m } in
      let {
        ds :: Get (Seq (Segment v n))
        ds
          = $fSerial1Seq_$cdeserializeWith
              $fMonadGetGet0
              (let {
                 mv1 :: Get (v n)
                 mv1 = deserializeWith $dSerial1 $fMonadGetGet0 m } in
               (\ (@ r) (i :: ByteString) (ks :: Success (Segment v n) r) ->
                  case i of wild { PS dt7 dt8 dt9 dt10 ->
                  let {
                    lvl77 :: ByteString -> v n -> Decoder r
                    lvl77
                      = \ (i' :: ByteString) (a1 :: v n) -> ks i' ($WLinear a1) } in
                  let {
                    lvl78 :: ByteString -> v n -> Decoder r
                    lvl78
                      = \ (i' :: ByteString) (a1 :: v n) ->
                          (mv1 `cast` <Co:3>)
                            i'
                            (\ (i'1 :: ByteString) (a2 :: v n) ->
                               (mv1 `cast` <Co:3>)
                                 i'1
                                 (\ (i'2 :: ByteString) (a3 :: v n) ->
                                    ks i'2 ($WCubic a1 a2 a3))) } in
                  case tagToEnum# (>=# dt10 1#) of {
                    False ->
                      readN1
                        lvl9
                        lvl10
                        lvl11
                        (lvl14 `cast` <Co:6>)
                        wild
                        (\ _ (a1 :: ByteString) ->
                           case a1 of { PS dt11 dt12 dt13 dt14 ->
                           case readWord8OffAddr# (plusAddr# dt11 dt13) 0# realWorld# of
                           { (# ipv, ipv1 #) ->
                           case touch# dt12 ipv of { __DEFAULT ->
                           case ipv1 of {
                             __DEFAULT ->
                               (mv1 `cast` <Co:3>) (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) lvl78;
                             0## ->
                               (mv1 `cast` <Co:3>) (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) lvl77
                           }
                           }
                           }
                           });
                    True ->
                      case readWord8OffAddr# (plusAddr# dt7 dt9) 0# realWorld# of
                      { (# ipv, ipv1 #) ->
                      case touch# dt8 ipv of { __DEFAULT ->
                      case ipv1 of {
                        __DEFAULT ->
                          (mv1 `cast` <Co:3>) (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) lvl78;
                        0## ->
                          (mv1 `cast` <Co:3>) (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) lvl77
                      }
                      }
                      }
                  }
                  })
               `cast` <Co:5>) } in
      (\ (@ r) (i :: ByteString) (ks :: Success (Loop v n) r) ->
         (ds `cast` <Co:5>)
           i
           (\ (i' :: ByteString) (a1 :: Seq (Segment v n)) ->
              ((deserializeWith $dSerial1 $fMonadGetGet0 m) `cast` <Co:3>)
                i'
                (\ (i'1 :: ByteString) (a2 :: v n) ->
                   case i'1 of wild { PS dt7 dt8 dt9 dt10 ->
                   let {
                     lvl77 :: Loop v n
                     lvl77
                       = case a1 `cast` <Co:4> of nt { __DEFAULT ->
                         case a2 of dt11 { __DEFAULT ->
                         Loop (Line (nt `cast` <Co:5>) dt11) LinearClosing
                         }
                         } } in
                   let {
                     lvl78 :: ByteString -> v n -> Decoder r
                     lvl78
                       = \ (i'2 :: ByteString) (a3 :: v n) ->
                           (mv `cast` <Co:3>)
                             i'2
                             (\ (i'3 :: ByteString) (a4 :: v n) ->
                                ks
                                  i'3
                                  (case a1 `cast` <Co:4> of nt { __DEFAULT ->
                                   case a2 of dt11 { __DEFAULT ->
                                   case a3 of dt12 { __DEFAULT ->
                                   case a4 of dt13 { __DEFAULT ->
                                   Loop (Line (nt `cast` <Co:5>) dt11) (CubicClosing dt12 dt13)
                                   }
                                   }
                                   }
                                   })) } in
                   case tagToEnum# (>=# dt10 1#) of {
                     False ->
                       readN1
                         lvl9
                         lvl10
                         lvl11
                         (lvl14 `cast` <Co:6>)
                         wild
                         (\ _ (a3 :: ByteString) ->
                            case a3 of { PS dt11 dt12 dt13 dt14 ->
                            case readWord8OffAddr# (plusAddr# dt11 dt13) 0# realWorld# of
                            { (# ipv, ipv1 #) ->
                            case touch# dt12 ipv of { __DEFAULT ->
                            case ipv1 of {
                              __DEFAULT ->
                                (mv `cast` <Co:3>) (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) lvl78;
                              0## -> ks (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) lvl77
                            }
                            }
                            }
                            });
                     True ->
                       case readWord8OffAddr# (plusAddr# dt7 dt9) 0# realWorld# of
                       { (# ipv, ipv1 #) ->
                       case touch# dt8 ipv of { __DEFAULT ->
                       case ipv1 of {
                         __DEFAULT ->
                           (mv `cast` <Co:3>) (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) lvl78;
                         0## -> ks (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) lvl77
                       }
                       }
                       }
                   }
                   })))
      `cast` <Co:5>

-- RHS size: {terms: 52, types: 31, coercions: 12, joins: 0/0}
$wdt
  :: forall r.
     BuildStep r
     -> Addr#
     -> Addr#
     -> State# RealWorld
     -> (# State# RealWorld, BuildSignal r #)
$wdt
  = \ (@ r)
      (w :: BuildStep r)
      (ww :: Addr#)
      (ww1 :: Addr#)
      (w1 :: State# RealWorld) ->
      case tagToEnum# (<# (minusAddr# ww1 ww) 1#) of {
        False ->
          case writeWord8OffAddr# ww 0# 0## w1 of s2 { __DEFAULT ->
          ((w (BufferRange (plusAddr# ww 1#) ww1)) `cast` <Co:3>) s2
          };
        True ->
          (# w1,
             BufferFull
               1#
               ww
               ((\ (ds :: BufferRange) (eta :: State# RealWorld) ->
                   case ds of { BufferRange dt7 dt8 ->
                   case writeWord8OffAddr# dt7 0# 0## eta of s2 { __DEFAULT ->
                   ((w (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                   }
                   })
                `cast` <Co:6>) #)
      }

-- RHS size: {terms: 12, types: 11, coercions: 0, joins: 0/0}
dt
  :: forall r.
     BuildStep r
     -> BufferRange
     -> State# RealWorld
     -> (# State# RealWorld, BuildSignal r #)
dt
  = \ (@ r)
      (w :: BuildStep r)
      (w1 :: BufferRange)
      (w2 :: State# RealWorld) ->
      case w1 of { BufferRange ww1 ww2 -> $wdt w ww1 ww2 w2 }

-- RHS size: {terms: 3, types: 1, coercions: 15, joins: 0/0}
lvl21 :: PairS ()
lvl21 = PairS () (dt `cast` <Co:15>)

-- RHS size: {terms: 299, types: 329, coercions: 130, joins: 0/18}
$fBinaryLoop_$cput
  :: forall (v :: * -> *) n. (Serial1 v, Binary n) => Loop v n -> Put
$fBinaryLoop_$cput
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dBinary :: Binary n)
      (eta :: Loop v n) ->
      case eta of { Loop l c ->
      case l of { Line ss o ->
      let {
        f3 :: n -> PutM ()
        f3 = put $dBinary } in
      let {
        k :: PutM ()
        k = case c of {
              LinearClosing -> lvl21 `cast` <Co:3>;
              CubicClosing c1 c2 ->
                let {
                  fv :: v n -> PutM ()
                  fv = serializeWith $dSerial1 $fMonadPutPutM0 f3 } in
                let {
                  k1 :: PutM ()
                  k1 = fv c2 } in
                (PairS
                   (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                   ((\ (@ r) ->
                       let {
                         g :: BuildStep r -> BuildStep r
                         g = case (fv c1) `cast` <Co:2> of { PairS b1 w' ->
                             (w' `cast` <Co:1>)
                             } } in
                       \ (x :: BuildStep r) ->
                         let {
                           x1 :: BuildStep r
                           x1
                             = g (case k1 `cast` <Co:2> of { PairS b1 w' ->
                                  (w' `cast` <Co:1>) x
                                  }) } in
                         let {
                           lvl77
                             :: BufferRange
                                -> State# RealWorld -> (# State# RealWorld, BuildSignal r #)
                           lvl77
                             = \ (ds :: BufferRange) (eta1 :: State# RealWorld) ->
                                 case ds of { BufferRange dt7 dt8 ->
                                 case writeWord8OffAddr# dt7 0# 1## eta1 of s2 { __DEFAULT ->
                                 ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                                 }
                                 } } in
                         (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                            case eta1 of { BufferRange dt7 dt8 ->
                            case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                              False ->
                                case writeWord8OffAddr# dt7 0# 1## eta2 of s2 { __DEFAULT ->
                                ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                                };
                              True -> (# eta2, BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                            }
                            })
                         `cast` <Co:6>)
                    `cast` <Co:2>))
                `cast` <Co:3>
            } } in
      (PairS
         (case k `cast` <Co:2> of { PairS b1 w' -> b1 })
         ((\ (@ r) ->
             let {
               f4 :: BuildStep r -> BuildStep r
               f4
                 = case ($fSerial1HashMap_$cserializeWith1
                           $fMonadPutPutM0
                           (let {
                              fv :: v n -> PutM ()
                              fv = serializeWith $dSerial1 $fMonadPutPutM0 f3 } in
                            \ (ds :: Segment v n) ->
                              case ds of {
                                Linear v1 ->
                                  let {
                                    k1 :: PutM ()
                                    k1 = fv v1 } in
                                  (PairS
                                     (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                     ((\ (@ r1) (x :: BuildStep r1) ->
                                         let {
                                           x1 :: BuildStep r1
                                           x1
                                             = case k1 `cast` <Co:2> of { PairS b1 w' ->
                                               (w' `cast` <Co:1>) x
                                               } } in
                                         let {
                                           lvl77
                                             :: BufferRange
                                                -> State# RealWorld
                                                -> (# State# RealWorld, BuildSignal r1 #)
                                           lvl77
                                             = \ (ds1 :: BufferRange) (eta1 :: State# RealWorld) ->
                                                 case ds1 of { BufferRange dt7 dt8 ->
                                                 case writeWord8OffAddr# dt7 0# 0## eta1 of s2
                                                 { __DEFAULT ->
                                                 ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                  `cast` <Co:3>)
                                                   s2
                                                 }
                                                 } } in
                                         (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                                            case eta1 of { BufferRange dt7 dt8 ->
                                            case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                              False ->
                                                case writeWord8OffAddr# dt7 0# 0## eta2 of s2
                                                { __DEFAULT ->
                                                ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                 `cast` <Co:3>)
                                                  s2
                                                };
                                              True ->
                                                (# eta2, BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                            }
                                            })
                                         `cast` <Co:6>)
                                      `cast` <Co:2>))
                                  `cast` <Co:3>;
                                Cubic c1 c2 c3 ->
                                  let {
                                    k1 :: PutM ()
                                    k1 = fv c3 } in
                                  (PairS
                                     (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                     ((\ (@ r1) ->
                                         let {
                                           g :: BuildStep r1 -> BuildStep r1
                                           g = case (fv c1) `cast` <Co:2> of { PairS b1 w' ->
                                               (w' `cast` <Co:1>)
                                               } } in
                                         let {
                                           g1 :: BuildStep r1 -> BuildStep r1
                                           g1
                                             = case (fv c2) `cast` <Co:2> of { PairS b1 w' ->
                                               (w' `cast` <Co:1>)
                                               } } in
                                         \ (x :: BuildStep r1) ->
                                           let {
                                             x1 :: BuildStep r1
                                             x1
                                               = g (g1
                                                      (case k1 `cast` <Co:2> of { PairS b1 w' ->
                                                       (w' `cast` <Co:1>) x
                                                       })) } in
                                           let {
                                             lvl77
                                               :: BufferRange
                                                  -> State# RealWorld
                                                  -> (# State# RealWorld, BuildSignal r1 #)
                                             lvl77
                                               = \ (ds1 :: BufferRange)
                                                   (eta1 :: State# RealWorld) ->
                                                   case ds1 of { BufferRange dt7 dt8 ->
                                                   case writeWord8OffAddr# dt7 0# 1## eta1 of s2
                                                   { __DEFAULT ->
                                                   ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                    `cast` <Co:3>)
                                                     s2
                                                   }
                                                   } } in
                                           (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                                              case eta1 of { BufferRange dt7 dt8 ->
                                              case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                                False ->
                                                  case writeWord8OffAddr# dt7 0# 1## eta2 of s2
                                                  { __DEFAULT ->
                                                  ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                   `cast` <Co:3>)
                                                    s2
                                                  };
                                                True ->
                                                  (# eta2,
                                                     BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                              }
                                              })
                                           `cast` <Co:6>)
                                      `cast` <Co:2>))
                                  `cast` <Co:3>
                              })
                           ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
                        `cast` <Co:2>
                   of
                   { PairS ds w ->
                   (w `cast` <Co:1>)
                   } } in
             let {
               g :: BuildStep r -> BuildStep r
               g = case (serializeWith $dSerial1 $fMonadPutPutM0 f3 o)
                        `cast` <Co:2>
                   of
                   { PairS b1 w' ->
                   (w' `cast` <Co:1>)
                   } } in
             \ (x :: BuildStep r) ->
               f4
                 (g (case k `cast` <Co:2> of { PairS b1 w' ->
                     (w' `cast` <Co:1>) x
                     })))
          `cast` <Co:2>))
      `cast` <Co:3>
      }
      }

Rec {
-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
$fBinaryLoop
  :: forall (v :: * -> *) n.
     (Serial1 v, Binary n) =>
     Binary (Loop v n)
$fBinaryLoop
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dBinary :: Binary n) ->
      C:Binary
        ($fBinaryLoop_$cput $dSerial1 $dBinary)
        ($fBinaryLoop_$cget $dSerial1 $dBinary)
        ($fBinaryLoop_$cputList $dSerial1 $dBinary)

-- RHS size: {terms: 8, types: 15, coercions: 0, joins: 0/0}
$fBinaryLoop_$cputList
  :: forall (v :: * -> *) n.
     (Serial1 v, Binary n) =>
     [Loop v n] -> Put
$fBinaryLoop_$cputList
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dBinary :: Binary n) ->
      defaultPutList ($fBinaryLoop $dSerial1 $dBinary)
end Rec }

Rec {
-- RHS size: {terms: 103, types: 77, coercions: 0, joins: 1/4}
$s$wgetMore1
  :: forall r.
     (ByteString -> Maybe ByteString -> More -> ByteString -> Result r)
     -> (ByteString
         -> Maybe ByteString -> More -> [[Char]] -> [Char] -> Result r)
     -> Maybe Int
     -> Maybe ByteString
     -> [ByteString]
     -> ByteString
     -> Int#
     -> Result r
$s$wgetMore1
  = \ (@ r)
      (sc
         :: ByteString
            -> Maybe ByteString -> More -> ByteString -> Result r)
      (sc1
         :: ByteString
            -> Maybe ByteString -> More -> [[Char]] -> [Char] -> Result r)
      (sc2 :: Maybe Int)
      (sc3 :: Maybe ByteString)
      (sc4 :: [ByteString])
      (sc5 :: ByteString)
      (sc6 :: Int#) ->
      let {
        tooFewBytes :: Result r
        tooFewBytes
          = case finalBuffer1 sc3 sc5 sc4 of b { __DEFAULT ->
            case concat (reverse1 (: sc5 sc4) []) of s
            { PS ipv1 ipv2 ipv3 ipv4 ->
            sc1 s b (Incomplete sc2) lvl19 lvl16
            }
            } } in
      let {
        ss1 :: [ByteString]
        ss1 = : sc5 sc4 } in
      Partial
        (\ (s :: ByteString) ->
           case s of wild2 { PS dt7 dt8 dt9 dt10 ->
           case tagToEnum# (<=# dt10 0#) of {
             False ->
               join {
                 $j :: Maybe Int -> Result r
                 $j (mb' :: Maybe Int)
                   = let {
                       n' :: Int#
                       n' = -# sc6 dt10 } in
                     case tagToEnum# (<=# n' 0#) of {
                       False -> $s$wgetMore1 sc sc1 mb' sc3 ss1 wild2 n';
                       True ->
                         case finalBuffer1 sc3 wild2 ss1 of b { __DEFAULT ->
                         case concat (reverse1 (: wild2 ss1) []) of s1
                         { PS ipv1 ipv2 ipv3 ipv4 ->
                         sc s1 b (Incomplete mb') s1
                         }
                         }
                     } } in
               case sc2 of {
                 Nothing -> jump $j Nothing;
                 Just l -> case l of { I# x -> jump $j (Just (I# (-# x dt10))) }
               };
             True -> tooFewBytes
           }
           })
end Rec }

Rec {
-- RHS size: {terms: 103, types: 77, coercions: 0, joins: 1/4}
$s$wgetMore2
  :: forall r.
     (ByteString -> Maybe ByteString -> More -> ByteString -> Result r)
     -> (ByteString
         -> Maybe ByteString -> More -> [[Char]] -> [Char] -> Result r)
     -> Maybe Int
     -> Maybe ByteString
     -> [ByteString]
     -> ByteString
     -> Int#
     -> Result r
$s$wgetMore2
  = \ (@ r)
      (sc
         :: ByteString
            -> Maybe ByteString -> More -> ByteString -> Result r)
      (sc1
         :: ByteString
            -> Maybe ByteString -> More -> [[Char]] -> [Char] -> Result r)
      (sc2 :: Maybe Int)
      (sc3 :: Maybe ByteString)
      (sc4 :: [ByteString])
      (sc5 :: ByteString)
      (sc6 :: Int#) ->
      let {
        tooFewBytes :: Result r
        tooFewBytes
          = case finalBuffer1 sc3 sc5 sc4 of b { __DEFAULT ->
            case concat (reverse1 (: sc5 sc4) []) of s
            { PS ipv1 ipv2 ipv3 ipv4 ->
            sc1 s b (Incomplete sc2) lvl19 lvl16
            }
            } } in
      let {
        ss1 :: [ByteString]
        ss1 = : sc5 sc4 } in
      Partial
        (\ (s :: ByteString) ->
           case s of wild2 { PS dt7 dt8 dt9 dt10 ->
           case tagToEnum# (<=# dt10 0#) of {
             False ->
               join {
                 $j :: Maybe Int -> Result r
                 $j (mb' :: Maybe Int)
                   = let {
                       n' :: Int#
                       n' = -# sc6 dt10 } in
                     case tagToEnum# (<=# n' 0#) of {
                       False -> $s$wgetMore2 sc sc1 mb' sc3 ss1 wild2 n';
                       True ->
                         case finalBuffer1 sc3 wild2 ss1 of b { __DEFAULT ->
                         case concat (reverse1 (: wild2 ss1) []) of s1
                         { PS ipv1 ipv2 ipv3 ipv4 ->
                         sc s1 b (Incomplete mb') s1
                         }
                         }
                     } } in
               case sc2 of {
                 Nothing -> jump $j Nothing;
                 Just l -> case l of { I# x -> jump $j (Just (I# (-# x dt10))) }
               };
             True -> tooFewBytes
           }
           })
end Rec }

-- RHS size: {terms: 537, types: 387, coercions: 54, joins: 2/22}
$fSerializeLoop_$cget
  :: forall (v :: * -> *) n.
     (Serial1 v, Serialize n) =>
     Get (Loop v n)
$fSerializeLoop_$cget
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerialize :: Serialize n) ->
      let {
        m :: Get n
        m = get $dSerialize } in
      let {
        mv :: Get (v n)
        mv = deserializeWith $dSerial1 $fMonadGetGet m } in
      let {
        m1 :: Get (Seq (Segment v n))
        m1
          = $fSerial1Seq_$cdeserializeWith
              $fMonadGetGet
              (let {
                 mv1 :: Get (v n)
                 mv1 = deserializeWith $dSerial1 $fMonadGetGet m } in
               (\ (@ r)
                  (s0 :: Input)
                  (b0 :: Buffer)
                  (m0 :: More)
                  (kf :: Failure r)
                  (ks :: Success (Segment v n) r) ->
                  case s0 of wild1 { PS dt7 dt8 dt9 dt10 ->
                  let {
                    x :: Int#
                    x = -# 1# dt10 } in
                  let {
                    lvl77 :: Input -> Buffer -> More -> v n -> Result r
                    lvl77
                      = \ (s1 :: Input) (b1 :: Buffer) (m2 :: More) (a1 :: v n) ->
                          ks s1 b1 m2 ($WLinear a1) } in
                  let {
                    lvl78 :: Input -> Buffer -> More -> v n -> Result r
                    lvl78
                      = \ (s1 :: Input) (b1 :: Buffer) (m2 :: More) (a1 :: v n) ->
                          (mv1 `cast` <Co:3>)
                            s1
                            b1
                            m2
                            kf
                            (\ (s2 :: Input) (b2 :: Buffer) (m3 :: More) (a2 :: v n) ->
                               (mv1 `cast` <Co:3>)
                                 s2
                                 b2
                                 m3
                                 kf
                                 (\ (s3 :: Input) (b3 :: Buffer) (m4 :: More) (a3 :: v n) ->
                                    ks s3 b3 m4 ($WCubic a1 a2 a3))) } in
                  let {
                    $wkarg
                      :: Input
                         -> Buffer
                         -> More
                         -> Addr#
                         -> ForeignPtrContents
                         -> Int#
                         -> Result r
                    $wkarg
                      = \ (w :: Input)
                          (w1 :: Buffer)
                          (w2 :: More)
                          (ww :: Addr#)
                          (ww1 :: ForeignPtrContents)
                          (ww2 :: Int#) ->
                          case readWord8OffAddr# (plusAddr# ww ww2) 0# realWorld# of
                          { (# ipv, ipv1 #) ->
                          case touch# ww1 ipv of { __DEFAULT ->
                          case ipv1 of {
                            __DEFAULT -> (mv1 `cast` <Co:3>) w w1 w2 kf lvl78;
                            0## -> (mv1 `cast` <Co:3>) w w1 w2 kf lvl77
                          }
                          }
                          } } in
                  case tagToEnum# (<=# x 0#) of {
                    False ->
                      let {
                        w :: ByteString -> Buffer -> More -> ByteString -> Result r
                        w = \ _ (b1 :: Buffer) (m2 :: More) (a :: ByteString) ->
                              case a of { PS dt11 dt12 dt13 dt14 ->
                              $wkarg
                                (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) b1 m2 dt11 dt12 dt13
                              } } in
                      let {
                        tooFewBytes :: Result r
                        tooFewBytes
                          = case finalBuffer1 b0 wild1 [] of b { __DEFAULT ->
                            case concat (reverse1 (: wild1 []) []) of s
                            { PS ipv1 ipv2 ipv3 ipv4 ->
                            kf s b m0 lvl19 lvl16
                            }
                            } } in
                      case m0 of {
                        Complete -> tooFewBytes;
                        Incomplete mb ->
                          let {
                            ss1 :: [ByteString]
                            ss1 = : wild1 [] } in
                          Partial
                            (\ (s :: ByteString) ->
                               case s of wild4 { PS dt11 dt12 dt13 dt14 ->
                               case tagToEnum# (<=# dt14 0#) of {
                                 False ->
                                   join {
                                     $j :: Maybe Int -> Result r
                                     $j (mb' :: Maybe Int)
                                       = let {
                                           n' :: Int#
                                           n' = -# x dt14 } in
                                         case tagToEnum# (<=# n' 0#) of {
                                           False -> $s$wgetMore1 w kf mb' b0 ss1 wild4 n';
                                           True ->
                                             case finalBuffer1 b0 wild4 ss1 of b { __DEFAULT ->
                                             case concat (reverse1 (: wild4 ss1) []) of
                                             { PS ipv1 ipv2 ipv3 ipv4 ->
                                             $wkarg
                                               (PS ipv1 ipv2 (+# ipv3 1#) (-# ipv4 1#))
                                               b
                                               (Incomplete mb')
                                               ipv1
                                               ipv2
                                               ipv3
                                             }
                                             }
                                         } } in
                                   case mb of {
                                     Nothing -> jump $j Nothing;
                                     Just l ->
                                       case l of { I# x1 -> jump $j (Just (I# (-# x1 dt14))) }
                                   };
                                 True -> tooFewBytes
                               }
                               })
                      };
                    True ->
                      $wkarg (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) b0 m0 dt7 dt8 dt9
                  }
                  })
               `cast` <Co:5>) } in
      (\ (@ r)
         (s0 :: Input)
         (b0 :: Buffer)
         (m0 :: More)
         (kf :: Failure r)
         (ks :: Success (Loop v n) r) ->
         (m1 `cast` <Co:5>)
           s0
           b0
           m0
           kf
           (\ (s1 :: Input)
              (b1 :: Buffer)
              (m2 :: More)
              (a1 :: Seq (Segment v n)) ->
              ((deserializeWith $dSerial1 $fMonadGetGet m) `cast` <Co:3>)
                s1
                b1
                m2
                kf
                (\ (s2 :: Input) (b2 :: Buffer) (m3 :: More) (a2 :: v n) ->
                   case s2 of wild1 { PS dt7 dt8 dt9 dt10 ->
                   let {
                     x :: Int#
                     x = -# 1# dt10 } in
                   let {
                     lvl77 :: Loop v n
                     lvl77
                       = case a1 `cast` <Co:4> of nt { __DEFAULT ->
                         case a2 of dt11 { __DEFAULT ->
                         Loop (Line (nt `cast` <Co:5>) dt11) LinearClosing
                         }
                         } } in
                   let {
                     lvl78 :: Input -> Buffer -> More -> v n -> Result r
                     lvl78
                       = \ (s3 :: Input) (b3 :: Buffer) (m4 :: More) (a3 :: v n) ->
                           (mv `cast` <Co:3>)
                             s3
                             b3
                             m4
                             kf
                             (\ (s4 :: Input) (b4 :: Buffer) (m5 :: More) (a4 :: v n) ->
                                ks
                                  s4
                                  b4
                                  m5
                                  (case a1 `cast` <Co:4> of nt { __DEFAULT ->
                                   case a2 of dt11 { __DEFAULT ->
                                   case a3 of dt12 { __DEFAULT ->
                                   case a4 of dt13 { __DEFAULT ->
                                   Loop (Line (nt `cast` <Co:5>) dt11) (CubicClosing dt12 dt13)
                                   }
                                   }
                                   }
                                   })) } in
                   let {
                     $wkarg
                       :: Input
                          -> Buffer
                          -> More
                          -> Addr#
                          -> ForeignPtrContents
                          -> Int#
                          -> Result r
                     $wkarg
                       = \ (w :: Input)
                           (w1 :: Buffer)
                           (w2 :: More)
                           (ww :: Addr#)
                           (ww1 :: ForeignPtrContents)
                           (ww2 :: Int#) ->
                           case readWord8OffAddr# (plusAddr# ww ww2) 0# realWorld# of
                           { (# ipv, ipv1 #) ->
                           case touch# ww1 ipv of { __DEFAULT ->
                           case ipv1 of {
                             __DEFAULT -> (mv `cast` <Co:3>) w w1 w2 kf lvl78;
                             0## -> ks w w1 w2 lvl77
                           }
                           }
                           } } in
                   case tagToEnum# (<=# x 0#) of {
                     False ->
                       let {
                         w :: ByteString -> Buffer -> More -> ByteString -> Result r
                         w = \ _ (b3 :: Buffer) (m4 :: More) (a :: ByteString) ->
                               case a of { PS dt11 dt12 dt13 dt14 ->
                               $wkarg
                                 (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) b3 m4 dt11 dt12 dt13
                               } } in
                       let {
                         tooFewBytes :: Result r
                         tooFewBytes
                           = case finalBuffer1 b2 wild1 [] of b { __DEFAULT ->
                             case concat (reverse1 (: wild1 []) []) of s
                             { PS ipv1 ipv2 ipv3 ipv4 ->
                             kf s b m3 lvl19 lvl16
                             }
                             } } in
                       case m3 of {
                         Complete -> tooFewBytes;
                         Incomplete mb ->
                           let {
                             ss1 :: [ByteString]
                             ss1 = : wild1 [] } in
                           Partial
                             (\ (s :: ByteString) ->
                                case s of wild4 { PS dt11 dt12 dt13 dt14 ->
                                case tagToEnum# (<=# dt14 0#) of {
                                  False ->
                                    join {
                                      $j :: Maybe Int -> Result r
                                      $j (mb' :: Maybe Int)
                                        = let {
                                            n' :: Int#
                                            n' = -# x dt14 } in
                                          case tagToEnum# (<=# n' 0#) of {
                                            False -> $s$wgetMore2 w kf mb' b2 ss1 wild4 n';
                                            True ->
                                              case finalBuffer1 b2 wild4 ss1 of b { __DEFAULT ->
                                              case concat (reverse1 (: wild4 ss1) []) of
                                              { PS ipv1 ipv2 ipv3 ipv4 ->
                                              $wkarg
                                                (PS ipv1 ipv2 (+# ipv3 1#) (-# ipv4 1#))
                                                b
                                                (Incomplete mb')
                                                ipv1
                                                ipv2
                                                ipv3
                                              }
                                              }
                                          } } in
                                    case mb of {
                                      Nothing -> jump $j Nothing;
                                      Just l ->
                                        case l of { I# x1 -> jump $j (Just (I# (-# x1 dt14))) }
                                    };
                                  True -> tooFewBytes
                                }
                                })
                       };
                     True ->
                       $wkarg (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) b2 m3 dt7 dt8 dt9
                   }
                   })))
      `cast` <Co:5>

-- RHS size: {terms: 52, types: 31, coercions: 12, joins: 0/0}
$wdt1
  :: forall r.
     BuildStep r
     -> Addr#
     -> Addr#
     -> State# RealWorld
     -> (# State# RealWorld, BuildSignal r #)
$wdt1
  = \ (@ r)
      (w :: BuildStep r)
      (ww :: Addr#)
      (ww1 :: Addr#)
      (w1 :: State# RealWorld) ->
      case tagToEnum# (<# (minusAddr# ww1 ww) 1#) of {
        False ->
          case writeWord8OffAddr# ww 0# 0## w1 of s2 { __DEFAULT ->
          ((w (BufferRange (plusAddr# ww 1#) ww1)) `cast` <Co:3>) s2
          };
        True ->
          (# w1,
             BufferFull
               1#
               ww
               ((\ (ds :: BufferRange) (eta :: State# RealWorld) ->
                   case ds of { BufferRange dt7 dt8 ->
                   case writeWord8OffAddr# dt7 0# 0## eta of s2 { __DEFAULT ->
                   ((w (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                   }
                   })
                `cast` <Co:6>) #)
      }

-- RHS size: {terms: 12, types: 11, coercions: 0, joins: 0/0}
dt1
  :: forall r.
     BuildStep r
     -> BufferRange
     -> State# RealWorld
     -> (# State# RealWorld, BuildSignal r #)
dt1
  = \ (@ r)
      (w :: BuildStep r)
      (w1 :: BufferRange)
      (w2 :: State# RealWorld) ->
      case w1 of { BufferRange ww1 ww2 -> $wdt1 w ww1 ww2 w2 }

-- RHS size: {terms: 3, types: 1, coercions: 15, joins: 0/0}
lvl22 :: PairS ()
lvl22 = PairS () (dt1 `cast` <Co:15>)

-- RHS size: {terms: 299, types: 329, coercions: 130, joins: 0/18}
$fSerializeLoop_$cput
  :: forall (v :: * -> *) n.
     (Serial1 v, Serialize n) =>
     Putter (Loop v n)
$fSerializeLoop_$cput
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerialize :: Serialize n)
      (eta :: Loop v n) ->
      case eta of { Loop l c ->
      case l of { Line ss o ->
      let {
        f3 :: n -> PutM ()
        f3 = put $dSerialize } in
      let {
        k :: PutM ()
        k = case c of {
              LinearClosing -> lvl22 `cast` <Co:3>;
              CubicClosing c1 c2 ->
                let {
                  fv :: v n -> PutM ()
                  fv = serializeWith $dSerial1 $fMonadPutPutM f3 } in
                let {
                  k1 :: PutM ()
                  k1 = fv c2 } in
                (PairS
                   (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                   ((\ (@ r) ->
                       let {
                         g :: BuildStep r -> BuildStep r
                         g = case (fv c1) `cast` <Co:2> of { PairS b1 w' ->
                             (w' `cast` <Co:1>)
                             } } in
                       \ (x :: BuildStep r) ->
                         let {
                           x1 :: BuildStep r
                           x1
                             = g (case k1 `cast` <Co:2> of { PairS b1 w' ->
                                  (w' `cast` <Co:1>) x
                                  }) } in
                         let {
                           lvl77
                             :: BufferRange
                                -> State# RealWorld -> (# State# RealWorld, BuildSignal r #)
                           lvl77
                             = \ (ds :: BufferRange) (eta1 :: State# RealWorld) ->
                                 case ds of { BufferRange dt7 dt8 ->
                                 case writeWord8OffAddr# dt7 0# 1## eta1 of s2 { __DEFAULT ->
                                 ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                                 }
                                 } } in
                         (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                            case eta1 of { BufferRange dt7 dt8 ->
                            case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                              False ->
                                case writeWord8OffAddr# dt7 0# 1## eta2 of s2 { __DEFAULT ->
                                ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                                };
                              True -> (# eta2, BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                            }
                            })
                         `cast` <Co:6>)
                    `cast` <Co:2>))
                `cast` <Co:3>
            } } in
      (PairS
         (case k `cast` <Co:2> of { PairS b1 w' -> b1 })
         ((\ (@ r) ->
             let {
               f4 :: BuildStep r -> BuildStep r
               f4
                 = case ($fSerial1HashMap_$cserializeWith1
                           $fMonadPutPutM
                           (let {
                              fv :: v n -> PutM ()
                              fv = serializeWith $dSerial1 $fMonadPutPutM f3 } in
                            \ (ds :: Segment v n) ->
                              case ds of {
                                Linear v1 ->
                                  let {
                                    k1 :: PutM ()
                                    k1 = fv v1 } in
                                  (PairS
                                     (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                     ((\ (@ r1) (x :: BuildStep r1) ->
                                         let {
                                           x1 :: BuildStep r1
                                           x1
                                             = case k1 `cast` <Co:2> of { PairS b1 w' ->
                                               (w' `cast` <Co:1>) x
                                               } } in
                                         let {
                                           lvl77
                                             :: BufferRange
                                                -> State# RealWorld
                                                -> (# State# RealWorld, BuildSignal r1 #)
                                           lvl77
                                             = \ (ds1 :: BufferRange) (eta1 :: State# RealWorld) ->
                                                 case ds1 of { BufferRange dt7 dt8 ->
                                                 case writeWord8OffAddr# dt7 0# 0## eta1 of s2
                                                 { __DEFAULT ->
                                                 ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                  `cast` <Co:3>)
                                                   s2
                                                 }
                                                 } } in
                                         (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                                            case eta1 of { BufferRange dt7 dt8 ->
                                            case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                              False ->
                                                case writeWord8OffAddr# dt7 0# 0## eta2 of s2
                                                { __DEFAULT ->
                                                ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                 `cast` <Co:3>)
                                                  s2
                                                };
                                              True ->
                                                (# eta2, BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                            }
                                            })
                                         `cast` <Co:6>)
                                      `cast` <Co:2>))
                                  `cast` <Co:3>;
                                Cubic c1 c2 c3 ->
                                  let {
                                    k1 :: PutM ()
                                    k1 = fv c3 } in
                                  (PairS
                                     (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                     ((\ (@ r1) ->
                                         let {
                                           g :: BuildStep r1 -> BuildStep r1
                                           g = case (fv c1) `cast` <Co:2> of { PairS b1 w' ->
                                               (w' `cast` <Co:1>)
                                               } } in
                                         let {
                                           g1 :: BuildStep r1 -> BuildStep r1
                                           g1
                                             = case (fv c2) `cast` <Co:2> of { PairS b1 w' ->
                                               (w' `cast` <Co:1>)
                                               } } in
                                         \ (x :: BuildStep r1) ->
                                           let {
                                             x1 :: BuildStep r1
                                             x1
                                               = g (g1
                                                      (case k1 `cast` <Co:2> of { PairS b1 w' ->
                                                       (w' `cast` <Co:1>) x
                                                       })) } in
                                           let {
                                             lvl77
                                               :: BufferRange
                                                  -> State# RealWorld
                                                  -> (# State# RealWorld, BuildSignal r1 #)
                                             lvl77
                                               = \ (ds1 :: BufferRange)
                                                   (eta1 :: State# RealWorld) ->
                                                   case ds1 of { BufferRange dt7 dt8 ->
                                                   case writeWord8OffAddr# dt7 0# 1## eta1 of s2
                                                   { __DEFAULT ->
                                                   ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                    `cast` <Co:3>)
                                                     s2
                                                   }
                                                   } } in
                                           (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                                              case eta1 of { BufferRange dt7 dt8 ->
                                              case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                                False ->
                                                  case writeWord8OffAddr# dt7 0# 1## eta2 of s2
                                                  { __DEFAULT ->
                                                  ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                   `cast` <Co:3>)
                                                    s2
                                                  };
                                                True ->
                                                  (# eta2,
                                                     BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                              }
                                              })
                                           `cast` <Co:6>)
                                      `cast` <Co:2>))
                                  `cast` <Co:3>
                              })
                           ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
                        `cast` <Co:2>
                   of
                   { PairS ds w ->
                   (w `cast` <Co:1>)
                   } } in
             let {
               g :: BuildStep r -> BuildStep r
               g = case (serializeWith $dSerial1 $fMonadPutPutM f3 o)
                        `cast` <Co:2>
                   of
                   { PairS b1 w' ->
                   (w' `cast` <Co:1>)
                   } } in
             \ (x :: BuildStep r) ->
               f4
                 (g (case k `cast` <Co:2> of { PairS b1 w' ->
                     (w' `cast` <Co:1>) x
                     })))
          `cast` <Co:2>))
      `cast` <Co:3>
      }
      }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fSerializeLoop
  :: forall (v :: * -> *) n.
     (Serial1 v, Serialize n) =>
     Serialize (Loop v n)
$fSerializeLoop
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerialize :: Serialize n) ->
      C:Serialize
        ($fSerializeLoop_$cput $dSerial1 $dSerialize)
        ($fSerializeLoop_$cget $dSerial1 $dSerialize)

-- RHS size: {terms: 10, types: 17, coercions: 13, joins: 0/1}
$fEndValuesLoop_$catEnd
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Loop v n -> Codomain (Loop v n) (N (Loop v n))
$fEndValuesLoop_$catEnd
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      let {
        x :: v n
        x = zero $dAdditive $dNum } in
      (\ _ -> x) `cast` <Co:13>

-- RHS size: {terms: 10, types: 17, coercions: 13, joins: 0/1}
$fEndValuesLoop_$catStart
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Loop v n -> Codomain (Loop v n) (N (Loop v n))
$fEndValuesLoop_$catStart
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      let {
        x :: v n
        x = zero $dAdditive $dNum } in
      (\ _ -> x) `cast` <Co:13>

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fEndValuesLoop
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     EndValues (Loop v n)
$fEndValuesLoop
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      C:EndValues
        ($fEndValuesLoop_$catStart $dAdditive $dNum)
        ($fEndValuesLoop_$catEnd $dAdditive $dNum)

-- RHS size: {terms: 33, types: 67, coercions: 35, joins: 0/0}
$fTangentEndValuesLoop_$ctangentAtStart
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Loop v n -> Vn (Loop v n)
$fTangentEndValuesLoop_$ctangentAtStart
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (ds :: Loop v n) ->
      case ds of { Loop ds1 ds2 ->
      case ds1 of { Line ss o ->
      case $m:<|_$sviewLTree (ss `cast` <Co:4>) of {
        ConsLTree ds3 xs' ->
          case ds3 `cast` <Co:4> of {
            Linear v1 -> v1 `cast` <Co:9>;
            Cubic c1 ds4 ds5 ->
              (fmap
                 ($p1Additive $dAdditive) (* $dNum (fromInteger $dNum lvl20)) c1)
              `cast` <Co:9>
          };
        EmptyLTree -> (zero $dAdditive $dNum) `cast` <Co:9>
      }
      }
      }

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
lvl23 :: forall (v :: * -> *) n. Either (Trail v n) ()
lvl23 = \ (@ (v :: * -> *)) (@ n) -> Right ()

-- RHS size: {terms: 19, types: 42, coercions: 4, joins: 0/0}
lvl24 :: forall (v :: * -> *) n. Trail v n -> Either (Trail v n) ()
lvl24
  = \ (@ (v :: * -> *)) (@ n) (s :: Trail v n) ->
      case s of wild {
        OpenTrail ds ->
          case ds of { Line s1 ds1 ->
          case s1 `cast` <Co:4> of {
            __DEFAULT -> Left wild;
            EmptyT -> lvl23
          }
          };
        ClosedTrail ipv -> Left wild
      }

-- RHS size: {terms: 47, types: 127, coercions: 5, joins: 0/3}
$fAsEmptyTrail_$c_Empty
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Prism' (Trail v n) ()
$fAsEmptyTrail_$c_Empty
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (@ (p :: * -> * -> *))
      (@ (f3 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f3) ->
      let {
        f4
          :: p (Either (Trail v n) ()) (Either (Trail v n) (f3 ()))
             -> p (Trail v n) (f3 (Trail v n))
        f4
          = dimap
              ($p1Choice $dChoice)
              lvl24
              (let {
                 ds :: f3 () -> f3 (Trail v n)
                 ds
                   = let {
                       dk :: Trail v n
                       dk
                         = case zero $dAdditive $dNum of dt7 { __DEFAULT ->
                           OpenTrail (Line (EmptyT `cast` <Co:5>) dt7)
                           } } in
                     fmap
                       ($p1Applicative $dApplicative)
                       (\ (ds1 :: ()) -> case ds1 of { () -> dk }) } in
               \ (ds1 :: Either (Trail v n) (f3 ())) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p () (f3 ())) -> f4 (right' $dChoice x)

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
$fAsEmptyTrail
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     AsEmpty (Trail v n)
$fAsEmptyTrail = $fAsEmptyTrail_$c_Empty `cast` <Co:19>

-- RHS size: {terms: 13, types: 22, coercions: 5, joins: 0/0}
$fMonoidTrail_$cmempty
  :: forall (v :: * -> *) n. (Additive v, Num n) => Trail v n
$fMonoidTrail_$cmempty
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      case zero $dAdditive $dNum of dt7 { __DEFAULT ->
      OpenTrail (Line (EmptyT `cast` <Co:5>) dt7)
      }

-- RHS size: {terms: 76, types: 99, coercions: 72, joins: 0/0}
$fNFDataTrail_$crnf
  :: forall (v :: * -> *) n. NFData (v n) => Trail v n -> ()
$fNFDataTrail_$crnf
  = \ (@ (v :: * -> *))
      (@ n)
      ($dNFData :: NFData (v n))
      (eta :: Trail v n) ->
      case eta of {
        OpenTrail l ->
          case l of { Line ss o ->
          case $fNFDataFingerTree_$crnf
                 ((\ (ds :: Segment v n) ->
                     case ds of {
                       Linear v1 -> ($dNFData `cast` <Co:3>) v1;
                       Cubic c1 c2 c3 ->
                         case ($dNFData `cast` <Co:3>) c1 of { () ->
                         case ($dNFData `cast` <Co:3>) c2 of { () ->
                         ($dNFData `cast` <Co:3>) c3
                         }
                         }
                     })
                  `cast` <Co:14>)
                 (ss `cast` <Co:4>)
          of
          { () ->
          ($dNFData `cast` <Co:3>) o
          }
          };
        ClosedTrail l ->
          case l of { Loop l1 c ->
          case l1 of { Line ss o ->
          case $fNFDataFingerTree_$crnf
                 ((\ (ds :: Segment v n) ->
                     case ds of {
                       Linear v1 -> ($dNFData `cast` <Co:3>) v1;
                       Cubic c1 c2 c3 ->
                         case ($dNFData `cast` <Co:3>) c1 of { () ->
                         case ($dNFData `cast` <Co:3>) c2 of { () ->
                         ($dNFData `cast` <Co:3>) c3
                         }
                         }
                     })
                  `cast` <Co:14>)
                 (ss `cast` <Co:4>)
          of
          { () ->
          case ($dNFData `cast` <Co:3>) o of { () ->
          case c of {
            LinearClosing -> ();
            CubicClosing c1 c2 ->
              case ($dNFData `cast` <Co:3>) c1 of { () ->
              ($dNFData `cast` <Co:3>) c2
              }
          }
          }
          }
          }
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 17, joins: 0/0}
$fNFDataTrail
  :: forall (v :: * -> *) n. NFData (v n) => NFData (Trail v n)
$fNFDataTrail = $fNFDataTrail_$crnf `cast` <Co:17>

-- RHS size: {terms: 231, types: 409, coercions: 18, joins: 0/13}
$fSerial1Trail_$cdeserializeWith
  :: forall (v :: * -> *).
     Serial1 v =>
     forall (m :: * -> *) a. MonadGet m => m a -> m (Trail v a)
$fSerial1Trail_$cdeserializeWith
  = \ (@ (v :: * -> *))
      ($dSerial1 :: Serial1 v)
      (@ (m :: * -> *))
      (@ a)
      (eta :: MonadGet m)
      (eta1 :: m a) ->
      let {
        $dMonad :: Monad m
        $dMonad = $p2MonadGet eta } in
      let {
        lvl77 :: m (Trail v a)
        lvl77
          = >>=
              $dMonad
              (let {
                 lvl78 :: m (ClosingSegment v a)
                 lvl78
                   = let {
                       lvl79 :: m (ClosingSegment v a)
                       lvl79 = return $dMonad LinearClosing } in
                     let {
                       lvl80 :: m (ClosingSegment v a)
                       lvl80
                         = let {
                             mv :: m (v a)
                             mv = deserializeWith $dSerial1 eta eta1 } in
                           ap
                             $dMonad
                             (>>=
                                $dMonad mv (\ (x1 :: v a) -> return $dMonad ($WCubicClosing x1)))
                             mv } in
                     >>=
                       $dMonad
                       (getWord8 eta)
                       (\ (ds :: Word8) ->
                          case ds of { W8# x ->
                          case x of {
                            __DEFAULT -> lvl80;
                            0## -> lvl79
                          }
                          }) } in
               >>=
                 $dMonad
                 (let {
                    lvl79 :: m (v a)
                    lvl79 = deserializeWith $dSerial1 eta eta1 } in
                  >>=
                    $dMonad
                    ($fSerial1Seq_$cdeserializeWith
                       eta
                       (let {
                          lvl80 :: m (Segment v a)
                          lvl80
                            = ap
                                $dMonad
                                (ap
                                   $dMonad
                                   (>>=
                                      $dMonad lvl79 (\ (x1 :: v a) -> return $dMonad ($WCubic x1)))
                                   lvl79)
                                lvl79 } in
                        let {
                          lvl81 :: m (Segment v a)
                          lvl81
                            = >>=
                                $dMonad
                                lvl79
                                (\ (x1 :: v a) ->
                                   return $dMonad (case x1 of dt7 { __DEFAULT -> Linear dt7 })) } in
                        >>=
                          $dMonad
                          (getWord8 eta)
                          (\ (ds :: Word8) ->
                             case ds of { W8# x ->
                             case x of {
                               __DEFAULT -> lvl80;
                               0## -> lvl81
                             }
                             })))
                    (\ (ss :: Seq (Segment v a)) ->
                       >>=
                         $dMonad
                         lvl79
                         (\ (o :: v a) ->
                            return
                              $dMonad
                              (case ss `cast` <Co:4> of nt { __DEFAULT ->
                               case o of dt7 { __DEFAULT -> Line (nt `cast` <Co:5>) dt7 }
                               }))))
                 (\ (l :: Line v a) ->
                    >>=
                      $dMonad
                      lvl78
                      (\ (c :: ClosingSegment v a) ->
                         return
                           $dMonad
                           (case l of dt7 { Line ipv ipv1 ->
                            case c of dt8 { __DEFAULT -> Loop dt7 dt8 }
                            }))))
              (\ (x1 :: Loop v a) ->
                 return
                   $dMonad (case x1 of dt7 { Loop ipv ipv1 -> ClosedTrail dt7 })) } in
      let {
        lvl78 :: m (Trail v a)
        lvl78
          = >>=
              $dMonad
              (let {
                 lvl79 :: m (v a)
                 lvl79 = deserializeWith $dSerial1 eta eta1 } in
               >>=
                 $dMonad
                 ($fSerial1Seq_$cdeserializeWith
                    eta
                    (let {
                       lvl80 :: m (Segment v a)
                       lvl80
                         = ap
                             $dMonad
                             (ap
                                $dMonad
                                (>>= $dMonad lvl79 (\ (x1 :: v a) -> return $dMonad ($WCubic x1)))
                                lvl79)
                             lvl79 } in
                     let {
                       lvl81 :: m (Segment v a)
                       lvl81
                         = >>=
                             $dMonad
                             lvl79
                             (\ (x1 :: v a) ->
                                return $dMonad (case x1 of dt7 { __DEFAULT -> Linear dt7 })) } in
                     >>=
                       $dMonad
                       (getWord8 eta)
                       (\ (ds :: Word8) ->
                          case ds of { W8# x ->
                          case x of {
                            __DEFAULT -> lvl80;
                            0## -> lvl81
                          }
                          })))
                 (\ (ss :: Seq (Segment v a)) ->
                    >>=
                      $dMonad
                      lvl79
                      (\ (o :: v a) ->
                         return
                           $dMonad
                           (case ss `cast` <Co:4> of nt { __DEFAULT ->
                            case o of dt7 { __DEFAULT -> Line (nt `cast` <Co:5>) dt7 }
                            }))))
              (\ (x1 :: Line v a) ->
                 return
                   $dMonad (case x1 of dt7 { Line ipv ipv1 -> OpenTrail dt7 })) } in
      >>=
        $dMonad
        (getWord8 eta)
        (\ (ds :: Word8) ->
           case ds of { W8# x ->
           case x of {
             __DEFAULT -> lvl77;
             0## -> lvl78
           }
           })

-- RHS size: {terms: 167, types: 229, coercions: 36, joins: 0/10}
$fSerial1Trail_$cserializeWith
  :: forall (v :: * -> *).
     Serial1 v =>
     forall (m :: * -> *) a.
     MonadPut m =>
     (a -> m ()) -> Trail v a -> m ()
$fSerial1Trail_$cserializeWith
  = \ (@ (v :: * -> *))
      ($dSerial1 :: Serial1 v)
      (@ (m :: * -> *))
      (@ a)
      (eta :: MonadPut m)
      (eta1 :: a -> m ())
      (eta2 :: Trail v a) ->
      case eta2 of {
        OpenTrail l ->
          case l of { Line ss o ->
          >>
            ($p2MonadPut eta)
            (putWord8 eta lvl7)
            (>>
               ($p2MonadPut eta)
               ($fSerial1HashMap_$cserializeWith1
                  eta
                  (let {
                     lvl77 :: m ()
                     lvl77 = putWord8 eta lvl7 } in
                   let {
                     lvl78 :: m ()
                     lvl78 = putWord8 eta lvl8 } in
                   let {
                     $dMonad :: Monad m
                     $dMonad = $p2MonadPut eta } in
                   let {
                     fv :: v a -> m ()
                     fv = serializeWith $dSerial1 eta eta1 } in
                   \ (ds :: Segment v a) ->
                     case ds of {
                       Linear v1 -> >> $dMonad lvl77 (fv v1);
                       Cubic c1 c2 c3 ->
                         >> $dMonad (>> $dMonad (>> $dMonad lvl78 (fv c1)) (fv c2)) (fv c3)
                     })
                  ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
               (serializeWith $dSerial1 eta eta1 o))
          };
        ClosedTrail l ->
          case l of { Loop l1 c ->
          case l1 of { Line ss o ->
          >>
            ($p2MonadPut eta)
            (putWord8 eta lvl8)
            (>>
               ($p2MonadPut eta)
               (>>
                  ($p2MonadPut eta)
                  ($fSerial1HashMap_$cserializeWith1
                     eta
                     (let {
                        lvl77 :: m ()
                        lvl77 = putWord8 eta lvl7 } in
                      let {
                        lvl78 :: m ()
                        lvl78 = putWord8 eta lvl8 } in
                      let {
                        $dMonad :: Monad m
                        $dMonad = $p2MonadPut eta } in
                      let {
                        fv :: v a -> m ()
                        fv = serializeWith $dSerial1 eta eta1 } in
                      \ (ds :: Segment v a) ->
                        case ds of {
                          Linear v1 -> >> $dMonad lvl77 (fv v1);
                          Cubic c1 c2 c3 ->
                            >> $dMonad (>> $dMonad (>> $dMonad lvl78 (fv c1)) (fv c2)) (fv c3)
                        })
                     ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
                  (serializeWith $dSerial1 eta eta1 o))
               (case c of {
                  LinearClosing -> putWord8 eta lvl7;
                  CubicClosing c1 c2 ->
                    let {
                      $dMonad :: Monad m
                      $dMonad = $p2MonadPut eta } in
                    let {
                      fv :: v a -> m ()
                      fv = serializeWith $dSerial1 eta eta1 } in
                    >> $dMonad (>> $dMonad (putWord8 eta lvl8) (fv c1)) (fv c2)
                }))
          }
          }
      }

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
$fSerial1Trail
  :: forall (v :: * -> *). Serial1 v => Serial1 (Trail v)
$fSerial1Trail
  = \ (@ (v :: * -> *)) ($dSerial1 :: Serial1 v) ->
      C:Serial1
        ($fSerial1Trail_$cserializeWith $dSerial1)
        ($fSerial1Trail_$cdeserializeWith $dSerial1)

-- RHS size: {terms: 235, types: 413, coercions: 18, joins: 0/14}
$fSerialTrail_$cdeserialize
  :: forall (v :: * -> *) n.
     (Serial1 v, Serial n) =>
     forall (m :: * -> *). MonadGet m => m (Trail v n)
$fSerialTrail_$cdeserialize
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerial :: Serial n)
      (@ (m :: * -> *))
      ($dMonadGet :: MonadGet m) ->
      let {
        $dMonad :: Monad m
        $dMonad = $p2MonadGet $dMonadGet } in
      let {
        m1 :: m n
        m1 = deserialize $dSerial $dMonadGet } in
      let {
        lvl77 :: m (Trail v n)
        lvl77
          = >>=
              $dMonad
              (let {
                 lvl78 :: m (ClosingSegment v n)
                 lvl78
                   = let {
                       lvl79 :: m (ClosingSegment v n)
                       lvl79 = return $dMonad LinearClosing } in
                     let {
                       lvl80 :: m (ClosingSegment v n)
                       lvl80
                         = let {
                             mv :: m (v n)
                             mv = deserializeWith $dSerial1 $dMonadGet m1 } in
                           ap
                             $dMonad
                             (>>=
                                $dMonad mv (\ (x1 :: v n) -> return $dMonad ($WCubicClosing x1)))
                             mv } in
                     >>=
                       $dMonad
                       (getWord8 $dMonadGet)
                       (\ (ds :: Word8) ->
                          case ds of { W8# x ->
                          case x of {
                            __DEFAULT -> lvl80;
                            0## -> lvl79
                          }
                          }) } in
               >>=
                 $dMonad
                 (let {
                    lvl79 :: m (v n)
                    lvl79 = deserializeWith $dSerial1 $dMonadGet m1 } in
                  >>=
                    $dMonad
                    ($fSerial1Seq_$cdeserializeWith
                       $dMonadGet
                       (let {
                          lvl80 :: m (Segment v n)
                          lvl80
                            = ap
                                $dMonad
                                (ap
                                   $dMonad
                                   (>>=
                                      $dMonad lvl79 (\ (x1 :: v n) -> return $dMonad ($WCubic x1)))
                                   lvl79)
                                lvl79 } in
                        let {
                          lvl81 :: m (Segment v n)
                          lvl81
                            = >>=
                                $dMonad
                                lvl79
                                (\ (x1 :: v n) ->
                                   return $dMonad (case x1 of dt7 { __DEFAULT -> Linear dt7 })) } in
                        >>=
                          $dMonad
                          (getWord8 $dMonadGet)
                          (\ (ds :: Word8) ->
                             case ds of { W8# x ->
                             case x of {
                               __DEFAULT -> lvl80;
                               0## -> lvl81
                             }
                             })))
                    (\ (ss :: Seq (Segment v n)) ->
                       >>=
                         $dMonad
                         lvl79
                         (\ (o :: v n) ->
                            return
                              $dMonad
                              (case ss `cast` <Co:4> of nt { __DEFAULT ->
                               case o of dt7 { __DEFAULT -> Line (nt `cast` <Co:5>) dt7 }
                               }))))
                 (\ (l :: Line v n) ->
                    >>=
                      $dMonad
                      lvl78
                      (\ (c :: ClosingSegment v n) ->
                         return
                           $dMonad
                           (case l of dt7 { Line ipv ipv1 ->
                            case c of dt8 { __DEFAULT -> Loop dt7 dt8 }
                            }))))
              (\ (x1 :: Loop v n) ->
                 return
                   $dMonad (case x1 of dt7 { Loop ipv ipv1 -> ClosedTrail dt7 })) } in
      let {
        lvl78 :: m (Trail v n)
        lvl78
          = >>=
              $dMonad
              (let {
                 lvl79 :: m (v n)
                 lvl79 = deserializeWith $dSerial1 $dMonadGet m1 } in
               >>=
                 $dMonad
                 ($fSerial1Seq_$cdeserializeWith
                    $dMonadGet
                    (let {
                       lvl80 :: m (Segment v n)
                       lvl80
                         = ap
                             $dMonad
                             (ap
                                $dMonad
                                (>>= $dMonad lvl79 (\ (x1 :: v n) -> return $dMonad ($WCubic x1)))
                                lvl79)
                             lvl79 } in
                     let {
                       lvl81 :: m (Segment v n)
                       lvl81
                         = >>=
                             $dMonad
                             lvl79
                             (\ (x1 :: v n) ->
                                return $dMonad (case x1 of dt7 { __DEFAULT -> Linear dt7 })) } in
                     >>=
                       $dMonad
                       (getWord8 $dMonadGet)
                       (\ (ds :: Word8) ->
                          case ds of { W8# x ->
                          case x of {
                            __DEFAULT -> lvl80;
                            0## -> lvl81
                          }
                          })))
                 (\ (ss :: Seq (Segment v n)) ->
                    >>=
                      $dMonad
                      lvl79
                      (\ (o :: v n) ->
                         return
                           $dMonad
                           (case ss `cast` <Co:4> of nt { __DEFAULT ->
                            case o of dt7 { __DEFAULT -> Line (nt `cast` <Co:5>) dt7 }
                            }))))
              (\ (x1 :: Line v n) ->
                 return
                   $dMonad (case x1 of dt7 { Line ipv ipv1 -> OpenTrail dt7 })) } in
      >>=
        $dMonad
        (getWord8 $dMonadGet)
        (\ (ds :: Word8) ->
           case ds of { W8# x ->
           case x of {
             __DEFAULT -> lvl77;
             0## -> lvl78
           }
           })

-- RHS size: {terms: 114, types: 177, coercions: 36, joins: 0/6}
$fSerialTrail_$cserialize
  :: forall (v :: * -> *) n.
     (Serial1 v, Serial n) =>
     forall (m :: * -> *). MonadPut m => Trail v n -> m ()
$fSerialTrail_$cserialize
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerial :: Serial n)
      (@ (m :: * -> *))
      ($dMonadPut :: MonadPut m) ->
      let {
        f3 :: n -> m ()
        f3 = serialize $dSerial $dMonadPut } in
      let {
        fv :: v n -> m ()
        fv = serializeWith $dSerial1 $dMonadPut f3 } in
      let {
        $dMonad :: Monad m
        $dMonad = $p2MonadPut $dMonadPut } in
      let {
        lvl77 :: m ()
        lvl77 = putWord8 $dMonadPut lvl8 } in
      let {
        lvl78 :: m ()
        lvl78 = putWord8 $dMonadPut lvl7 } in
      let {
        lvl79 :: Segment v n -> m ()
        lvl79
          = \ (ds :: Segment v n) ->
              case ds of {
                Linear v1 -> >> $dMonad lvl78 (fv v1);
                Cubic c1 c2 c3 ->
                  >> $dMonad (>> $dMonad (>> $dMonad lvl77 (fv c1)) (fv c2)) (fv c3)
              } } in
      \ (ds :: Trail v n) ->
        case ds of {
          OpenTrail l ->
            case l of { Line ss o ->
            >>
              $dMonad
              lvl78
              (>>
                 $dMonad
                 ($fSerial1HashMap_$cserializeWith1
                    $dMonadPut
                    lvl79
                    ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
                 (serializeWith $dSerial1 $dMonadPut f3 o))
            };
          ClosedTrail l ->
            case l of { Loop l1 c ->
            case l1 of { Line ss o ->
            >>
              $dMonad
              lvl77
              (>>
                 $dMonad
                 (>>
                    $dMonad
                    ($fSerial1HashMap_$cserializeWith1
                       $dMonadPut
                       lvl79
                       ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
                    (serializeWith $dSerial1 $dMonadPut f3 o))
                 (case c of {
                    LinearClosing -> lvl78;
                    CubicClosing c1 c2 -> >> $dMonad (>> $dMonad lvl77 (fv c1)) (fv c2)
                  }))
            }
            }
        }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fSerialTrail
  :: forall (v :: * -> *) n.
     (Serial1 v, Serial n) =>
     Serial (Trail v n)
$fSerialTrail
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerial :: Serial n) ->
      C:Serial
        ($fSerialTrail_$cserialize $dSerial1 $dSerial)
        ($fSerialTrail_$cdeserialize $dSerial1 $dSerial)

-- RHS size: {terms: 542, types: 456, coercions: 122, joins: 0/15}
$w$cget
  :: forall (v :: * -> *) n.
     (Serial1 v, Binary n) =>
     forall r.
     Addr#
     -> ForeignPtrContents
     -> Int#
     -> Int#
     -> Success (Trail v n) r
     -> Decoder r
$w$cget
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Serial1 v)
      (w1 :: Binary n)
      (@ r)
      (ww :: Addr#)
      (ww1 :: ForeignPtrContents)
      (ww2 :: Int#)
      (ww3 :: Int#)
      (w2 :: Success (Trail v n) r) ->
      let {
        m :: Get n
        m = get w1 } in
      let {
        mv :: Get (v n)
        mv = deserializeWith w $fMonadGetGet0 m } in
      let {
        lvl77 :: ByteString -> Seq (Segment v n) -> Decoder r
        lvl77
          = \ (i' :: ByteString) (a1 :: Seq (Segment v n)) ->
              ((deserializeWith w $fMonadGetGet0 m) `cast` <Co:3>)
                i'
                (\ (i'1 :: ByteString) (a2 :: v n) ->
                   case i'1 of wild { PS dt7 dt8 dt9 dt10 ->
                   let {
                     lvl78 :: Trail v n
                     lvl78
                       = case a1 `cast` <Co:4> of nt { __DEFAULT ->
                         case a2 of dt11 { __DEFAULT ->
                         ClosedTrail (Loop (Line (nt `cast` <Co:5>) dt11) LinearClosing)
                         }
                         } } in
                   let {
                     lvl79 :: ByteString -> v n -> Decoder r
                     lvl79
                       = \ (i'2 :: ByteString) (a3 :: v n) ->
                           (mv `cast` <Co:3>)
                             i'2
                             (\ (i'3 :: ByteString) (a4 :: v n) ->
                                w2
                                  i'3
                                  (case a1 `cast` <Co:4> of nt { __DEFAULT ->
                                   case a2 of dt11 { __DEFAULT ->
                                   case a3 of dt12 { __DEFAULT ->
                                   case a4 of dt13 { __DEFAULT ->
                                   ClosedTrail
                                     (Loop (Line (nt `cast` <Co:5>) dt11) (CubicClosing dt12 dt13))
                                   }
                                   }
                                   }
                                   })) } in
                   case tagToEnum# (>=# dt10 1#) of {
                     False ->
                       readN1
                         lvl9
                         lvl10
                         lvl11
                         (lvl14 `cast` <Co:6>)
                         wild
                         (\ _ (a3 :: ByteString) ->
                            case a3 of { PS dt11 dt12 dt13 dt14 ->
                            case readWord8OffAddr# (plusAddr# dt11 dt13) 0# realWorld# of
                            { (# ipv, ipv1 #) ->
                            case touch# dt12 ipv of { __DEFAULT ->
                            case ipv1 of {
                              __DEFAULT ->
                                (mv `cast` <Co:3>) (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) lvl79;
                              0## -> w2 (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) lvl78
                            }
                            }
                            }
                            });
                     True ->
                       case readWord8OffAddr# (plusAddr# dt7 dt9) 0# realWorld# of
                       { (# ipv, ipv1 #) ->
                       case touch# dt8 ipv of { __DEFAULT ->
                       case ipv1 of {
                         __DEFAULT ->
                           (mv `cast` <Co:3>) (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) lvl79;
                         0## -> w2 (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) lvl78
                       }
                       }
                       }
                   }
                   }) } in
      let {
        lvl78 :: ByteString -> Seq (Segment v n) -> Decoder r
        lvl78
          = \ (i' :: ByteString) (a1 :: Seq (Segment v n)) ->
              ((deserializeWith w $fMonadGetGet0 m) `cast` <Co:3>)
                i'
                (\ (i'1 :: ByteString) (a2 :: v n) ->
                   w2
                     i'1
                     (case a1 `cast` <Co:4> of nt { __DEFAULT ->
                      case a2 of dt7 { __DEFAULT ->
                      OpenTrail (Line (nt `cast` <Co:5>) dt7)
                      }
                      })) } in
      let {
        mv1 :: Get (v n)
        mv1 = deserializeWith w $fMonadGetGet0 m } in
      let {
        lvl79
          :: forall r1. ByteString -> Success (Segment v n) r1 -> Decoder r1
        lvl79
          = \ (@ r1) (i :: ByteString) (ks :: Success (Segment v n) r1) ->
              case i of wild { PS dt7 dt8 dt9 dt10 ->
              let {
                lvl80 :: ByteString -> v n -> Decoder r1
                lvl80
                  = \ (i' :: ByteString) (a1 :: v n) -> ks i' ($WLinear a1) } in
              let {
                lvl81 :: ByteString -> v n -> Decoder r1
                lvl81
                  = \ (i' :: ByteString) (a1 :: v n) ->
                      (mv1 `cast` <Co:3>)
                        i'
                        (\ (i'1 :: ByteString) (a2 :: v n) ->
                           (mv1 `cast` <Co:3>)
                             i'1
                             (\ (i'2 :: ByteString) (a3 :: v n) ->
                                ks i'2 ($WCubic a1 a2 a3))) } in
              case tagToEnum# (>=# dt10 1#) of {
                False ->
                  readN1
                    lvl9
                    lvl10
                    lvl11
                    (lvl14 `cast` <Co:6>)
                    wild
                    (\ _ (a1 :: ByteString) ->
                       case a1 of { PS dt11 dt12 dt13 dt14 ->
                       case readWord8OffAddr# (plusAddr# dt11 dt13) 0# realWorld# of
                       { (# ipv, ipv1 #) ->
                       case touch# dt12 ipv of { __DEFAULT ->
                       case ipv1 of {
                         __DEFAULT ->
                           (mv1 `cast` <Co:3>) (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) lvl81;
                         0## ->
                           (mv1 `cast` <Co:3>) (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) lvl80
                       }
                       }
                       }
                       });
                True ->
                  case readWord8OffAddr# (plusAddr# dt7 dt9) 0# realWorld# of
                  { (# ipv, ipv1 #) ->
                  case touch# dt8 ipv of { __DEFAULT ->
                  case ipv1 of {
                    __DEFAULT ->
                      (mv1 `cast` <Co:3>) (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) lvl81;
                    0## ->
                      (mv1 `cast` <Co:3>) (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) lvl80
                  }
                  }
                  }
              }
              } } in
      let {
        mv2 :: Get (v n)
        mv2 = deserializeWith w $fMonadGetGet0 m } in
      let {
        lvl80
          :: forall r1. ByteString -> Success (Segment v n) r1 -> Decoder r1
        lvl80
          = \ (@ r1) (i :: ByteString) (ks :: Success (Segment v n) r1) ->
              case i of wild { PS dt7 dt8 dt9 dt10 ->
              let {
                lvl81 :: ByteString -> v n -> Decoder r1
                lvl81
                  = \ (i' :: ByteString) (a1 :: v n) -> ks i' ($WLinear a1) } in
              let {
                lvl82 :: ByteString -> v n -> Decoder r1
                lvl82
                  = \ (i' :: ByteString) (a1 :: v n) ->
                      (mv2 `cast` <Co:3>)
                        i'
                        (\ (i'1 :: ByteString) (a2 :: v n) ->
                           (mv2 `cast` <Co:3>)
                             i'1
                             (\ (i'2 :: ByteString) (a3 :: v n) ->
                                ks i'2 ($WCubic a1 a2 a3))) } in
              case tagToEnum# (>=# dt10 1#) of {
                False ->
                  readN1
                    lvl9
                    lvl10
                    lvl11
                    (lvl14 `cast` <Co:6>)
                    wild
                    (\ _ (a1 :: ByteString) ->
                       case a1 of { PS dt11 dt12 dt13 dt14 ->
                       case readWord8OffAddr# (plusAddr# dt11 dt13) 0# realWorld# of
                       { (# ipv, ipv1 #) ->
                       case touch# dt12 ipv of { __DEFAULT ->
                       case ipv1 of {
                         __DEFAULT ->
                           (mv2 `cast` <Co:3>) (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) lvl82;
                         0## ->
                           (mv2 `cast` <Co:3>) (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) lvl81
                       }
                       }
                       }
                       });
                True ->
                  case readWord8OffAddr# (plusAddr# dt7 dt9) 0# realWorld# of
                  { (# ipv, ipv1 #) ->
                  case touch# dt8 ipv of { __DEFAULT ->
                  case ipv1 of {
                    __DEFAULT ->
                      (mv2 `cast` <Co:3>) (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) lvl82;
                    0## ->
                      (mv2 `cast` <Co:3>) (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) lvl81
                  }
                  }
                  }
              }
              } } in
      let {
        $wks :: ByteString -> Word# -> Decoder r
        $wks
          = \ (w3 :: ByteString) (ww4 :: Word#) ->
              case ww4 of {
                __DEFAULT ->
                  (($fSerial1Seq_$cdeserializeWith
                      $fMonadGetGet0 (lvl80 `cast` <Co:5>))
                   `cast` <Co:5>)
                    w3 lvl77;
                0## ->
                  (($fSerial1Seq_$cdeserializeWith
                      $fMonadGetGet0 (lvl79 `cast` <Co:5>))
                   `cast` <Co:5>)
                    w3 lvl78
              } } in
      case tagToEnum# (>=# ww3 1#) of {
        False ->
          readN1
            lvl9
            lvl10
            lvl11
            (lvl14 `cast` <Co:6>)
            (PS ww ww1 ww2 ww3)
            (\ _ (a1 :: ByteString) ->
               case a1 of { PS dt7 dt8 dt9 dt10 ->
               case readWord8OffAddr# (plusAddr# dt7 dt9) 0# realWorld# of
               { (# ipv, ipv1 #) ->
               case touch# dt8 ipv of { __DEFAULT ->
               $wks (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) ipv1
               }
               }
               });
        True ->
          case readWord8OffAddr# (plusAddr# ww ww2) 0# realWorld# of
          { (# ipv, ipv1 #) ->
          case touch# ww1 ipv of { __DEFAULT ->
          $wks (PS ww ww1 (+# ww2 1#) (-# ww3 1#)) ipv1
          }
          }
      }

-- RHS size: {terms: 18, types: 26, coercions: 0, joins: 0/0}
$cget
  :: forall (v :: * -> *) n.
     (Serial1 v, Binary n) =>
     forall r. ByteString -> Success (Trail v n) r -> Decoder r
$cget
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Serial1 v)
      (w1 :: Binary n)
      (@ r)
      (w2 :: ByteString)
      (w3 :: Success (Trail v n) r) ->
      case w2 of { PS ww1 ww2 ww3 ww4 ->
      $w$cget w w1 ww1 ww2 ww3 ww4 w3
      }

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
$fBinaryTrail_$cget
  :: forall (v :: * -> *) n. (Serial1 v, Binary n) => Get (Trail v n)
$fBinaryTrail_$cget = $cget `cast` <Co:19>

-- RHS size: {terms: 52, types: 31, coercions: 12, joins: 0/0}
$wdt2
  :: forall r.
     BuildStep r
     -> Addr#
     -> Addr#
     -> State# RealWorld
     -> (# State# RealWorld, BuildSignal r #)
$wdt2
  = \ (@ r)
      (w :: BuildStep r)
      (ww :: Addr#)
      (ww1 :: Addr#)
      (w1 :: State# RealWorld) ->
      case tagToEnum# (<# (minusAddr# ww1 ww) 1#) of {
        False ->
          case writeWord8OffAddr# ww 0# 0## w1 of s2 { __DEFAULT ->
          ((w (BufferRange (plusAddr# ww 1#) ww1)) `cast` <Co:3>) s2
          };
        True ->
          (# w1,
             BufferFull
               1#
               ww
               ((\ (ds :: BufferRange) (eta :: State# RealWorld) ->
                   case ds of { BufferRange dt7 dt8 ->
                   case writeWord8OffAddr# dt7 0# 0## eta of s2 { __DEFAULT ->
                   ((w (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                   }
                   })
                `cast` <Co:6>) #)
      }

-- RHS size: {terms: 12, types: 11, coercions: 0, joins: 0/0}
dt2
  :: forall r.
     BuildStep r
     -> BufferRange
     -> State# RealWorld
     -> (# State# RealWorld, BuildSignal r #)
dt2
  = \ (@ r)
      (w :: BuildStep r)
      (w1 :: BufferRange)
      (w2 :: State# RealWorld) ->
      case w1 of { BufferRange ww1 ww2 -> $wdt2 w ww1 ww2 w2 }

-- RHS size: {terms: 3, types: 1, coercions: 15, joins: 0/0}
lvl25 :: PairS ()
lvl25 = PairS () (dt2 `cast` <Co:15>)

-- RHS size: {terms: 609, types: 636, coercions: 259, joins: 0/33}
$fBinaryTrail_$cput
  :: forall (v :: * -> *) n.
     (Serial1 v, Binary n) =>
     Trail v n -> Put
$fBinaryTrail_$cput
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dBinary :: Binary n)
      (eta :: Trail v n) ->
      let {
        f3 :: n -> PutM ()
        f3 = put $dBinary } in
      case eta of {
        OpenTrail l ->
          case l of { Line ss o ->
          let {
            k :: PutM ()
            k = serializeWith $dSerial1 $fMonadPutPutM0 f3 o } in
          (PairS
             (case k `cast` <Co:2> of { PairS b1 w' -> b1 })
             ((\ (@ r) ->
                 let {
                   f4 :: BuildStep r -> BuildStep r
                   f4
                     = case ($fSerial1HashMap_$cserializeWith1
                               $fMonadPutPutM0
                               (let {
                                  fv :: v n -> PutM ()
                                  fv = serializeWith $dSerial1 $fMonadPutPutM0 f3 } in
                                \ (ds :: Segment v n) ->
                                  case ds of {
                                    Linear v1 ->
                                      let {
                                        k1 :: PutM ()
                                        k1 = fv v1 } in
                                      (PairS
                                         (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                         ((\ (@ r1) (x :: BuildStep r1) ->
                                             let {
                                               x1 :: BuildStep r1
                                               x1
                                                 = case k1 `cast` <Co:2> of { PairS b1 w' ->
                                                   (w' `cast` <Co:1>) x
                                                   } } in
                                             let {
                                               lvl77
                                                 :: BufferRange
                                                    -> State# RealWorld
                                                    -> (# State# RealWorld, BuildSignal r1 #)
                                               lvl77
                                                 = \ (ds1 :: BufferRange)
                                                     (eta1 :: State# RealWorld) ->
                                                     case ds1 of { BufferRange dt7 dt8 ->
                                                     case writeWord8OffAddr# dt7 0# 0## eta1 of s2
                                                     { __DEFAULT ->
                                                     ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                      `cast` <Co:3>)
                                                       s2
                                                     }
                                                     } } in
                                             (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                                                case eta1 of { BufferRange dt7 dt8 ->
                                                case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                                  False ->
                                                    case writeWord8OffAddr# dt7 0# 0## eta2 of s2
                                                    { __DEFAULT ->
                                                    ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                     `cast` <Co:3>)
                                                      s2
                                                    };
                                                  True ->
                                                    (# eta2,
                                                       BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                                }
                                                })
                                             `cast` <Co:6>)
                                          `cast` <Co:2>))
                                      `cast` <Co:3>;
                                    Cubic c1 c2 c3 ->
                                      let {
                                        k1 :: PutM ()
                                        k1 = fv c3 } in
                                      (PairS
                                         (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                         ((\ (@ r1) ->
                                             let {
                                               g :: BuildStep r1 -> BuildStep r1
                                               g = case (fv c1) `cast` <Co:2> of { PairS b1 w' ->
                                                   (w' `cast` <Co:1>)
                                                   } } in
                                             let {
                                               g1 :: BuildStep r1 -> BuildStep r1
                                               g1
                                                 = case (fv c2) `cast` <Co:2> of { PairS b1 w' ->
                                                   (w' `cast` <Co:1>)
                                                   } } in
                                             \ (x :: BuildStep r1) ->
                                               let {
                                                 x1 :: BuildStep r1
                                                 x1
                                                   = g (g1
                                                          (case k1 `cast` <Co:2> of { PairS b1 w' ->
                                                           (w' `cast` <Co:1>) x
                                                           })) } in
                                               let {
                                                 lvl77
                                                   :: BufferRange
                                                      -> State# RealWorld
                                                      -> (# State# RealWorld, BuildSignal r1 #)
                                                 lvl77
                                                   = \ (ds1 :: BufferRange)
                                                       (eta1 :: State# RealWorld) ->
                                                       case ds1 of { BufferRange dt7 dt8 ->
                                                       case writeWord8OffAddr# dt7 0# 1## eta1 of s2
                                                       { __DEFAULT ->
                                                       ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                        `cast` <Co:3>)
                                                         s2
                                                       }
                                                       } } in
                                               (\ (eta1 :: BufferRange)
                                                  (eta2 :: State# RealWorld) ->
                                                  case eta1 of { BufferRange dt7 dt8 ->
                                                  case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                                    False ->
                                                      case writeWord8OffAddr# dt7 0# 1## eta2 of s2
                                                      { __DEFAULT ->
                                                      ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                       `cast` <Co:3>)
                                                        s2
                                                      };
                                                    True ->
                                                      (# eta2,
                                                         BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                                  }
                                                  })
                                               `cast` <Co:6>)
                                          `cast` <Co:2>))
                                      `cast` <Co:3>
                                  })
                               ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
                            `cast` <Co:2>
                       of
                       { PairS ds w ->
                       (w `cast` <Co:1>)
                       } } in
                 \ (x :: BuildStep r) ->
                   let {
                     x1 :: BuildStep r
                     x1
                       = f4
                           (case k `cast` <Co:2> of { PairS b1 w' ->
                            (w' `cast` <Co:1>) x
                            }) } in
                   let {
                     lvl77
                       :: BufferRange
                          -> State# RealWorld -> (# State# RealWorld, BuildSignal r #)
                     lvl77
                       = \ (ds :: BufferRange) (eta1 :: State# RealWorld) ->
                           case ds of { BufferRange dt7 dt8 ->
                           case writeWord8OffAddr# dt7 0# 0## eta1 of s2 { __DEFAULT ->
                           ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                           }
                           } } in
                   (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                      case eta1 of { BufferRange dt7 dt8 ->
                      case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                        False ->
                          case writeWord8OffAddr# dt7 0# 0## eta2 of s2 { __DEFAULT ->
                          ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                          };
                        True -> (# eta2, BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                      }
                      })
                   `cast` <Co:6>)
              `cast` <Co:2>))
          `cast` <Co:3>
          };
        ClosedTrail l ->
          case l of { Loop l1 c ->
          case l1 of { Line ss o ->
          let {
            k :: PutM ()
            k = case c of {
                  LinearClosing -> lvl25 `cast` <Co:3>;
                  CubicClosing c1 c2 ->
                    let {
                      fv :: v n -> PutM ()
                      fv = serializeWith $dSerial1 $fMonadPutPutM0 f3 } in
                    let {
                      k1 :: PutM ()
                      k1 = fv c2 } in
                    (PairS
                       (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                       ((\ (@ r) ->
                           let {
                             g :: BuildStep r -> BuildStep r
                             g = case (fv c1) `cast` <Co:2> of { PairS b1 w' ->
                                 (w' `cast` <Co:1>)
                                 } } in
                           \ (x :: BuildStep r) ->
                             let {
                               x1 :: BuildStep r
                               x1
                                 = g (case k1 `cast` <Co:2> of { PairS b1 w' ->
                                      (w' `cast` <Co:1>) x
                                      }) } in
                             let {
                               lvl77
                                 :: BufferRange
                                    -> State# RealWorld -> (# State# RealWorld, BuildSignal r #)
                               lvl77
                                 = \ (ds :: BufferRange) (eta1 :: State# RealWorld) ->
                                     case ds of { BufferRange dt7 dt8 ->
                                     case writeWord8OffAddr# dt7 0# 1## eta1 of s2 { __DEFAULT ->
                                     ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                                     }
                                     } } in
                             (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                                case eta1 of { BufferRange dt7 dt8 ->
                                case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                  False ->
                                    case writeWord8OffAddr# dt7 0# 1## eta2 of s2 { __DEFAULT ->
                                    ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                                    };
                                  True -> (# eta2, BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                }
                                })
                             `cast` <Co:6>)
                        `cast` <Co:2>))
                    `cast` <Co:3>
                } } in
          (PairS
             (case k `cast` <Co:2> of { PairS b1 w' -> b1 })
             ((\ (@ r) ->
                 let {
                   f4 :: BuildStep r -> BuildStep r
                   f4
                     = case ($fSerial1HashMap_$cserializeWith1
                               $fMonadPutPutM0
                               (let {
                                  fv :: v n -> PutM ()
                                  fv = serializeWith $dSerial1 $fMonadPutPutM0 f3 } in
                                \ (ds :: Segment v n) ->
                                  case ds of {
                                    Linear v1 ->
                                      let {
                                        k1 :: PutM ()
                                        k1 = fv v1 } in
                                      (PairS
                                         (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                         ((\ (@ r1) (x :: BuildStep r1) ->
                                             let {
                                               x1 :: BuildStep r1
                                               x1
                                                 = case k1 `cast` <Co:2> of { PairS b1 w' ->
                                                   (w' `cast` <Co:1>) x
                                                   } } in
                                             let {
                                               lvl77
                                                 :: BufferRange
                                                    -> State# RealWorld
                                                    -> (# State# RealWorld, BuildSignal r1 #)
                                               lvl77
                                                 = \ (ds1 :: BufferRange)
                                                     (eta1 :: State# RealWorld) ->
                                                     case ds1 of { BufferRange dt7 dt8 ->
                                                     case writeWord8OffAddr# dt7 0# 0## eta1 of s2
                                                     { __DEFAULT ->
                                                     ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                      `cast` <Co:3>)
                                                       s2
                                                     }
                                                     } } in
                                             (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                                                case eta1 of { BufferRange dt7 dt8 ->
                                                case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                                  False ->
                                                    case writeWord8OffAddr# dt7 0# 0## eta2 of s2
                                                    { __DEFAULT ->
                                                    ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                     `cast` <Co:3>)
                                                      s2
                                                    };
                                                  True ->
                                                    (# eta2,
                                                       BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                                }
                                                })
                                             `cast` <Co:6>)
                                          `cast` <Co:2>))
                                      `cast` <Co:3>;
                                    Cubic c1 c2 c3 ->
                                      let {
                                        k1 :: PutM ()
                                        k1 = fv c3 } in
                                      (PairS
                                         (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                         ((\ (@ r1) ->
                                             let {
                                               g :: BuildStep r1 -> BuildStep r1
                                               g = case (fv c1) `cast` <Co:2> of { PairS b1 w' ->
                                                   (w' `cast` <Co:1>)
                                                   } } in
                                             let {
                                               g1 :: BuildStep r1 -> BuildStep r1
                                               g1
                                                 = case (fv c2) `cast` <Co:2> of { PairS b1 w' ->
                                                   (w' `cast` <Co:1>)
                                                   } } in
                                             \ (x :: BuildStep r1) ->
                                               let {
                                                 x1 :: BuildStep r1
                                                 x1
                                                   = g (g1
                                                          (case k1 `cast` <Co:2> of { PairS b1 w' ->
                                                           (w' `cast` <Co:1>) x
                                                           })) } in
                                               let {
                                                 lvl77
                                                   :: BufferRange
                                                      -> State# RealWorld
                                                      -> (# State# RealWorld, BuildSignal r1 #)
                                                 lvl77
                                                   = \ (ds1 :: BufferRange)
                                                       (eta1 :: State# RealWorld) ->
                                                       case ds1 of { BufferRange dt7 dt8 ->
                                                       case writeWord8OffAddr# dt7 0# 1## eta1 of s2
                                                       { __DEFAULT ->
                                                       ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                        `cast` <Co:3>)
                                                         s2
                                                       }
                                                       } } in
                                               (\ (eta1 :: BufferRange)
                                                  (eta2 :: State# RealWorld) ->
                                                  case eta1 of { BufferRange dt7 dt8 ->
                                                  case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                                    False ->
                                                      case writeWord8OffAddr# dt7 0# 1## eta2 of s2
                                                      { __DEFAULT ->
                                                      ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                       `cast` <Co:3>)
                                                        s2
                                                      };
                                                    True ->
                                                      (# eta2,
                                                         BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                                  }
                                                  })
                                               `cast` <Co:6>)
                                          `cast` <Co:2>))
                                      `cast` <Co:3>
                                  })
                               ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
                            `cast` <Co:2>
                       of
                       { PairS ds w ->
                       (w `cast` <Co:1>)
                       } } in
                 let {
                   g :: BuildStep r -> BuildStep r
                   g = case (serializeWith $dSerial1 $fMonadPutPutM0 f3 o)
                            `cast` <Co:2>
                       of
                       { PairS b1 w' ->
                       (w' `cast` <Co:1>)
                       } } in
                 \ (x :: BuildStep r) ->
                   let {
                     x1 :: BuildStep r
                     x1
                       = f4
                           (g (case k `cast` <Co:2> of { PairS b1 w' ->
                               (w' `cast` <Co:1>) x
                               })) } in
                   let {
                     lvl77
                       :: BufferRange
                          -> State# RealWorld -> (# State# RealWorld, BuildSignal r #)
                     lvl77
                       = \ (ds :: BufferRange) (eta1 :: State# RealWorld) ->
                           case ds of { BufferRange dt7 dt8 ->
                           case writeWord8OffAddr# dt7 0# 1## eta1 of s2 { __DEFAULT ->
                           ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                           }
                           } } in
                   (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                      case eta1 of { BufferRange dt7 dt8 ->
                      case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                        False ->
                          case writeWord8OffAddr# dt7 0# 1## eta2 of s2 { __DEFAULT ->
                          ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                          };
                        True -> (# eta2, BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                      }
                      })
                   `cast` <Co:6>)
              `cast` <Co:2>))
          `cast` <Co:3>
          }
          }
      }

Rec {
-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
$fBinaryTrail
  :: forall (v :: * -> *) n.
     (Serial1 v, Binary n) =>
     Binary (Trail v n)
$fBinaryTrail
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dBinary :: Binary n) ->
      C:Binary
        ($fBinaryTrail_$cput $dSerial1 $dBinary)
        ($fBinaryTrail_$cget $dSerial1 $dBinary)
        ($fBinaryTrail_$cputList $dSerial1 $dBinary)

-- RHS size: {terms: 8, types: 15, coercions: 0, joins: 0/0}
$fBinaryTrail_$cputList
  :: forall (v :: * -> *) n.
     (Serial1 v, Binary n) =>
     [Trail v n] -> Put
$fBinaryTrail_$cputList
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dBinary :: Binary n) ->
      defaultPutList ($fBinaryTrail $dSerial1 $dBinary)
end Rec }

Rec {
-- RHS size: {terms: 103, types: 77, coercions: 0, joins: 1/4}
$s$wgetMore3
  :: forall r.
     (ByteString -> Maybe ByteString -> More -> ByteString -> Result r)
     -> (ByteString
         -> Maybe ByteString -> More -> [[Char]] -> [Char] -> Result r)
     -> Maybe Int
     -> Maybe ByteString
     -> [ByteString]
     -> ByteString
     -> Int#
     -> Result r
$s$wgetMore3
  = \ (@ r)
      (sc
         :: ByteString
            -> Maybe ByteString -> More -> ByteString -> Result r)
      (sc1
         :: ByteString
            -> Maybe ByteString -> More -> [[Char]] -> [Char] -> Result r)
      (sc2 :: Maybe Int)
      (sc3 :: Maybe ByteString)
      (sc4 :: [ByteString])
      (sc5 :: ByteString)
      (sc6 :: Int#) ->
      let {
        tooFewBytes :: Result r
        tooFewBytes
          = case finalBuffer1 sc3 sc5 sc4 of b { __DEFAULT ->
            case concat (reverse1 (: sc5 sc4) []) of s
            { PS ipv1 ipv2 ipv3 ipv4 ->
            sc1 s b (Incomplete sc2) lvl19 lvl16
            }
            } } in
      let {
        ss1 :: [ByteString]
        ss1 = : sc5 sc4 } in
      Partial
        (\ (s :: ByteString) ->
           case s of wild2 { PS dt7 dt8 dt9 dt10 ->
           case tagToEnum# (<=# dt10 0#) of {
             False ->
               join {
                 $j :: Maybe Int -> Result r
                 $j (mb' :: Maybe Int)
                   = let {
                       n' :: Int#
                       n' = -# sc6 dt10 } in
                     case tagToEnum# (<=# n' 0#) of {
                       False -> $s$wgetMore3 sc sc1 mb' sc3 ss1 wild2 n';
                       True ->
                         case finalBuffer1 sc3 wild2 ss1 of b { __DEFAULT ->
                         case concat (reverse1 (: wild2 ss1) []) of s1
                         { PS ipv1 ipv2 ipv3 ipv4 ->
                         sc s1 b (Incomplete mb') s1
                         }
                         }
                     } } in
               case sc2 of {
                 Nothing -> jump $j Nothing;
                 Just l -> case l of { I# x -> jump $j (Just (I# (-# x dt10))) }
               };
             True -> tooFewBytes
           }
           })
end Rec }

Rec {
-- RHS size: {terms: 103, types: 77, coercions: 0, joins: 1/4}
$s$wgetMore4
  :: forall r.
     (ByteString -> Maybe ByteString -> More -> ByteString -> Result r)
     -> (ByteString
         -> Maybe ByteString -> More -> [[Char]] -> [Char] -> Result r)
     -> Maybe Int
     -> Maybe ByteString
     -> [ByteString]
     -> ByteString
     -> Int#
     -> Result r
$s$wgetMore4
  = \ (@ r)
      (sc
         :: ByteString
            -> Maybe ByteString -> More -> ByteString -> Result r)
      (sc1
         :: ByteString
            -> Maybe ByteString -> More -> [[Char]] -> [Char] -> Result r)
      (sc2 :: Maybe Int)
      (sc3 :: Maybe ByteString)
      (sc4 :: [ByteString])
      (sc5 :: ByteString)
      (sc6 :: Int#) ->
      let {
        tooFewBytes :: Result r
        tooFewBytes
          = case finalBuffer1 sc3 sc5 sc4 of b { __DEFAULT ->
            case concat (reverse1 (: sc5 sc4) []) of s
            { PS ipv1 ipv2 ipv3 ipv4 ->
            sc1 s b (Incomplete sc2) lvl19 lvl16
            }
            } } in
      let {
        ss1 :: [ByteString]
        ss1 = : sc5 sc4 } in
      Partial
        (\ (s :: ByteString) ->
           case s of wild2 { PS dt7 dt8 dt9 dt10 ->
           case tagToEnum# (<=# dt10 0#) of {
             False ->
               join {
                 $j :: Maybe Int -> Result r
                 $j (mb' :: Maybe Int)
                   = let {
                       n' :: Int#
                       n' = -# sc6 dt10 } in
                     case tagToEnum# (<=# n' 0#) of {
                       False -> $s$wgetMore4 sc sc1 mb' sc3 ss1 wild2 n';
                       True ->
                         case finalBuffer1 sc3 wild2 ss1 of b { __DEFAULT ->
                         case concat (reverse1 (: wild2 ss1) []) of s1
                         { PS ipv1 ipv2 ipv3 ipv4 ->
                         sc s1 b (Incomplete mb') s1
                         }
                         }
                     } } in
               case sc2 of {
                 Nothing -> jump $j Nothing;
                 Just l -> case l of { I# x -> jump $j (Just (I# (-# x dt10))) }
               };
             True -> tooFewBytes
           }
           })
end Rec }

Rec {
-- RHS size: {terms: 103, types: 77, coercions: 0, joins: 1/4}
$s$wgetMore5
  :: forall r.
     (ByteString -> Maybe ByteString -> More -> ByteString -> Result r)
     -> (ByteString
         -> Maybe ByteString -> More -> [[Char]] -> [Char] -> Result r)
     -> Maybe Int
     -> Maybe ByteString
     -> [ByteString]
     -> ByteString
     -> Int#
     -> Result r
$s$wgetMore5
  = \ (@ r)
      (sc
         :: ByteString
            -> Maybe ByteString -> More -> ByteString -> Result r)
      (sc1
         :: ByteString
            -> Maybe ByteString -> More -> [[Char]] -> [Char] -> Result r)
      (sc2 :: Maybe Int)
      (sc3 :: Maybe ByteString)
      (sc4 :: [ByteString])
      (sc5 :: ByteString)
      (sc6 :: Int#) ->
      let {
        tooFewBytes :: Result r
        tooFewBytes
          = case finalBuffer1 sc3 sc5 sc4 of b { __DEFAULT ->
            case concat (reverse1 (: sc5 sc4) []) of s
            { PS ipv1 ipv2 ipv3 ipv4 ->
            sc1 s b (Incomplete sc2) lvl19 lvl16
            }
            } } in
      let {
        ss1 :: [ByteString]
        ss1 = : sc5 sc4 } in
      Partial
        (\ (s :: ByteString) ->
           case s of wild2 { PS dt7 dt8 dt9 dt10 ->
           case tagToEnum# (<=# dt10 0#) of {
             False ->
               join {
                 $j :: Maybe Int -> Result r
                 $j (mb' :: Maybe Int)
                   = let {
                       n' :: Int#
                       n' = -# sc6 dt10 } in
                     case tagToEnum# (<=# n' 0#) of {
                       False -> $s$wgetMore5 sc sc1 mb' sc3 ss1 wild2 n';
                       True ->
                         case finalBuffer1 sc3 wild2 ss1 of b { __DEFAULT ->
                         case concat (reverse1 (: wild2 ss1) []) of s1
                         { PS ipv1 ipv2 ipv3 ipv4 ->
                         sc s1 b (Incomplete mb') s1
                         }
                         }
                     } } in
               case sc2 of {
                 Nothing -> jump $j Nothing;
                 Just l -> case l of { I# x -> jump $j (Just (I# (-# x dt10))) }
               };
             True -> tooFewBytes
           }
           })
end Rec }

Rec {
-- RHS size: {terms: 103, types: 77, coercions: 0, joins: 1/4}
$s$wgetMore6
  :: forall r.
     (ByteString -> Maybe ByteString -> More -> ByteString -> Result r)
     -> (ByteString
         -> Maybe ByteString -> More -> [[Char]] -> [Char] -> Result r)
     -> Maybe Int
     -> Maybe ByteString
     -> [ByteString]
     -> ByteString
     -> Int#
     -> Result r
$s$wgetMore6
  = \ (@ r)
      (sc
         :: ByteString
            -> Maybe ByteString -> More -> ByteString -> Result r)
      (sc1
         :: ByteString
            -> Maybe ByteString -> More -> [[Char]] -> [Char] -> Result r)
      (sc2 :: Maybe Int)
      (sc3 :: Maybe ByteString)
      (sc4 :: [ByteString])
      (sc5 :: ByteString)
      (sc6 :: Int#) ->
      let {
        tooFewBytes :: Result r
        tooFewBytes
          = case finalBuffer1 sc3 sc5 sc4 of b { __DEFAULT ->
            case concat (reverse1 (: sc5 sc4) []) of s
            { PS ipv1 ipv2 ipv3 ipv4 ->
            sc1 s b (Incomplete sc2) lvl19 lvl16
            }
            } } in
      let {
        ss1 :: [ByteString]
        ss1 = : sc5 sc4 } in
      Partial
        (\ (s :: ByteString) ->
           case s of wild2 { PS dt7 dt8 dt9 dt10 ->
           case tagToEnum# (<=# dt10 0#) of {
             False ->
               join {
                 $j :: Maybe Int -> Result r
                 $j (mb' :: Maybe Int)
                   = let {
                       n' :: Int#
                       n' = -# sc6 dt10 } in
                     case tagToEnum# (<=# n' 0#) of {
                       False -> $s$wgetMore6 sc sc1 mb' sc3 ss1 wild2 n';
                       True ->
                         case finalBuffer1 sc3 wild2 ss1 of b { __DEFAULT ->
                         case concat (reverse1 (: wild2 ss1) []) of s1
                         { PS ipv1 ipv2 ipv3 ipv4 ->
                         sc s1 b (Incomplete mb') s1
                         }
                         }
                     } } in
               case sc2 of {
                 Nothing -> jump $j Nothing;
                 Just l -> case l of { I# x -> jump $j (Just (I# (-# x dt10))) }
               };
             True -> tooFewBytes
           }
           })
end Rec }

-- RHS size: {terms: 1,022, types: 741, coercions: 83, joins: 4/43}
$w$cget1
  :: forall (v :: * -> *) n.
     (Serial1 v, Serialize n) =>
     forall r.
     Addr#
     -> ForeignPtrContents
     -> Int#
     -> Int#
     -> Buffer
     -> More
     -> Failure r
     -> Success (Trail v n) r
     -> Result r
$w$cget1
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Serial1 v)
      (w1 :: Serialize n)
      (@ r)
      (ww :: Addr#)
      (ww1 :: ForeignPtrContents)
      (ww2 :: Int#)
      (ww3 :: Int#)
      (w2 :: Buffer)
      (w3 :: More)
      (w4 :: Failure r)
      (w5 :: Success (Trail v n) r) ->
      let {
        x :: Int#
        x = -# 1# ww3 } in
      let {
        m :: Get n
        m = get w1 } in
      let {
        mv :: Get (v n)
        mv = deserializeWith w $fMonadGetGet m } in
      let {
        lvl77 :: Input -> Buffer -> More -> Seq (Segment v n) -> Result r
        lvl77
          = \ (s1 :: Input)
              (b1 :: Buffer)
              (m1 :: More)
              (a1 :: Seq (Segment v n)) ->
              ((deserializeWith w $fMonadGetGet m) `cast` <Co:3>)
                s1
                b1
                m1
                w4
                (\ (s2 :: Input) (b2 :: Buffer) (m2 :: More) (a2 :: v n) ->
                   case s2 of wild1 { PS dt7 dt8 dt9 dt10 ->
                   let {
                     x1 :: Int#
                     x1 = -# 1# dt10 } in
                   let {
                     lvl78 :: Trail v n
                     lvl78
                       = case a1 `cast` <Co:4> of nt { __DEFAULT ->
                         case a2 of dt11 { __DEFAULT ->
                         ClosedTrail (Loop (Line (nt `cast` <Co:5>) dt11) LinearClosing)
                         }
                         } } in
                   let {
                     lvl79 :: Input -> Buffer -> More -> v n -> Result r
                     lvl79
                       = \ (s3 :: Input) (b3 :: Buffer) (m3 :: More) (a3 :: v n) ->
                           (mv `cast` <Co:3>)
                             s3
                             b3
                             m3
                             w4
                             (\ (s4 :: Input) (b4 :: Buffer) (m4 :: More) (a4 :: v n) ->
                                w5
                                  s4
                                  b4
                                  m4
                                  (case a1 `cast` <Co:4> of nt { __DEFAULT ->
                                   case a2 of dt11 { __DEFAULT ->
                                   case a3 of dt12 { __DEFAULT ->
                                   case a4 of dt13 { __DEFAULT ->
                                   ClosedTrail
                                     (Loop (Line (nt `cast` <Co:5>) dt11) (CubicClosing dt12 dt13))
                                   }
                                   }
                                   }
                                   })) } in
                   let {
                     $wkarg
                       :: Input
                          -> Buffer
                          -> More
                          -> Addr#
                          -> ForeignPtrContents
                          -> Int#
                          -> Result r
                     $wkarg
                       = \ (w6 :: Input)
                           (w7 :: Buffer)
                           (w8 :: More)
                           (ww4 :: Addr#)
                           (ww5 :: ForeignPtrContents)
                           (ww6 :: Int#) ->
                           case readWord8OffAddr# (plusAddr# ww4 ww6) 0# realWorld# of
                           { (# ipv, ipv1 #) ->
                           case touch# ww5 ipv of { __DEFAULT ->
                           case ipv1 of {
                             __DEFAULT -> (mv `cast` <Co:3>) w6 w7 w8 w4 lvl79;
                             0## -> w5 w6 w7 w8 lvl78
                           }
                           }
                           } } in
                   case tagToEnum# (<=# x1 0#) of {
                     False ->
                       let {
                         w6 :: ByteString -> Buffer -> More -> ByteString -> Result r
                         w6
                           = \ _ (b3 :: Buffer) (m3 :: More) (a :: ByteString) ->
                               case a of { PS dt11 dt12 dt13 dt14 ->
                               $wkarg
                                 (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) b3 m3 dt11 dt12 dt13
                               } } in
                       let {
                         tooFewBytes :: Result r
                         tooFewBytes
                           = case finalBuffer1 b2 wild1 [] of b { __DEFAULT ->
                             case concat (reverse1 (: wild1 []) []) of s
                             { PS ipv1 ipv2 ipv3 ipv4 ->
                             w4 s b m2 lvl19 lvl16
                             }
                             } } in
                       case m2 of {
                         Complete -> tooFewBytes;
                         Incomplete mb ->
                           let {
                             ss1 :: [ByteString]
                             ss1 = : wild1 [] } in
                           Partial
                             (\ (s :: ByteString) ->
                                case s of wild4 { PS dt11 dt12 dt13 dt14 ->
                                case tagToEnum# (<=# dt14 0#) of {
                                  False ->
                                    join {
                                      $j :: Maybe Int -> Result r
                                      $j (mb' :: Maybe Int)
                                        = let {
                                            n' :: Int#
                                            n' = -# x1 dt14 } in
                                          case tagToEnum# (<=# n' 0#) of {
                                            False -> $s$wgetMore5 w6 w4 mb' b2 ss1 wild4 n';
                                            True ->
                                              case finalBuffer1 b2 wild4 ss1 of b { __DEFAULT ->
                                              case concat (reverse1 (: wild4 ss1) []) of
                                              { PS ipv1 ipv2 ipv3 ipv4 ->
                                              $wkarg
                                                (PS ipv1 ipv2 (+# ipv3 1#) (-# ipv4 1#))
                                                b
                                                (Incomplete mb')
                                                ipv1
                                                ipv2
                                                ipv3
                                              }
                                              }
                                          } } in
                                    case mb of {
                                      Nothing -> jump $j Nothing;
                                      Just l ->
                                        case l of { I# x2 -> jump $j (Just (I# (-# x2 dt14))) }
                                    };
                                  True -> tooFewBytes
                                }
                                })
                       };
                     True ->
                       $wkarg (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) b2 m2 dt7 dt8 dt9
                   }
                   }) } in
      let {
        lvl78 :: Input -> Buffer -> More -> Seq (Segment v n) -> Result r
        lvl78
          = \ (s1 :: Input)
              (b1 :: Buffer)
              (m1 :: More)
              (a1 :: Seq (Segment v n)) ->
              ((deserializeWith w $fMonadGetGet m) `cast` <Co:3>)
                s1
                b1
                m1
                w4
                (\ (s2 :: Input) (b2 :: Buffer) (m2 :: More) (a2 :: v n) ->
                   w5
                     s2
                     b2
                     m2
                     (case a1 `cast` <Co:4> of nt { __DEFAULT ->
                      case a2 of dt7 { __DEFAULT ->
                      OpenTrail (Line (nt `cast` <Co:5>) dt7)
                      }
                      })) } in
      let {
        mv1 :: Get (v n)
        mv1 = deserializeWith w $fMonadGetGet m } in
      let {
        lvl79
          :: forall r1.
             Input
             -> Buffer
             -> More
             -> Failure r1
             -> Success (Segment v n) r1
             -> Result r1
        lvl79
          = \ (@ r1)
              (s0 :: Input)
              (b0 :: Buffer)
              (m0 :: More)
              (kf :: Failure r1)
              (ks :: Success (Segment v n) r1) ->
              case s0 of wild1 { PS dt7 dt8 dt9 dt10 ->
              let {
                x1 :: Int#
                x1 = -# 1# dt10 } in
              let {
                lvl80 :: Input -> Buffer -> More -> v n -> Result r1
                lvl80
                  = \ (s1 :: Input) (b1 :: Buffer) (m1 :: More) (a1 :: v n) ->
                      ks s1 b1 m1 ($WLinear a1) } in
              let {
                lvl81 :: Input -> Buffer -> More -> v n -> Result r1
                lvl81
                  = \ (s1 :: Input) (b1 :: Buffer) (m1 :: More) (a1 :: v n) ->
                      (mv1 `cast` <Co:3>)
                        s1
                        b1
                        m1
                        kf
                        (\ (s2 :: Input) (b2 :: Buffer) (m2 :: More) (a2 :: v n) ->
                           (mv1 `cast` <Co:3>)
                             s2
                             b2
                             m2
                             kf
                             (\ (s3 :: Input) (b3 :: Buffer) (m3 :: More) (a3 :: v n) ->
                                ks s3 b3 m3 ($WCubic a1 a2 a3))) } in
              let {
                $wkarg
                  :: Input
                     -> Buffer
                     -> More
                     -> Addr#
                     -> ForeignPtrContents
                     -> Int#
                     -> Result r1
                $wkarg
                  = \ (w6 :: Input)
                      (w7 :: Buffer)
                      (w8 :: More)
                      (ww4 :: Addr#)
                      (ww5 :: ForeignPtrContents)
                      (ww6 :: Int#) ->
                      case readWord8OffAddr# (plusAddr# ww4 ww6) 0# realWorld# of
                      { (# ipv, ipv1 #) ->
                      case touch# ww5 ipv of { __DEFAULT ->
                      case ipv1 of {
                        __DEFAULT -> (mv1 `cast` <Co:3>) w6 w7 w8 kf lvl81;
                        0## -> (mv1 `cast` <Co:3>) w6 w7 w8 kf lvl80
                      }
                      }
                      } } in
              case tagToEnum# (<=# x1 0#) of {
                False ->
                  let {
                    w6 :: ByteString -> Buffer -> More -> ByteString -> Result r1
                    w6
                      = \ _ (b1 :: Buffer) (m1 :: More) (a :: ByteString) ->
                          case a of { PS dt11 dt12 dt13 dt14 ->
                          $wkarg
                            (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) b1 m1 dt11 dt12 dt13
                          } } in
                  let {
                    tooFewBytes :: Result r1
                    tooFewBytes
                      = case finalBuffer1 b0 wild1 [] of b { __DEFAULT ->
                        case concat (reverse1 (: wild1 []) []) of s
                        { PS ipv1 ipv2 ipv3 ipv4 ->
                        kf s b m0 lvl19 lvl16
                        }
                        } } in
                  case m0 of {
                    Complete -> tooFewBytes;
                    Incomplete mb ->
                      let {
                        ss1 :: [ByteString]
                        ss1 = : wild1 [] } in
                      Partial
                        (\ (s :: ByteString) ->
                           case s of wild4 { PS dt11 dt12 dt13 dt14 ->
                           case tagToEnum# (<=# dt14 0#) of {
                             False ->
                               join {
                                 $j :: Maybe Int -> Result r1
                                 $j (mb' :: Maybe Int)
                                   = let {
                                       n' :: Int#
                                       n' = -# x1 dt14 } in
                                     case tagToEnum# (<=# n' 0#) of {
                                       False -> $s$wgetMore6 w6 kf mb' b0 ss1 wild4 n';
                                       True ->
                                         case finalBuffer1 b0 wild4 ss1 of b { __DEFAULT ->
                                         case concat (reverse1 (: wild4 ss1) []) of
                                         { PS ipv1 ipv2 ipv3 ipv4 ->
                                         $wkarg
                                           (PS ipv1 ipv2 (+# ipv3 1#) (-# ipv4 1#))
                                           b
                                           (Incomplete mb')
                                           ipv1
                                           ipv2
                                           ipv3
                                         }
                                         }
                                     } } in
                               case mb of {
                                 Nothing -> jump $j Nothing;
                                 Just l -> case l of { I# x2 -> jump $j (Just (I# (-# x2 dt14))) }
                               };
                             True -> tooFewBytes
                           }
                           })
                  };
                True ->
                  $wkarg (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) b0 m0 dt7 dt8 dt9
              }
              } } in
      let {
        mv2 :: Get (v n)
        mv2 = deserializeWith w $fMonadGetGet m } in
      let {
        lvl80
          :: forall r1.
             Input
             -> Buffer
             -> More
             -> Failure r1
             -> Success (Segment v n) r1
             -> Result r1
        lvl80
          = \ (@ r1)
              (s0 :: Input)
              (b0 :: Buffer)
              (m0 :: More)
              (kf :: Failure r1)
              (ks :: Success (Segment v n) r1) ->
              case s0 of wild1 { PS dt7 dt8 dt9 dt10 ->
              let {
                x1 :: Int#
                x1 = -# 1# dt10 } in
              let {
                lvl81 :: Input -> Buffer -> More -> v n -> Result r1
                lvl81
                  = \ (s1 :: Input) (b1 :: Buffer) (m1 :: More) (a1 :: v n) ->
                      ks s1 b1 m1 ($WLinear a1) } in
              let {
                lvl82 :: Input -> Buffer -> More -> v n -> Result r1
                lvl82
                  = \ (s1 :: Input) (b1 :: Buffer) (m1 :: More) (a1 :: v n) ->
                      (mv2 `cast` <Co:3>)
                        s1
                        b1
                        m1
                        kf
                        (\ (s2 :: Input) (b2 :: Buffer) (m2 :: More) (a2 :: v n) ->
                           (mv2 `cast` <Co:3>)
                             s2
                             b2
                             m2
                             kf
                             (\ (s3 :: Input) (b3 :: Buffer) (m3 :: More) (a3 :: v n) ->
                                ks s3 b3 m3 ($WCubic a1 a2 a3))) } in
              let {
                $wkarg
                  :: Input
                     -> Buffer
                     -> More
                     -> Addr#
                     -> ForeignPtrContents
                     -> Int#
                     -> Result r1
                $wkarg
                  = \ (w6 :: Input)
                      (w7 :: Buffer)
                      (w8 :: More)
                      (ww4 :: Addr#)
                      (ww5 :: ForeignPtrContents)
                      (ww6 :: Int#) ->
                      case readWord8OffAddr# (plusAddr# ww4 ww6) 0# realWorld# of
                      { (# ipv, ipv1 #) ->
                      case touch# ww5 ipv of { __DEFAULT ->
                      case ipv1 of {
                        __DEFAULT -> (mv2 `cast` <Co:3>) w6 w7 w8 kf lvl82;
                        0## -> (mv2 `cast` <Co:3>) w6 w7 w8 kf lvl81
                      }
                      }
                      } } in
              case tagToEnum# (<=# x1 0#) of {
                False ->
                  let {
                    w6 :: ByteString -> Buffer -> More -> ByteString -> Result r1
                    w6
                      = \ _ (b1 :: Buffer) (m1 :: More) (a :: ByteString) ->
                          case a of { PS dt11 dt12 dt13 dt14 ->
                          $wkarg
                            (PS dt11 dt12 (+# dt13 1#) (-# dt14 1#)) b1 m1 dt11 dt12 dt13
                          } } in
                  let {
                    tooFewBytes :: Result r1
                    tooFewBytes
                      = case finalBuffer1 b0 wild1 [] of b { __DEFAULT ->
                        case concat (reverse1 (: wild1 []) []) of s
                        { PS ipv1 ipv2 ipv3 ipv4 ->
                        kf s b m0 lvl19 lvl16
                        }
                        } } in
                  case m0 of {
                    Complete -> tooFewBytes;
                    Incomplete mb ->
                      let {
                        ss1 :: [ByteString]
                        ss1 = : wild1 [] } in
                      Partial
                        (\ (s :: ByteString) ->
                           case s of wild4 { PS dt11 dt12 dt13 dt14 ->
                           case tagToEnum# (<=# dt14 0#) of {
                             False ->
                               join {
                                 $j :: Maybe Int -> Result r1
                                 $j (mb' :: Maybe Int)
                                   = let {
                                       n' :: Int#
                                       n' = -# x1 dt14 } in
                                     case tagToEnum# (<=# n' 0#) of {
                                       False -> $s$wgetMore4 w6 kf mb' b0 ss1 wild4 n';
                                       True ->
                                         case finalBuffer1 b0 wild4 ss1 of b { __DEFAULT ->
                                         case concat (reverse1 (: wild4 ss1) []) of
                                         { PS ipv1 ipv2 ipv3 ipv4 ->
                                         $wkarg
                                           (PS ipv1 ipv2 (+# ipv3 1#) (-# ipv4 1#))
                                           b
                                           (Incomplete mb')
                                           ipv1
                                           ipv2
                                           ipv3
                                         }
                                         }
                                     } } in
                               case mb of {
                                 Nothing -> jump $j Nothing;
                                 Just l -> case l of { I# x2 -> jump $j (Just (I# (-# x2 dt14))) }
                               };
                             True -> tooFewBytes
                           }
                           })
                  };
                True ->
                  $wkarg (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) b0 m0 dt7 dt8 dt9
              }
              } } in
      let {
        $wkarg
          :: Input
             -> Buffer
             -> More
             -> Addr#
             -> ForeignPtrContents
             -> Int#
             -> Result r
        $wkarg
          = \ (w6 :: Input)
              (w7 :: Buffer)
              (w8 :: More)
              (ww4 :: Addr#)
              (ww5 :: ForeignPtrContents)
              (ww6 :: Int#) ->
              case readWord8OffAddr# (plusAddr# ww4 ww6) 0# realWorld# of
              { (# ipv, ipv1 #) ->
              case touch# ww5 ipv of { __DEFAULT ->
              case ipv1 of {
                __DEFAULT ->
                  (($fSerial1Seq_$cdeserializeWith
                      $fMonadGetGet (lvl80 `cast` <Co:5>))
                   `cast` <Co:5>)
                    w6 w7 w8 w4 lvl77;
                0## ->
                  (($fSerial1Seq_$cdeserializeWith
                      $fMonadGetGet (lvl79 `cast` <Co:5>))
                   `cast` <Co:5>)
                    w6 w7 w8 w4 lvl78
              }
              }
              } } in
      case tagToEnum# (<=# x 0#) of {
        False ->
          let {
            w6 :: ByteString
            w6 = PS ww ww1 ww2 ww3 } in
          let {
            w7 :: ByteString -> Buffer -> More -> ByteString -> Result r
            w7
              = \ _ (b1 :: Buffer) (m1 :: More) (a :: ByteString) ->
                  case a of { PS dt7 dt8 dt9 dt10 ->
                  $wkarg (PS dt7 dt8 (+# dt9 1#) (-# dt10 1#)) b1 m1 dt7 dt8 dt9
                  } } in
          let {
            tooFewBytes :: Result r
            tooFewBytes
              = case finalBuffer1 w2 w6 [] of b { __DEFAULT ->
                case concat (reverse1 (: w6 []) []) of s
                { PS ipv1 ipv2 ipv3 ipv4 ->
                w4 s b w3 lvl19 lvl16
                }
                } } in
          case w3 of {
            Complete -> tooFewBytes;
            Incomplete mb ->
              let {
                ss1 :: [ByteString]
                ss1 = : w6 [] } in
              Partial
                (\ (s :: ByteString) ->
                   case s of wild3 { PS dt7 dt8 dt9 dt10 ->
                   case tagToEnum# (<=# dt10 0#) of {
                     False ->
                       join {
                         $j :: Maybe Int -> Result r
                         $j (mb' :: Maybe Int)
                           = let {
                               n' :: Int#
                               n' = -# x dt10 } in
                             case tagToEnum# (<=# n' 0#) of {
                               False -> $s$wgetMore3 w7 w4 mb' w2 ss1 wild3 n';
                               True ->
                                 case finalBuffer1 w2 wild3 ss1 of b { __DEFAULT ->
                                 case concat (reverse1 (: wild3 ss1) []) of
                                 { PS ipv1 ipv2 ipv3 ipv4 ->
                                 $wkarg
                                   (PS ipv1 ipv2 (+# ipv3 1#) (-# ipv4 1#))
                                   b
                                   (Incomplete mb')
                                   ipv1
                                   ipv2
                                   ipv3
                                 }
                                 }
                             } } in
                       case mb of {
                         Nothing -> jump $j Nothing;
                         Just l -> case l of { I# x1 -> jump $j (Just (I# (-# x1 dt10))) }
                       };
                     True -> tooFewBytes
                   }
                   })
          };
        True -> $wkarg (PS ww ww1 (+# ww2 1#) (-# ww3 1#)) w2 w3 ww ww1 ww2
      }

-- RHS size: {terms: 24, types: 30, coercions: 0, joins: 0/0}
$cget1
  :: forall (v :: * -> *) n.
     (Serial1 v, Serialize n) =>
     forall r.
     Input
     -> Buffer -> More -> Failure r -> Success (Trail v n) r -> Result r
$cget1
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Serial1 v)
      (w1 :: Serialize n)
      (@ r)
      (w2 :: Input)
      (w3 :: Buffer)
      (w4 :: More)
      (w5 :: Failure r)
      (w6 :: Success (Trail v n) r) ->
      case w2 of { PS ww1 ww2 ww3 ww4 ->
      $w$cget1 w w1 ww1 ww2 ww3 ww4 w3 w4 w5 w6
      }

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
$fSerializeTrail_$cget
  :: forall (v :: * -> *) n.
     (Serial1 v, Serialize n) =>
     Get (Trail v n)
$fSerializeTrail_$cget = $cget1 `cast` <Co:19>

-- RHS size: {terms: 52, types: 31, coercions: 12, joins: 0/0}
$wdt3
  :: forall r.
     BuildStep r
     -> Addr#
     -> Addr#
     -> State# RealWorld
     -> (# State# RealWorld, BuildSignal r #)
$wdt3
  = \ (@ r)
      (w :: BuildStep r)
      (ww :: Addr#)
      (ww1 :: Addr#)
      (w1 :: State# RealWorld) ->
      case tagToEnum# (<# (minusAddr# ww1 ww) 1#) of {
        False ->
          case writeWord8OffAddr# ww 0# 0## w1 of s2 { __DEFAULT ->
          ((w (BufferRange (plusAddr# ww 1#) ww1)) `cast` <Co:3>) s2
          };
        True ->
          (# w1,
             BufferFull
               1#
               ww
               ((\ (ds :: BufferRange) (eta :: State# RealWorld) ->
                   case ds of { BufferRange dt7 dt8 ->
                   case writeWord8OffAddr# dt7 0# 0## eta of s2 { __DEFAULT ->
                   ((w (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                   }
                   })
                `cast` <Co:6>) #)
      }

-- RHS size: {terms: 12, types: 11, coercions: 0, joins: 0/0}
dt3
  :: forall r.
     BuildStep r
     -> BufferRange
     -> State# RealWorld
     -> (# State# RealWorld, BuildSignal r #)
dt3
  = \ (@ r)
      (w :: BuildStep r)
      (w1 :: BufferRange)
      (w2 :: State# RealWorld) ->
      case w1 of { BufferRange ww1 ww2 -> $wdt3 w ww1 ww2 w2 }

-- RHS size: {terms: 3, types: 1, coercions: 15, joins: 0/0}
lvl26 :: PairS ()
lvl26 = PairS () (dt3 `cast` <Co:15>)

-- RHS size: {terms: 609, types: 636, coercions: 259, joins: 0/33}
$fSerializeTrail_$cput
  :: forall (v :: * -> *) n.
     (Serial1 v, Serialize n) =>
     Putter (Trail v n)
$fSerializeTrail_$cput
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerialize :: Serialize n)
      (eta :: Trail v n) ->
      let {
        f3 :: n -> PutM ()
        f3 = put $dSerialize } in
      case eta of {
        OpenTrail l ->
          case l of { Line ss o ->
          let {
            k :: PutM ()
            k = serializeWith $dSerial1 $fMonadPutPutM f3 o } in
          (PairS
             (case k `cast` <Co:2> of { PairS b1 w' -> b1 })
             ((\ (@ r) ->
                 let {
                   f4 :: BuildStep r -> BuildStep r
                   f4
                     = case ($fSerial1HashMap_$cserializeWith1
                               $fMonadPutPutM
                               (let {
                                  fv :: v n -> PutM ()
                                  fv = serializeWith $dSerial1 $fMonadPutPutM f3 } in
                                \ (ds :: Segment v n) ->
                                  case ds of {
                                    Linear v1 ->
                                      let {
                                        k1 :: PutM ()
                                        k1 = fv v1 } in
                                      (PairS
                                         (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                         ((\ (@ r1) (x :: BuildStep r1) ->
                                             let {
                                               x1 :: BuildStep r1
                                               x1
                                                 = case k1 `cast` <Co:2> of { PairS b1 w' ->
                                                   (w' `cast` <Co:1>) x
                                                   } } in
                                             let {
                                               lvl77
                                                 :: BufferRange
                                                    -> State# RealWorld
                                                    -> (# State# RealWorld, BuildSignal r1 #)
                                               lvl77
                                                 = \ (ds1 :: BufferRange)
                                                     (eta1 :: State# RealWorld) ->
                                                     case ds1 of { BufferRange dt7 dt8 ->
                                                     case writeWord8OffAddr# dt7 0# 0## eta1 of s2
                                                     { __DEFAULT ->
                                                     ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                      `cast` <Co:3>)
                                                       s2
                                                     }
                                                     } } in
                                             (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                                                case eta1 of { BufferRange dt7 dt8 ->
                                                case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                                  False ->
                                                    case writeWord8OffAddr# dt7 0# 0## eta2 of s2
                                                    { __DEFAULT ->
                                                    ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                     `cast` <Co:3>)
                                                      s2
                                                    };
                                                  True ->
                                                    (# eta2,
                                                       BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                                }
                                                })
                                             `cast` <Co:6>)
                                          `cast` <Co:2>))
                                      `cast` <Co:3>;
                                    Cubic c1 c2 c3 ->
                                      let {
                                        k1 :: PutM ()
                                        k1 = fv c3 } in
                                      (PairS
                                         (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                         ((\ (@ r1) ->
                                             let {
                                               g :: BuildStep r1 -> BuildStep r1
                                               g = case (fv c1) `cast` <Co:2> of { PairS b1 w' ->
                                                   (w' `cast` <Co:1>)
                                                   } } in
                                             let {
                                               g1 :: BuildStep r1 -> BuildStep r1
                                               g1
                                                 = case (fv c2) `cast` <Co:2> of { PairS b1 w' ->
                                                   (w' `cast` <Co:1>)
                                                   } } in
                                             \ (x :: BuildStep r1) ->
                                               let {
                                                 x1 :: BuildStep r1
                                                 x1
                                                   = g (g1
                                                          (case k1 `cast` <Co:2> of { PairS b1 w' ->
                                                           (w' `cast` <Co:1>) x
                                                           })) } in
                                               let {
                                                 lvl77
                                                   :: BufferRange
                                                      -> State# RealWorld
                                                      -> (# State# RealWorld, BuildSignal r1 #)
                                                 lvl77
                                                   = \ (ds1 :: BufferRange)
                                                       (eta1 :: State# RealWorld) ->
                                                       case ds1 of { BufferRange dt7 dt8 ->
                                                       case writeWord8OffAddr# dt7 0# 1## eta1 of s2
                                                       { __DEFAULT ->
                                                       ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                        `cast` <Co:3>)
                                                         s2
                                                       }
                                                       } } in
                                               (\ (eta1 :: BufferRange)
                                                  (eta2 :: State# RealWorld) ->
                                                  case eta1 of { BufferRange dt7 dt8 ->
                                                  case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                                    False ->
                                                      case writeWord8OffAddr# dt7 0# 1## eta2 of s2
                                                      { __DEFAULT ->
                                                      ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                       `cast` <Co:3>)
                                                        s2
                                                      };
                                                    True ->
                                                      (# eta2,
                                                         BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                                  }
                                                  })
                                               `cast` <Co:6>)
                                          `cast` <Co:2>))
                                      `cast` <Co:3>
                                  })
                               ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
                            `cast` <Co:2>
                       of
                       { PairS ds w ->
                       (w `cast` <Co:1>)
                       } } in
                 \ (x :: BuildStep r) ->
                   let {
                     x1 :: BuildStep r
                     x1
                       = f4
                           (case k `cast` <Co:2> of { PairS b1 w' ->
                            (w' `cast` <Co:1>) x
                            }) } in
                   let {
                     lvl77
                       :: BufferRange
                          -> State# RealWorld -> (# State# RealWorld, BuildSignal r #)
                     lvl77
                       = \ (ds :: BufferRange) (eta1 :: State# RealWorld) ->
                           case ds of { BufferRange dt7 dt8 ->
                           case writeWord8OffAddr# dt7 0# 0## eta1 of s2 { __DEFAULT ->
                           ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                           }
                           } } in
                   (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                      case eta1 of { BufferRange dt7 dt8 ->
                      case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                        False ->
                          case writeWord8OffAddr# dt7 0# 0## eta2 of s2 { __DEFAULT ->
                          ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                          };
                        True -> (# eta2, BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                      }
                      })
                   `cast` <Co:6>)
              `cast` <Co:2>))
          `cast` <Co:3>
          };
        ClosedTrail l ->
          case l of { Loop l1 c ->
          case l1 of { Line ss o ->
          let {
            k :: PutM ()
            k = case c of {
                  LinearClosing -> lvl26 `cast` <Co:3>;
                  CubicClosing c1 c2 ->
                    let {
                      fv :: v n -> PutM ()
                      fv = serializeWith $dSerial1 $fMonadPutPutM f3 } in
                    let {
                      k1 :: PutM ()
                      k1 = fv c2 } in
                    (PairS
                       (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                       ((\ (@ r) ->
                           let {
                             g :: BuildStep r -> BuildStep r
                             g = case (fv c1) `cast` <Co:2> of { PairS b1 w' ->
                                 (w' `cast` <Co:1>)
                                 } } in
                           \ (x :: BuildStep r) ->
                             let {
                               x1 :: BuildStep r
                               x1
                                 = g (case k1 `cast` <Co:2> of { PairS b1 w' ->
                                      (w' `cast` <Co:1>) x
                                      }) } in
                             let {
                               lvl77
                                 :: BufferRange
                                    -> State# RealWorld -> (# State# RealWorld, BuildSignal r #)
                               lvl77
                                 = \ (ds :: BufferRange) (eta1 :: State# RealWorld) ->
                                     case ds of { BufferRange dt7 dt8 ->
                                     case writeWord8OffAddr# dt7 0# 1## eta1 of s2 { __DEFAULT ->
                                     ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                                     }
                                     } } in
                             (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                                case eta1 of { BufferRange dt7 dt8 ->
                                case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                  False ->
                                    case writeWord8OffAddr# dt7 0# 1## eta2 of s2 { __DEFAULT ->
                                    ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                                    };
                                  True -> (# eta2, BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                }
                                })
                             `cast` <Co:6>)
                        `cast` <Co:2>))
                    `cast` <Co:3>
                } } in
          (PairS
             (case k `cast` <Co:2> of { PairS b1 w' -> b1 })
             ((\ (@ r) ->
                 let {
                   f4 :: BuildStep r -> BuildStep r
                   f4
                     = case ($fSerial1HashMap_$cserializeWith1
                               $fMonadPutPutM
                               (let {
                                  fv :: v n -> PutM ()
                                  fv = serializeWith $dSerial1 $fMonadPutPutM f3 } in
                                \ (ds :: Segment v n) ->
                                  case ds of {
                                    Linear v1 ->
                                      let {
                                        k1 :: PutM ()
                                        k1 = fv v1 } in
                                      (PairS
                                         (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                         ((\ (@ r1) (x :: BuildStep r1) ->
                                             let {
                                               x1 :: BuildStep r1
                                               x1
                                                 = case k1 `cast` <Co:2> of { PairS b1 w' ->
                                                   (w' `cast` <Co:1>) x
                                                   } } in
                                             let {
                                               lvl77
                                                 :: BufferRange
                                                    -> State# RealWorld
                                                    -> (# State# RealWorld, BuildSignal r1 #)
                                               lvl77
                                                 = \ (ds1 :: BufferRange)
                                                     (eta1 :: State# RealWorld) ->
                                                     case ds1 of { BufferRange dt7 dt8 ->
                                                     case writeWord8OffAddr# dt7 0# 0## eta1 of s2
                                                     { __DEFAULT ->
                                                     ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                      `cast` <Co:3>)
                                                       s2
                                                     }
                                                     } } in
                                             (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                                                case eta1 of { BufferRange dt7 dt8 ->
                                                case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                                  False ->
                                                    case writeWord8OffAddr# dt7 0# 0## eta2 of s2
                                                    { __DEFAULT ->
                                                    ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                     `cast` <Co:3>)
                                                      s2
                                                    };
                                                  True ->
                                                    (# eta2,
                                                       BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                                }
                                                })
                                             `cast` <Co:6>)
                                          `cast` <Co:2>))
                                      `cast` <Co:3>;
                                    Cubic c1 c2 c3 ->
                                      let {
                                        k1 :: PutM ()
                                        k1 = fv c3 } in
                                      (PairS
                                         (case k1 `cast` <Co:2> of { PairS b1 w' -> b1 })
                                         ((\ (@ r1) ->
                                             let {
                                               g :: BuildStep r1 -> BuildStep r1
                                               g = case (fv c1) `cast` <Co:2> of { PairS b1 w' ->
                                                   (w' `cast` <Co:1>)
                                                   } } in
                                             let {
                                               g1 :: BuildStep r1 -> BuildStep r1
                                               g1
                                                 = case (fv c2) `cast` <Co:2> of { PairS b1 w' ->
                                                   (w' `cast` <Co:1>)
                                                   } } in
                                             \ (x :: BuildStep r1) ->
                                               let {
                                                 x1 :: BuildStep r1
                                                 x1
                                                   = g (g1
                                                          (case k1 `cast` <Co:2> of { PairS b1 w' ->
                                                           (w' `cast` <Co:1>) x
                                                           })) } in
                                               let {
                                                 lvl77
                                                   :: BufferRange
                                                      -> State# RealWorld
                                                      -> (# State# RealWorld, BuildSignal r1 #)
                                                 lvl77
                                                   = \ (ds1 :: BufferRange)
                                                       (eta1 :: State# RealWorld) ->
                                                       case ds1 of { BufferRange dt7 dt8 ->
                                                       case writeWord8OffAddr# dt7 0# 1## eta1 of s2
                                                       { __DEFAULT ->
                                                       ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                        `cast` <Co:3>)
                                                         s2
                                                       }
                                                       } } in
                                               (\ (eta1 :: BufferRange)
                                                  (eta2 :: State# RealWorld) ->
                                                  case eta1 of { BufferRange dt7 dt8 ->
                                                  case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                                                    False ->
                                                      case writeWord8OffAddr# dt7 0# 1## eta2 of s2
                                                      { __DEFAULT ->
                                                      ((x1 (BufferRange (plusAddr# dt7 1#) dt8))
                                                       `cast` <Co:3>)
                                                        s2
                                                      };
                                                    True ->
                                                      (# eta2,
                                                         BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                                                  }
                                                  })
                                               `cast` <Co:6>)
                                          `cast` <Co:2>))
                                      `cast` <Co:3>
                                  })
                               ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ss `cast` <Co:4>)))
                            `cast` <Co:2>
                       of
                       { PairS ds w ->
                       (w `cast` <Co:1>)
                       } } in
                 let {
                   g :: BuildStep r -> BuildStep r
                   g = case (serializeWith $dSerial1 $fMonadPutPutM f3 o)
                            `cast` <Co:2>
                       of
                       { PairS b1 w' ->
                       (w' `cast` <Co:1>)
                       } } in
                 \ (x :: BuildStep r) ->
                   let {
                     x1 :: BuildStep r
                     x1
                       = f4
                           (g (case k `cast` <Co:2> of { PairS b1 w' ->
                               (w' `cast` <Co:1>) x
                               })) } in
                   let {
                     lvl77
                       :: BufferRange
                          -> State# RealWorld -> (# State# RealWorld, BuildSignal r #)
                     lvl77
                       = \ (ds :: BufferRange) (eta1 :: State# RealWorld) ->
                           case ds of { BufferRange dt7 dt8 ->
                           case writeWord8OffAddr# dt7 0# 1## eta1 of s2 { __DEFAULT ->
                           ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                           }
                           } } in
                   (\ (eta1 :: BufferRange) (eta2 :: State# RealWorld) ->
                      case eta1 of { BufferRange dt7 dt8 ->
                      case tagToEnum# (<# (minusAddr# dt8 dt7) 1#) of {
                        False ->
                          case writeWord8OffAddr# dt7 0# 1## eta2 of s2 { __DEFAULT ->
                          ((x1 (BufferRange (plusAddr# dt7 1#) dt8)) `cast` <Co:3>) s2
                          };
                        True -> (# eta2, BufferFull 1# dt7 (lvl77 `cast` <Co:6>) #)
                      }
                      })
                   `cast` <Co:6>)
              `cast` <Co:2>))
          `cast` <Co:3>
          }
          }
      }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fSerializeTrail
  :: forall (v :: * -> *) n.
     (Serial1 v, Serialize n) =>
     Serialize (Trail v n)
$fSerializeTrail
  = \ (@ (v :: * -> *))
      (@ n)
      ($dSerial1 :: Serial1 v)
      ($dSerialize :: Serialize n) ->
      C:Serialize
        ($fSerializeTrail_$cput $dSerial1 $dSerialize)
        ($fSerializeTrail_$cget $dSerial1 $dSerialize)

-- RHS size: {terms: 16, types: 33, coercions: 18, joins: 0/0}
$fEndValuesTrail_$catEnd
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Trail v n -> Codomain (Trail v n) (N (Trail v n))
$fEndValuesTrail_$catEnd
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (ds :: Trail v n) ->
      case ds of {
        OpenTrail l -> case l of { Line ds1 o -> o `cast` <Co:9> };
        ClosedTrail l -> (zero $dAdditive $dNum) `cast` <Co:9>
      }

-- RHS size: {terms: 17, types: 25, coercions: 9, joins: 0/1}
$fEndValuesTrail
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     EndValues (Trail v n)
$fEndValuesTrail
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      let {
        lvl77 :: v n
        lvl77 = zero $dAdditive $dNum } in
      C:EndValues
        (\ (ds :: Trail v n) ->
           case ds of { __DEFAULT -> lvl77 `cast` <Co:9> })
        ($fEndValuesTrail_$catEnd $dAdditive $dNum)

-- RHS size: {terms: 13, types: 38, coercions: 20, joins: 0/0}
$fFromTrailLocated_$cfromLocTrail
  :: forall t.
     FromTrail t =>
     Located (Trail (V (Located t)) (N (Located t))) -> Located t
$fFromTrailLocated_$cfromLocTrail
  = \ (@ t)
      ($dFromTrail :: FromTrail t)
      (eta :: Located (Trail (V (Located t)) (N (Located t)))) ->
      case eta `cast` <Co:6> of wild { Loc ds1 ds2 ->
      case ($dFromTrail `cast` <Co:2>) wild of dt7 { __DEFAULT ->
      Loc (ds1 `cast` <Co:12>) dt7
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 10, joins: 0/0}
$fFromTrailLocated
  :: forall t. FromTrail t => FromTrail (Located t)
$fFromTrailLocated
  = $fFromTrailLocated_$cfromLocTrail `cast` <Co:10>

-- RHS size: {terms: 3, types: 9, coercions: 28, joins: 0/0}
$fFromTrailTrail :: forall (v :: * -> *) n. FromTrail (Trail v n)
$fFromTrailTrail
  = (\ (@ (v :: * -> *)) (@ n) -> unLoc) `cast` <Co:28>

-- RHS size: {terms: 121, types: 228, coercions: 56, joins: 1/1}
$fEqLoop_$c==
  :: forall (v :: * -> *) n.
     (Eq n, Eq1 v) =>
     Loop v n -> Loop v n -> Bool
$fEqLoop_$c==
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Eq n)
      (w1 :: Eq1 v)
      (w2 :: Loop v n)
      (w3 :: Loop v n) ->
      case w2 of { Loop ww1 ww2 ->
      case ww1 of { Line ww4 ww5 ->
      case w3 of { Loop ww7 ww8 ->
      case ww7 of { Line ww10 ww11 ->
      join {
        $j :: Bool
        $j
          = case $fEq1[]_$cliftEq
                   ($fEqSegment_$c== w1 w)
                   ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ww4 `cast` <Co:4>))
                   ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ww10 `cast` <Co:4>))
            of {
              False -> False;
              True ->
                case ww2 of {
                  LinearClosing ->
                    case ww8 of {
                      LinearClosing -> True;
                      CubicClosing ipv ipv1 -> False
                    };
                  CubicClosing b1 c1 ->
                    case ww8 of {
                      LinearClosing -> False;
                      CubicClosing b2 c2 ->
                        case (w1 `cast` <Co:2>) (== w) b1 b2 of {
                          False -> False;
                          True -> (w1 `cast` <Co:2>) (== w) c1 c2
                        }
                    }
                }
            } } in
      case ww4 `cast` <Co:4> of {
        EmptyT ->
          case ww10 `cast` <Co:4> of {
            EmptyT -> jump $j;
            Single x -> False;
            Deep dt7 ds ds1 ds2 ->
              case dt7 of {
                __DEFAULT -> False;
                0# -> jump $j
              }
          };
        Single x ->
          case ww10 `cast` <Co:4> of {
            EmptyT -> False;
            Single x1 -> jump $j;
            Deep dt7 ds ds1 ds2 ->
              case dt7 of {
                __DEFAULT -> False;
                1# -> jump $j
              }
          };
        Deep dt7 ds ds1 ds2 ->
          case ww10 `cast` <Co:4> of {
            EmptyT ->
              case dt7 of {
                __DEFAULT -> False;
                0# -> jump $j
              };
            Single x ->
              case dt7 of {
                __DEFAULT -> False;
                1# -> jump $j
              };
            Deep dt8 ds3 ds4 ds5 ->
              case tagToEnum# (==# dt7 dt8) of {
                False -> False;
                True -> jump $j
              }
          }
      }
      }
      }
      }
      }

-- RHS size: {terms: 126, types: 229, coercions: 56, joins: 1/1}
$fEqLoop_$c/=
  :: forall (v :: * -> *) n.
     (Eq n, Eq1 v) =>
     Loop v n -> Loop v n -> Bool
$fEqLoop_$c/=
  = \ (@ (v :: * -> *))
      (@ n)
      ($dEq :: Eq n)
      ($dEq1 :: Eq1 v)
      (a :: Loop v n)
      (b :: Loop v n) ->
      case a of { Loop ww1 ww2 ->
      case ww1 of { Line ww4 ww5 ->
      case b of { Loop ww7 ww8 ->
      case ww7 of { Line ww10 ww11 ->
      join {
        $j :: Bool
        $j
          = case $fEq1[]_$cliftEq
                   ($fEqSegment_$c== $dEq1 $dEq)
                   ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ww4 `cast` <Co:4>))
                   ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ww10 `cast` <Co:4>))
            of {
              False -> True;
              True ->
                case ww2 of {
                  LinearClosing ->
                    case ww8 of {
                      LinearClosing -> False;
                      CubicClosing ipv ipv1 -> True
                    };
                  CubicClosing b1 c1 ->
                    case ww8 of {
                      LinearClosing -> True;
                      CubicClosing b2 c2 ->
                        case ($dEq1 `cast` <Co:2>) (== $dEq) b1 b2 of {
                          False -> True;
                          True ->
                            case ($dEq1 `cast` <Co:2>) (== $dEq) c1 c2 of {
                              False -> True;
                              True -> False
                            }
                        }
                    }
                }
            } } in
      case ww4 `cast` <Co:4> of {
        EmptyT ->
          case ww10 `cast` <Co:4> of {
            EmptyT -> jump $j;
            Single x -> True;
            Deep dt7 ds ds1 ds2 ->
              case dt7 of {
                __DEFAULT -> True;
                0# -> jump $j
              }
          };
        Single x ->
          case ww10 `cast` <Co:4> of {
            EmptyT -> True;
            Single x1 -> jump $j;
            Deep dt7 ds ds1 ds2 ->
              case dt7 of {
                __DEFAULT -> True;
                1# -> jump $j
              }
          };
        Deep dt7 ds ds1 ds2 ->
          case ww10 `cast` <Co:4> of {
            EmptyT ->
              case dt7 of {
                __DEFAULT -> True;
                0# -> jump $j
              };
            Single x ->
              case dt7 of {
                __DEFAULT -> True;
                1# -> jump $j
              };
            Deep dt8 ds3 ds4 ds5 ->
              case tagToEnum# (==# dt7 dt8) of {
                False -> True;
                True -> jump $j
              }
          }
      }
      }
      }
      }
      }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fEqLoop :: forall (v :: * -> *) n. (Eq n, Eq1 v) => Eq (Loop v n)
$fEqLoop
  = \ (@ (v :: * -> *)) (@ n) ($dEq :: Eq n) ($dEq1 :: Eq1 v) ->
      C:Eq ($fEqLoop_$c== $dEq $dEq1) ($fEqLoop_$c/= $dEq $dEq1)

-- RHS size: {terms: 211, types: 420, coercions: 108, joins: 2/2}
$fEqTrail_$c==
  :: forall (v :: * -> *) n.
     (Eq n, Eq1 v) =>
     Trail v n -> Trail v n -> Bool
$fEqTrail_$c==
  = \ (@ (v :: * -> *))
      (@ n)
      ($dEq :: Eq n)
      ($dEq1 :: Eq1 v)
      (ds :: Trail v n)
      (ds1 :: Trail v n) ->
      case ds of {
        OpenTrail a1 ->
          case a1 of { Line s1 ds2 ->
          case ds1 of {
            OpenTrail b1 ->
              case b1 of { Line s2 ds3 ->
              join {
                $j :: Bool
                $j
                  = $fEq1[]_$cliftEq
                      ($fEqSegment_$c== $dEq1 $dEq)
                      ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (s1 `cast` <Co:4>))
                      ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (s2 `cast` <Co:4>)) } in
              case s1 `cast` <Co:4> of {
                EmptyT ->
                  case s2 `cast` <Co:4> of {
                    EmptyT -> jump $j;
                    Single x -> False;
                    Deep dt7 ds4 ds5 ds6 ->
                      case dt7 of {
                        __DEFAULT -> False;
                        0# -> jump $j
                      }
                  };
                Single x ->
                  case s2 `cast` <Co:4> of {
                    EmptyT -> False;
                    Single x1 -> jump $j;
                    Deep dt7 ds4 ds5 ds6 ->
                      case dt7 of {
                        __DEFAULT -> False;
                        1# -> jump $j
                      }
                  };
                Deep dt7 ds4 ds5 ds6 ->
                  case s2 `cast` <Co:4> of {
                    EmptyT ->
                      case dt7 of {
                        __DEFAULT -> False;
                        0# -> jump $j
                      };
                    Single x ->
                      case dt7 of {
                        __DEFAULT -> False;
                        1# -> jump $j
                      };
                    Deep dt8 ds7 ds8 ds9 ->
                      case tagToEnum# (==# dt7 dt8) of {
                        False -> False;
                        True -> jump $j
                      }
                  }
              }
              };
            ClosedTrail ipv -> False
          }
          };
        ClosedTrail a1 ->
          case a1 of { Loop ww1 ww2 ->
          case ww1 of { Line ww4 ww5 ->
          case ds1 of {
            OpenTrail ipv -> False;
            ClosedTrail b1 ->
              case b1 of { Loop ww7 ww8 ->
              case ww7 of { Line ww10 ww11 ->
              join {
                $j :: Bool
                $j
                  = case $fEq1[]_$cliftEq
                           ($fEqSegment_$c== $dEq1 $dEq)
                           ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ww4 `cast` <Co:4>))
                           ($fEq1Seq_$cfoldr (: `cast` <Co:14>) [] (ww10 `cast` <Co:4>))
                    of {
                      False -> False;
                      True ->
                        case ww2 of {
                          LinearClosing ->
                            case ww8 of {
                              LinearClosing -> True;
                              CubicClosing ipv ipv1 -> False
                            };
                          CubicClosing b2 c1 ->
                            case ww8 of {
                              LinearClosing -> False;
                              CubicClosing b3 c2 ->
                                case ($dEq1 `cast` <Co:2>) (== $dEq) b2 b3 of {
                                  False -> False;
                                  True -> ($dEq1 `cast` <Co:2>) (== $dEq) c1 c2
                                }
                            }
                        }
                    } } in
              case ww4 `cast` <Co:4> of {
                EmptyT ->
                  case ww10 `cast` <Co:4> of {
                    EmptyT -> jump $j;
                    Single x -> False;
                    Deep dt7 ds2 ds3 ds4 ->
                      case dt7 of {
                        __DEFAULT -> False;
                        0# -> jump $j
                      }
                  };
                Single x ->
                  case ww10 `cast` <Co:4> of {
                    EmptyT -> False;
                    Single x1 -> jump $j;
                    Deep dt7 ds2 ds3 ds4 ->
                      case dt7 of {
                        __DEFAULT -> False;
                        1# -> jump $j
                      }
                  };
                Deep dt7 ds2 ds3 ds4 ->
                  case ww10 `cast` <Co:4> of {
                    EmptyT ->
                      case dt7 of {
                        __DEFAULT -> False;
                        0# -> jump $j
                      };
                    Single x ->
                      case dt7 of {
                        __DEFAULT -> False;
                        1# -> jump $j
                      };
                    Deep dt8 ds5 ds6 ds7 ->
                      case tagToEnum# (==# dt7 dt8) of {
                        False -> False;
                        True -> jump $j
                      }
                  }
              }
              }
              }
          }
          }
          }
      }

-- RHS size: {terms: 16, types: 19, coercions: 0, joins: 0/0}
$fEqTrail_$c/=
  :: forall (v :: * -> *) n.
     (Eq n, Eq1 v) =>
     Trail v n -> Trail v n -> Bool
$fEqTrail_$c/=
  = \ (@ (v :: * -> *))
      (@ n)
      ($dEq :: Eq n)
      ($dEq1 :: Eq1 v)
      (a :: Trail v n)
      (b :: Trail v n) ->
      case $fEqTrail_$c== $dEq $dEq1 a b of {
        False -> True;
        True -> False
      }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fEqTrail
  :: forall (v :: * -> *) n. (Eq n, Eq1 v) => Eq (Trail v n)
$fEqTrail
  = \ (@ (v :: * -> *)) (@ n) ($dEq :: Eq n) ($dEq1 :: Eq1 v) ->
      C:Eq ($fEqTrail_$c== $dEq $dEq1) ($fEqTrail_$c/= $dEq $dEq1)

-- RHS size: {terms: 20, types: 52, coercions: 9, joins: 0/0}
lineSeq
  :: forall (v :: * -> *) n. Lens' (Line v n) (Seq (Segment v n))
lineSeq
  = \ (@ (v :: * -> *))
      (@ n)
      (@ (f3 :: * -> *))
      ($dFunctor :: Functor f3)
      (eta :: Seq (Segment v n) -> f3 (Seq (Segment v n)))
      (eta1 :: Line v n) ->
      case eta1 of { Line s o ->
      fmap
        $dFunctor
        (\ (s' :: Seq (Segment v n)) ->
           case s' `cast` <Co:4> of nt { __DEFAULT ->
           Line (nt `cast` <Co:5>) o
           })
        (eta s)
      }

-- RHS size: {terms: 115, types: 215, coercions: 1,423, joins: 1/3}
lineFromSegments
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     [Segment v n] -> Line v n
lineFromSegments
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      let {
        z :: Line v n
        z = case zero $dAdditive $dNum of dt7 { __DEFAULT ->
            Line (EmptyT `cast` <Co:5>) dt7
            } } in
      letrec {
        go1 :: [Segment v n] -> Line v n
        go1
          = \ (ds :: [Segment v n]) ->
              case ds of {
                [] -> z;
                : y ys ->
                  case go1 ys of { Line ss o ->
                  join {
                    $j :: Seq (Segment v n) -> Line v n
                    $j (dt7 :: Seq (Segment v n))
                      = case ^+^
                               $dAdditive
                               $dNum
                               o
                               (case y of {
                                  Linear v1 -> v1;
                                  Cubic ds1 ds2 v1 -> v1
                                })
                        of dt8
                        { __DEFAULT ->
                        Line dt7 dt8
                        } } in
                  case ss `cast` <Co:32> of {
                    EmptyT -> jump $j ((Single (y `cast` <Co:31>)) `cast` <Co:200>);
                    Single b ->
                      jump $j
                        ((Deep 2# (One (y `cast` <Co:31>)) EmptyT (One b))
                         `cast` <Co:200>);
                    Deep dt7 ds1 m sf ->
                      case ds1 of {
                        One b ->
                          jump $j
                            ((Deep (+# 1# dt7) (Two (y `cast` <Co:31>) b) m sf)
                             `cast` <Co:200>);
                        Two b c ->
                          jump $j
                            ((Deep (+# 1# dt7) (Three (y `cast` <Co:31>) b c) m sf)
                             `cast` <Co:200>);
                        Three b c d ->
                          jump $j
                            ((Deep (+# 1# dt7) (Four (y `cast` <Co:31>) b c d) m sf)
                             `cast` <Co:200>);
                        Four b c d e ->
                          case m of m1 { __DEFAULT ->
                          jump $j
                            ((Deep
                                (+# 1# dt7)
                                (Two (y `cast` <Co:31>) b)
                                ($b:<|_$s$sconsTree m1 3# c d e)
                                sf)
                             `cast` <Co:200>)
                          }
                      }
                  }
                  }
              }; } in
      go1

-- RHS size: {terms: 128, types: 239, coercions: 1,423, joins: 1/4}
loopFromSegments
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     [Segment v n] -> ClosingSegment v n -> Loop v n
loopFromSegments
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      let {
        g :: Line v n
        g = case zero $dAdditive $dNum of dt7 { __DEFAULT ->
            Line (EmptyT `cast` <Co:5>) dt7
            } } in
      letrec {
        go1 :: [Segment v n] -> Line v n
        go1
          = \ (ds :: [Segment v n]) ->
              case ds of {
                [] -> g;
                : y ys ->
                  case go1 ys of { Line ss o ->
                  join {
                    $j :: Seq (Segment v n) -> Line v n
                    $j (dt7 :: Seq (Segment v n))
                      = case ^+^
                               $dAdditive
                               $dNum
                               o
                               (case y of {
                                  Linear v1 -> v1;
                                  Cubic ds1 ds2 v1 -> v1
                                })
                        of dt8
                        { __DEFAULT ->
                        Line dt7 dt8
                        } } in
                  case ss `cast` <Co:32> of {
                    EmptyT -> jump $j ((Single (y `cast` <Co:31>)) `cast` <Co:200>);
                    Single b ->
                      jump $j
                        ((Deep 2# (One (y `cast` <Co:31>)) EmptyT (One b))
                         `cast` <Co:200>);
                    Deep dt7 ds1 m sf ->
                      case ds1 of {
                        One b ->
                          jump $j
                            ((Deep (+# 1# dt7) (Two (y `cast` <Co:31>) b) m sf)
                             `cast` <Co:200>);
                        Two b c ->
                          jump $j
                            ((Deep (+# 1# dt7) (Three (y `cast` <Co:31>) b c) m sf)
                             `cast` <Co:200>);
                        Three b c d ->
                          jump $j
                            ((Deep (+# 1# dt7) (Four (y `cast` <Co:31>) b c d) m sf)
                             `cast` <Co:200>);
                        Four b c d e ->
                          case m of m1 { __DEFAULT ->
                          jump $j
                            ((Deep
                                (+# 1# dt7)
                                (Two (y `cast` <Co:31>) b)
                                ($b:<|_$s$sconsTree m1 3# c d e)
                                sf)
                             `cast` <Co:200>)
                          }
                      }
                  }
                  }
              }; } in
      \ (x :: [Segment v n]) ->
        let {
          dt7 :: Line v n
          dt7 = go1 x } in
        \ (dt8 :: ClosingSegment v n) ->
          case dt7 of dt9 { Line ipv ipv1 ->
          case dt8 of dt10 { __DEFAULT -> Loop dt9 dt10 }
          }

-- RHS size: {terms: 141, types: 324, coercions: 1,452, joins: 1/5}
fromSegments
  :: forall (v :: * -> *) n t.
     (InSpace v n t, FromTrail t) =>
     [Segment v n] -> t
fromSegments
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      ($d(%,,,%) :: InSpace v n t)
      ($dFromTrail :: FromTrail t)
      (eta :: [Segment v n]) ->
      case HEq_sc (($p2(%,,,%) $d(%,,,%)) `cast` <Co:5>) of cobox
      { __DEFAULT ->
      case HEq_sc (($p1(%,,,%) $d(%,,,%)) `cast` <Co:6>) of cobox1
      { __DEFAULT ->
      ($dFromTrail `cast` <Co:2>)
        (let {
           $dNum :: Num n
           $dNum = $p4(%,,,%) $d(%,,,%) } in
         let {
           $dAdditive :: Additive v
           $dAdditive = $p3(%,,,%) $d(%,,,%) } in
         case zero $dAdditive $dNum of nt { __DEFAULT ->
         let {
           z :: Line v n
           z = Line (EmptyT `cast` <Co:5>) nt } in
         letrec {
           go1 :: [Segment v n] -> Line v n
           go1
             = \ (ds :: [Segment v n]) ->
                 case ds of {
                   [] -> z;
                   : y ys ->
                     case go1 ys of { Line ss o ->
                     join {
                       $j :: Seq (Segment v n) -> Line v n
                       $j (dt7 :: Seq (Segment v n))
                         = case ^+^
                                  $dAdditive
                                  $dNum
                                  o
                                  (case y of {
                                     Linear v1 -> v1;
                                     Cubic ds1 ds2 v1 -> v1
                                   })
                           of dt8
                           { __DEFAULT ->
                           Line dt7 dt8
                           } } in
                     case ss `cast` <Co:32> of {
                       EmptyT -> jump $j ((Single (y `cast` <Co:31>)) `cast` <Co:200>);
                       Single b ->
                         jump $j
                           ((Deep 2# (One (y `cast` <Co:31>)) EmptyT (One b))
                            `cast` <Co:200>);
                       Deep dt7 ds1 m sf ->
                         case ds1 of {
                           One b ->
                             jump $j
                               ((Deep (+# 1# dt7) (Two (y `cast` <Co:31>) b) m sf)
                                `cast` <Co:200>);
                           Two b c ->
                             jump $j
                               ((Deep (+# 1# dt7) (Three (y `cast` <Co:31>) b c) m sf)
                                `cast` <Co:200>);
                           Three b c d ->
                             jump $j
                               ((Deep (+# 1# dt7) (Four (y `cast` <Co:31>) b c d) m sf)
                                `cast` <Co:200>);
                           Four b c d e ->
                             case m of m1 { __DEFAULT ->
                             jump $j
                               ((Deep
                                   (+# 1# dt7)
                                   (Two (y `cast` <Co:31>) b)
                                   ($b:<|_$s$sconsTree m1 3# c d e)
                                   sf)
                                `cast` <Co:200>)
                             }
                         }
                     }
                     }
                 }; } in
         case go1 eta of dt7 { Line ipv ipv1 ->
         (Loc (nt `cast` <Co:10>) (OpenTrail dt7)) `cast` <Co:6>
         }
         })
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lineSegParam1 :: Int
lineSegParam1 = I# -1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShow1Line1 :: Int
$fShow1Line1 = I# 0#

-- RHS size: {terms: 70, types: 94, coercions: 33, joins: 0/4}
$wlineSegParam
  :: forall (v :: * -> *) n.
     (Additive v, OrderedField n) =>
     Int -> n -> Seq (Segment v n) -> v n
$wlineSegParam
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: OrderedField n)
      (w2 :: Int)
      (w3 :: n)
      (ww
         :: Seq (Segment v n)
         Unf=OtherCon []) ->
      let {
        $dFloating :: Floating n
        $dFloating = $p1(%,%) w1 } in
      let {
        $dFractional :: Fractional n
        $dFractional = $p1Floating $dFloating } in
      let {
        $dNum :: Num n
        $dNum = $p1Fractional $dFractional } in
      let {
        z :: v n
        z = zero w $dNum } in
      $fFoldableFingerTree_$cfoldl2
        ((\ (g :: Int -> v n) (x :: Segment v n) (i :: Int) ->
            case i of { I# ipv ->
            case w2 of { I# y ->
            case tagToEnum# (==# ipv y) of {
              False ->
                ^+^
                  w
                  $dNum
                  (case x of {
                     Linear v1 -> v1;
                     Cubic ds1 ds2 v1 -> v1
                   })
                  (g (I# (-# ipv 1#)));
              True ->
                ($fParametricSegment_$catParam w $dNum x (w3 `cast` <Co:5>))
                `cast` <Co:7>
            }
            }
            })
         `cast` <Co:13>)
        (\ _ -> z)
        (ww `cast` <Co:4>)
        (case ww `cast` <Co:4> of {
           EmptyT -> lineSegParam1;
           Single x -> $fShow1Line1;
           Deep dt7 ds ds1 ds2 -> I# (-# dt7 1#)
         })

-- RHS size: {terms: 16, types: 26, coercions: 0, joins: 0/0}
lineSegParam
  :: forall (v :: * -> *) n.
     (Additive v, OrderedField n) =>
     Int -> n -> Line v n -> v n
lineSegParam
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: OrderedField n)
      (w2 :: Int)
      (w3 :: n)
      (w4 :: Line v n) ->
      case w4 of { Line ww1 ww2 -> $wlineSegParam w w1 w2 w3 ww1 }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
wrapLine :: forall (v :: * -> *) n. Line v n -> Trail v n
wrapLine = $WOpenTrail

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
wrapLoop :: forall (v :: * -> *) n. Loop v n -> Trail v n
wrapLoop = $WClosedTrail

-- RHS size: {terms: 18, types: 57, coercions: 38, joins: 0/0}
lvl27
  :: forall (v :: * -> *) n.
     Located (Trail v n)
     -> Either (Located (Line v n)) (Located (Loop v n))
lvl27
  = \ (@ (v :: * -> *)) (@ n) (ds :: Located (Trail v n)) ->
      case ds of { Loc p ds1 ->
      case ds1 of {
        OpenTrail t -> Left (Loc (p `cast` <Co:19>) t);
        ClosedTrail t -> Right (Loc (p `cast` <Co:19>) t)
      }
      }

-- RHS size: {terms: 21, types: 74, coercions: 38, joins: 0/0}
lvl28
  :: forall (v :: * -> *) n.
     Either (Located (Line v n)) (Located (Loop v n))
     -> Located (Trail v n)
lvl28
  = \ (@ (v :: * -> *))
      (@ n)
      (ds :: Either (Located (Line v n)) (Located (Loop v n))) ->
      case ds of {
        Left ds1 ->
          case ds1 of { Loc p t -> Loc (p `cast` <Co:19>) (OpenTrail t) };
        Right ds1 ->
          case ds1 of { Loc p t -> Loc (p `cast` <Co:19>) (ClosedTrail t) }
      }

-- RHS size: {terms: 12, types: 67, coercions: 0, joins: 0/0}
_LocTrail
  :: forall (v :: * -> *) n.
     Iso'
       (Located (Trail v n))
       (Either (Located (Line v n)) (Located (Loop v n)))
_LocTrail
  = \ (@ (v :: * -> *))
      (@ n)
      (@ (p :: * -> * -> *))
      (@ (f3 :: * -> *))
      ($dProfunctor :: Profunctor p)
      ($dFunctor :: Functor f3) ->
      dimap $dProfunctor lvl27 (fmap $dFunctor lvl28)

-- RHS size: {terms: 11, types: 30, coercions: 0, joins: 0/0}
lvl29
  :: forall (v :: * -> *) n.
     Trail v n -> Either (Trail v n) (Line v n)
lvl29
  = \ (@ (v :: * -> *)) (@ n) (s1 :: Trail v n) ->
      case s1 of wild {
        OpenTrail t -> Right t;
        ClosedTrail ipv -> Left wild
      }

-- RHS size: {terms: 31, types: 134, coercions: 0, joins: 0/2}
_Line :: forall (v :: * -> *) n. Prism' (Trail v n) (Line v n)
_Line
  = \ (@ (v :: * -> *))
      (@ n)
      (@ (p :: * -> * -> *))
      (@ (f3 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f3) ->
      let {
        f4
          :: p (Either (Trail v n) (Line v n)) (Either
                                                  (Trail v n) (f3 (Line v n)))
             -> p (Trail v n) (f3 (Trail v n))
        f4
          = dimap
              ($p1Choice $dChoice)
              lvl29
              (let {
                 ds :: f3 (Line v n) -> f3 (Trail v n)
                 ds = fmap ($p1Applicative $dApplicative) $WOpenTrail } in
               \ (ds1 :: Either (Trail v n) (f3 (Line v n))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (Line v n) (f3 (Line v n))) -> f4 (right' $dChoice x)

-- RHS size: {terms: 16, types: 54, coercions: 19, joins: 0/0}
lvl30
  :: forall (v :: * -> *) n.
     Located (Trail v n)
     -> Either (Located (Trail v n)) (Located (Line v n))
lvl30
  = \ (@ (v :: * -> *)) (@ n) (s1 :: Located (Trail v n)) ->
      case s1 of wild { Loc p a1 ->
      case a1 of {
        OpenTrail t -> Right (Loc (p `cast` <Co:19>) t);
        ClosedTrail ipv -> Left wild
      }
      }

-- RHS size: {terms: 2, types: 10, coercions: 1, joins: 0/0}
lvl31 :: forall (v :: * -> *). (v :: (* -> *)) ~~ (v :: (* -> *))
lvl31 = \ (@ (v :: * -> *)) -> Eq# @~ <Co:1>

-- RHS size: {terms: 2, types: 8, coercions: 1, joins: 0/0}
lvl32 :: forall n. (n :: *) ~~ (n :: *)
lvl32 = \ (@ n) -> Eq# @~ <Co:1>

-- RHS size: {terms: 5, types: 17, coercions: 12, joins: 0/0}
lvl33
  :: forall (v :: * -> *) n.
     ((v :: (* -> *)) ~ (v :: (* -> *)), (n :: *) ~ (n :: *))
lvl33
  = \ (@ (v :: * -> *)) (@ n) ->
      (lvl31 `cast` <Co:6>, lvl32 `cast` <Co:6>)

-- RHS size: {terms: 5, types: 16, coercions: 25, joins: 0/0}
lvl34
  :: forall (v :: * -> *) n.
     Located (Line v n) -> Located (Trail v n)
lvl34
  = \ (@ (v :: * -> *)) (@ n) ->
      mapLoc (lvl33 `cast` <Co:25>) $WOpenTrail

-- RHS size: {terms: 31, types: 162, coercions: 0, joins: 0/2}
_LocLine
  :: forall (v :: * -> *) n.
     Prism' (Located (Trail v n)) (Located (Line v n))
_LocLine
  = \ (@ (v :: * -> *))
      (@ n)
      (@ (p :: * -> * -> *))
      (@ (f3 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f3) ->
      let {
        f4
          :: p (Either (Located (Trail v n)) (Located (Line v n))) (Either
                                                                      (Located (Trail v n))
                                                                      (f3 (Located (Line v n))))
             -> p (Located (Trail v n)) (f3 (Located (Trail v n)))
        f4
          = dimap
              ($p1Choice $dChoice)
              lvl30
              (let {
                 ds :: f3 (Located (Line v n)) -> f3 (Located (Trail v n))
                 ds = fmap ($p1Applicative $dApplicative) lvl34 } in
               \ (ds1
                    :: Either (Located (Trail v n)) (f3 (Located (Line v n)))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (Located (Line v n)) (f3 (Located (Line v n)))) ->
        f4 (right' $dChoice x)

-- RHS size: {terms: 24, types: 92, coercions: 39, joins: 0/0}
fromLocLine
  :: forall (v :: * -> *) n t.
     (InSpace v n t, FromTrail t) =>
     Located (Line v n) -> t
fromLocLine
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      ($d(%,,,%) :: InSpace v n t)
      ($dFromTrail :: FromTrail t)
      (eta :: Located (Line v n)) ->
      case HEq_sc (($p2(%,,,%) $d(%,,,%)) `cast` <Co:5>) of cobox
      { __DEFAULT ->
      case HEq_sc (($p1(%,,,%) $d(%,,,%)) `cast` <Co:6>) of cobox1
      { __DEFAULT ->
      ($dFromTrail `cast` <Co:9>)
        (case eta of { Loc p a1 -> Loc (p `cast` <Co:19>) (OpenTrail a1) })
      }
      }

-- RHS size: {terms: 156, types: 406, coercions: 1,504, joins: 1/7}
fromLocSegments
  :: forall (v :: * -> *) n t.
     (InSpace v n t, FromTrail t) =>
     Located [Segment v n] -> t
fromLocSegments
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      ($d(%,,,%) :: InSpace v n t)
      ($dFromTrail :: FromTrail t) ->
      let {
        lvl77 :: (N t :: *) ~ (n :: *)
        lvl77 = $p2(%,,,%) $d(%,,,%) } in
      case HEq_sc (lvl77 `cast` <Co:5>) of cobox { __DEFAULT ->
      let {
        lvl78 :: (V t :: (* -> *)) ~ (v :: (* -> *))
        lvl78 = $p1(%,,,%) $d(%,,,%) } in
      case HEq_sc (lvl78 `cast` <Co:6>) of cobox1 { __DEFAULT ->
      let {
        $dAdditive :: Additive v
        $dAdditive = $p3(%,,,%) $d(%,,,%) } in
      let {
        $dNum :: Num n
        $dNum = $p4(%,,,%) $d(%,,,%) } in
      let {
        g :: Line v n
        g = case zero $dAdditive $dNum of dt7 { __DEFAULT ->
            Line (EmptyT `cast` <Co:5>) dt7
            } } in
      letrec {
        go1 :: [Segment v n] -> Line v n
        go1
          = \ (ds :: [Segment v n]) ->
              case ds of {
                [] -> g;
                : y ys ->
                  case go1 ys of { Line ss o ->
                  join {
                    $j :: Seq (Segment v n) -> Line v n
                    $j (dt7 :: Seq (Segment v n))
                      = case ^+^
                               $dAdditive
                               $dNum
                               o
                               (case y of {
                                  Linear v1 -> v1;
                                  Cubic ds1 ds2 v1 -> v1
                                })
                        of dt8
                        { __DEFAULT ->
                        Line dt7 dt8
                        } } in
                  case ss `cast` <Co:32> of {
                    EmptyT -> jump $j ((Single (y `cast` <Co:31>)) `cast` <Co:200>);
                    Single b ->
                      jump $j
                        ((Deep 2# (One (y `cast` <Co:31>)) EmptyT (One b))
                         `cast` <Co:200>);
                    Deep dt7 ds1 m sf ->
                      case ds1 of {
                        One b ->
                          jump $j
                            ((Deep (+# 1# dt7) (Two (y `cast` <Co:31>) b) m sf)
                             `cast` <Co:200>);
                        Two b c ->
                          jump $j
                            ((Deep (+# 1# dt7) (Three (y `cast` <Co:31>) b c) m sf)
                             `cast` <Co:200>);
                        Three b c d ->
                          jump $j
                            ((Deep (+# 1# dt7) (Four (y `cast` <Co:31>) b c d) m sf)
                             `cast` <Co:200>);
                        Four b c d e ->
                          case m of m1 { __DEFAULT ->
                          jump $j
                            ((Deep
                                (+# 1# dt7)
                                (Two (y `cast` <Co:31>) b)
                                ($b:<|_$s$sconsTree m1 3# c d e)
                                sf)
                             `cast` <Co:200>)
                          }
                      }
                  }
                  }
              }; } in
      \ (x :: Located [Segment v n]) ->
        ($dFromTrail `cast` <Co:9>)
          (case HEq_sc (lvl77 `cast` <Co:18>) of cobox2 { __DEFAULT ->
           case HEq_sc (lvl78 `cast` <Co:19>) of cobox3 { __DEFAULT ->
           case x of { Loc p a1 ->
           case go1 a1 of dt7 { Line ipv ipv1 ->
           Loc (p `cast` <Co:24>) (OpenTrail dt7)
           }
           }
           }
           })
      }
      }

-- RHS size: {terms: 33, types: 120, coercions: 30, joins: 0/1}
fromLine
  :: forall (v :: * -> *) n t.
     (InSpace v n t, FromTrail t) =>
     Line v n -> t
fromLine
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      ($d(%,,,%) :: InSpace v n t)
      ($dFromTrail :: FromTrail t) ->
      case HEq_sc (($p2(%,,,%) $d(%,,,%)) `cast` <Co:5>) of cobox
      { __DEFAULT ->
      case HEq_sc (($p1(%,,,%) $d(%,,,%)) `cast` <Co:6>) of cobox1
      { __DEFAULT ->
      let {
        ds :: v n
        ds = zero ($p3(%,,,%) $d(%,,,%)) ($p4(%,,,%) $d(%,,,%)) } in
      \ (x :: Line v n) ->
        ($dFromTrail `cast` <Co:9>)
          (case ds of nt { __DEFAULT ->
           case x of dt7 { Line ipv ipv1 ->
           Loc (nt `cast` <Co:10>) (OpenTrail dt7)
           }
           })
      }
      }

-- RHS size: {terms: 154, types: 359, coercions: 1,453, joins: 1/6}
fromOffsets
  :: forall (v :: * -> *) n t.
     (InSpace v n t, FromTrail t) =>
     [v n] -> t
fromOffsets
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      ($d(%,,,%) :: InSpace v n t)
      ($dFromTrail :: FromTrail t)
      (eta :: [v n]) ->
      case HEq_sc (($p2(%,,,%) $d(%,,,%)) `cast` <Co:5>) of cobox
      { __DEFAULT ->
      case HEq_sc (($p1(%,,,%) $d(%,,,%)) `cast` <Co:6>) of cobox1
      { __DEFAULT ->
      ($dFromTrail `cast` <Co:9>)
        (case zero ($p3(%,,,%) $d(%,,,%)) ($p4(%,,,%) $d(%,,,%)) of nt
         { __DEFAULT ->
         let {
           $dAdditive :: Additive v
           $dAdditive = $p3(%,,,%) $d(%,,,%) } in
         let {
           $dNum :: Num n
           $dNum = $p4(%,,,%) $d(%,,,%) } in
         case zero $dAdditive $dNum of dt7 { __DEFAULT ->
         let {
           z :: Line v n
           z = Line (EmptyT `cast` <Co:5>) dt7 } in
         letrec {
           go1 :: [v n] -> Line v n
           go1
             = \ (ds :: [v n]) ->
                 case ds of {
                   [] -> z;
                   : y ys ->
                     case go1 ys of { Line ss o ->
                     let {
                       x :: Segment v n
                       x = case y of dt8 { __DEFAULT -> Linear dt8 } } in
                     join {
                       $j :: Seq (Segment v n) -> Line v n
                       $j (dt8 :: Seq (Segment v n))
                         = case ^+^
                                  $dAdditive
                                  $dNum
                                  o
                                  (case x of {
                                     Linear v1 -> v1;
                                     Cubic ds1 ds2 v1 -> v1
                                   })
                           of dt9
                           { __DEFAULT ->
                           Line dt8 dt9
                           } } in
                     case ss `cast` <Co:32> of {
                       EmptyT -> jump $j ((Single (x `cast` <Co:31>)) `cast` <Co:200>);
                       Single b ->
                         jump $j
                           ((Deep 2# (One (x `cast` <Co:31>)) EmptyT (One b))
                            `cast` <Co:200>);
                       Deep dt8 ds1 m sf ->
                         case ds1 of {
                           One b ->
                             jump $j
                               ((Deep (+# 1# dt8) (Two (x `cast` <Co:31>) b) m sf)
                                `cast` <Co:200>);
                           Two b c ->
                             jump $j
                               ((Deep (+# 1# dt8) (Three (x `cast` <Co:31>) b c) m sf)
                                `cast` <Co:200>);
                           Three b c d ->
                             jump $j
                               ((Deep (+# 1# dt8) (Four (x `cast` <Co:31>) b c d) m sf)
                                `cast` <Co:200>);
                           Four b c d e ->
                             case m of m1 { __DEFAULT ->
                             jump $j
                               ((Deep
                                   (+# 1# dt8)
                                   (Two (x `cast` <Co:31>) b)
                                   ($b:<|_$s$sconsTree m1 3# c d e)
                                   sf)
                                `cast` <Co:200>)
                             }
                         }
                     }
                     }
                 }; } in
         case go1 eta of dt8 { Line ipv ipv1 ->
         Loc (nt `cast` <Co:10>) (OpenTrail dt8)
         }
         }
         })
      }
      }

-- RHS size: {terms: 11, types: 30, coercions: 0, joins: 0/0}
lvl35
  :: forall (v :: * -> *) n.
     Trail v n -> Either (Trail v n) (Loop v n)
lvl35
  = \ (@ (v :: * -> *)) (@ n) (s1 :: Trail v n) ->
      case s1 of wild {
        OpenTrail ipv -> Left wild;
        ClosedTrail t -> Right t
      }

-- RHS size: {terms: 31, types: 134, coercions: 0, joins: 0/2}
_Loop :: forall (v :: * -> *) n. Prism' (Trail v n) (Loop v n)
_Loop
  = \ (@ (v :: * -> *))
      (@ n)
      (@ (p :: * -> * -> *))
      (@ (f3 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f3) ->
      let {
        f4
          :: p (Either (Trail v n) (Loop v n)) (Either
                                                  (Trail v n) (f3 (Loop v n)))
             -> p (Trail v n) (f3 (Trail v n))
        f4
          = dimap
              ($p1Choice $dChoice)
              lvl35
              (let {
                 ds :: f3 (Loop v n) -> f3 (Trail v n)
                 ds = fmap ($p1Applicative $dApplicative) $WClosedTrail } in
               \ (ds1 :: Either (Trail v n) (f3 (Loop v n))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (Loop v n) (f3 (Loop v n))) -> f4 (right' $dChoice x)

-- RHS size: {terms: 16, types: 54, coercions: 19, joins: 0/0}
lvl36
  :: forall (v :: * -> *) n.
     Located (Trail v n)
     -> Either (Located (Trail v n)) (Located (Loop v n))
lvl36
  = \ (@ (v :: * -> *)) (@ n) (s1 :: Located (Trail v n)) ->
      case s1 of wild { Loc p a1 ->
      case a1 of {
        OpenTrail ipv -> Left wild;
        ClosedTrail t -> Right (Loc (p `cast` <Co:19>) t)
      }
      }

-- RHS size: {terms: 5, types: 16, coercions: 25, joins: 0/0}
lvl37
  :: forall (v :: * -> *) n.
     Located (Loop v n) -> Located (Trail v n)
lvl37
  = \ (@ (v :: * -> *)) (@ n) ->
      mapLoc (lvl33 `cast` <Co:25>) $WClosedTrail

-- RHS size: {terms: 31, types: 162, coercions: 0, joins: 0/2}
_LocLoop
  :: forall (v :: * -> *) n.
     Prism' (Located (Trail v n)) (Located (Loop v n))
_LocLoop
  = \ (@ (v :: * -> *))
      (@ n)
      (@ (p :: * -> * -> *))
      (@ (f3 :: * -> *))
      ($dChoice :: Choice p)
      ($dApplicative :: Applicative f3) ->
      let {
        f4
          :: p (Either (Located (Trail v n)) (Located (Loop v n))) (Either
                                                                      (Located (Trail v n))
                                                                      (f3 (Located (Loop v n))))
             -> p (Located (Trail v n)) (f3 (Located (Trail v n)))
        f4
          = dimap
              ($p1Choice $dChoice)
              lvl36
              (let {
                 ds :: f3 (Located (Loop v n)) -> f3 (Located (Trail v n))
                 ds = fmap ($p1Applicative $dApplicative) lvl37 } in
               \ (ds1
                    :: Either (Located (Trail v n)) (f3 (Located (Loop v n)))) ->
                 case ds1 of {
                   Left x -> pure $dApplicative x;
                   Right y -> ds y
                 }) } in
      \ (x :: p (Located (Loop v n)) (f3 (Located (Loop v n)))) ->
        f4 (right' $dChoice x)

-- RHS size: {terms: 24, types: 92, coercions: 39, joins: 0/0}
fromLocLoop
  :: forall (v :: * -> *) n t.
     (InSpace v n t, FromTrail t) =>
     Located (Loop v n) -> t
fromLocLoop
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      ($d(%,,,%) :: InSpace v n t)
      ($dFromTrail :: FromTrail t)
      (eta :: Located (Loop v n)) ->
      case HEq_sc (($p2(%,,,%) $d(%,,,%)) `cast` <Co:5>) of cobox
      { __DEFAULT ->
      case HEq_sc (($p1(%,,,%) $d(%,,,%)) `cast` <Co:6>) of cobox1
      { __DEFAULT ->
      ($dFromTrail `cast` <Co:9>)
        (case eta of { Loc p a1 ->
         Loc (p `cast` <Co:19>) (ClosedTrail a1)
         })
      }
      }

-- RHS size: {terms: 33, types: 120, coercions: 30, joins: 0/1}
fromLoop
  :: forall (v :: * -> *) n t.
     (InSpace v n t, FromTrail t) =>
     Loop v n -> t
fromLoop
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      ($d(%,,,%) :: InSpace v n t)
      ($dFromTrail :: FromTrail t) ->
      case HEq_sc (($p2(%,,,%) $d(%,,,%)) `cast` <Co:5>) of cobox
      { __DEFAULT ->
      case HEq_sc (($p1(%,,,%) $d(%,,,%)) `cast` <Co:6>) of cobox1
      { __DEFAULT ->
      let {
        ds :: v n
        ds = zero ($p3(%,,,%) $d(%,,,%)) ($p4(%,,,%) $d(%,,,%)) } in
      \ (x :: Loop v n) ->
        ($dFromTrail `cast` <Co:9>)
          (case ds of nt { __DEFAULT ->
           case x of dt7 { Loop ipv ipv1 ->
           Loc (nt `cast` <Co:10>) (ClosedTrail dt7)
           }
           })
      }
      }

-- RHS size: {terms: 14, types: 28, coercions: 0, joins: 0/0}
withTrail
  :: forall (v :: * -> *) n r.
     (Line v n -> r) -> (Loop v n -> r) -> Trail v n -> r
withTrail
  = \ (@ (v :: * -> *))
      (@ n)
      (@ r)
      (lineR :: Line v n -> r)
      (loopR :: Loop v n -> r)
      (ds :: Trail v n) ->
      case ds of {
        OpenTrail line -> lineR line;
        ClosedTrail loop -> loopR loop
      }

-- RHS size: {terms: 11, types: 30, coercions: 0, joins: 0/0}
lvl38
  :: forall (v :: * -> *) n.
     Trail v n -> Either (Line v n) (Loop v n)
lvl38
  = \ (@ (v :: * -> *)) (@ n) (ds :: Trail v n) ->
      case ds of {
        OpenTrail line -> Left line;
        ClosedTrail loop -> Right loop
      }

-- RHS size: {terms: 11, types: 30, coercions: 0, joins: 0/0}
lvl39
  :: forall (v :: * -> *) n.
     Either (Line v n) (Loop v n) -> Trail v n
lvl39
  = \ (@ (v :: * -> *))
      (@ n)
      (ds1 :: Either (Line v n) (Loop v n)) ->
      case ds1 of {
        Left x -> $WOpenTrail x;
        Right y -> $WClosedTrail y
      }

-- RHS size: {terms: 12, types: 58, coercions: 0, joins: 0/0}
_Trail
  :: forall (v :: * -> *) n.
     Iso' (Trail v n) (Either (Line v n) (Loop v n))
_Trail
  = \ (@ (v :: * -> *))
      (@ n)
      (@ (p :: * -> * -> *))
      (@ (f3 :: * -> *))
      ($dProfunctor :: Profunctor p)
      ($dFunctor :: Functor f3) ->
      dimap $dProfunctor lvl38 (fmap $dFunctor lvl39)

-- RHS size: {terms: 9, types: 22, coercions: 0, joins: 0/0}
closeLine :: forall (v :: * -> *) n. Line v n -> Loop v n
closeLine
  = \ (@ (v :: * -> *)) (@ n) (line :: Line v n) ->
      case line of dt7 { Line ipv ipv1 -> Loop dt7 LinearClosing }

-- RHS size: {terms: 12, types: 24, coercions: 0, joins: 0/0}
closeTrail :: forall (v :: * -> *) n. Trail v n -> Trail v n
closeTrail
  = \ (@ (v :: * -> *)) (@ n) (ds :: Trail v n) ->
      case ds of wild {
        OpenTrail line -> ClosedTrail (Loop line LinearClosing);
        ClosedTrail loop -> wild
      }

-- RHS size: {terms: 51, types: 91, coercions: 27, joins: 0/0}
glueLine
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Line v n -> Loop v n
glueLine
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (eta :: Line v n) ->
      case eta of { Line ss o ->
      case $m:|>_$sviewRTree (ss `cast` <Co:4>) of {
        SnocRTree xs' ds1 ->
          case ^-^
                 $dAdditive
                 $dNum
                 o
                 (case ds1 `cast` <Co:4> of {
                    Linear v1 -> v1;
                    Cubic ds2 ds3 v1 -> v1
                  })
          of dt7
          { __DEFAULT ->
          case ds1 `cast` <Co:4> of {
            Linear ds -> Loop (Line (xs' `cast` <Co:5>) dt7) LinearClosing;
            Cubic c1 c2 ds ->
              Loop (Line (xs' `cast` <Co:5>) dt7) (CubicClosing c1 c2)
          }
          };
        EmptyRTree ->
          case zero $dAdditive $dNum of dt7 { __DEFAULT ->
          Loop (Line (EmptyT `cast` <Co:5>) dt7) LinearClosing
          }
      }
      }

-- RHS size: {terms: 59, types: 106, coercions: 27, joins: 0/0}
glueTrail
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Trail v n -> Trail v n
glueTrail
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (eta :: Trail v n) ->
      case eta of wild {
        OpenTrail line ->
          case line of { Line ss o ->
          case $m:|>_$sviewRTree (ss `cast` <Co:4>) of {
            SnocRTree xs' ds1 ->
              case ^-^
                     $dAdditive
                     $dNum
                     o
                     (case ds1 `cast` <Co:4> of {
                        Linear v1 -> v1;
                        Cubic ds2 ds3 v1 -> v1
                      })
              of dt7
              { __DEFAULT ->
              case ds1 `cast` <Co:4> of {
                Linear ds ->
                  ClosedTrail (Loop (Line (xs' `cast` <Co:5>) dt7) LinearClosing);
                Cubic c1 c2 ds ->
                  ClosedTrail
                    (Loop (Line (xs' `cast` <Co:5>) dt7) (CubicClosing c1 c2))
              }
              };
            EmptyRTree ->
              case zero $dAdditive $dNum of dt7 { __DEFAULT ->
              ClosedTrail (Loop (Line (EmptyT `cast` <Co:5>) dt7) LinearClosing)
              }
          }
          };
        ClosedTrail loop -> wild
      }

-- RHS size: {terms: 67, types: 137, coercions: 35, joins: 0/0}
$fFromTrailLoop_$cfromLocTrail
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Located (Trail (V (Loop v n)) (N (Loop v n))) -> Loop v n
$fFromTrailLoop_$cfromLocTrail
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n)
      (eta :: Located (Trail (V (Loop v n)) (N (Loop v n)))) ->
      case eta `cast` <Co:8> of { Loc ds1 ds2 ->
      case ds2 of {
        OpenTrail line ->
          case line of { Line ss o ->
          case $m:|>_$sviewRTree (ss `cast` <Co:4>) of {
            SnocRTree xs' ds4 ->
              case ^-^
                     ($p1Metric $dMetric)
                     ($p1Fractional ($p1Floating ($p1(%,%) $d(%,%))))
                     o
                     (case ds4 `cast` <Co:4> of {
                        Linear v1 -> v1;
                        Cubic ds5 ds6 v1 -> v1
                      })
              of dt7
              { __DEFAULT ->
              case ds4 `cast` <Co:4> of {
                Linear ds -> Loop (Line (xs' `cast` <Co:5>) dt7) LinearClosing;
                Cubic c1 c2 ds ->
                  Loop (Line (xs' `cast` <Co:5>) dt7) (CubicClosing c1 c2)
              }
              };
            EmptyRTree ->
              case zero
                     ($p1Metric $dMetric)
                     ($p1Fractional ($p1Floating ($p1(%,%) $d(%,%))))
              of dt7
              { __DEFAULT ->
              Loop (Line (EmptyT `cast` <Co:5>) dt7) LinearClosing
              }
          }
          };
        ClosedTrail loop -> loop
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
$fFromTrailLoop
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     FromTrail (Loop v n)
$fFromTrailLoop = $fFromTrailLoop_$cfromLocTrail `cast` <Co:19>

-- RHS size: {terms: 26, types: 107, coercions: 30, joins: 0/1}
fromTrail
  :: forall (v :: * -> *) n t.
     (InSpace v n t, FromTrail t) =>
     Trail v n -> t
fromTrail
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      ($d(%,,,%) :: InSpace v n t)
      ($dFromTrail :: FromTrail t) ->
      case HEq_sc (($p2(%,,,%) $d(%,,,%)) `cast` <Co:5>) of cobox
      { __DEFAULT ->
      case HEq_sc (($p1(%,,,%) $d(%,,,%)) `cast` <Co:6>) of cobox1
      { __DEFAULT ->
      let {
        ds :: v n
        ds = zero ($p3(%,,,%) $d(%,,,%)) ($p4(%,,,%) $d(%,,,%)) } in
      \ (x :: Trail v n) ->
        ($dFromTrail `cast` <Co:9>) ($WLoc (ds `cast` <Co:10>) x)
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lineVertices2 :: Integer
lineVertices2 = 1000000000000000

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
lineVertices1 :: Ratio Integer
lineVertices1 = :% lineVertices3 lineVertices2

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
tolerance :: forall a. OrderedField a => a
tolerance
  = \ (@ a) ($d(%,%) :: OrderedField a) ->
      fromRational ($p1Floating ($p1(%,%) $d(%,%))) lineVertices1

Rec {
-- RHS size: {terms: 15, types: 18, coercions: 0, joins: 0/0}
$s$wunsafeDrop
  :: forall (v :: * -> *) n.
     Point v n -> [Point v n] -> Int# -> [Point v n]
$s$wunsafeDrop
  = \ (@ (v :: * -> *)) (@ n) _ (sc1 :: [Point v n]) (sc2 :: Int#) ->
      case sc2 of ds3 {
        __DEFAULT -> $wunsafeDrop (-# ds3 1#) sc1;
        1# -> sc1
      }

-- RHS size: {terms: 18, types: 13, coercions: 0, joins: 0/0}
$wunsafeDrop :: forall a1. Int# -> [a1] -> [a1]
$wunsafeDrop
  = \ (@ a1) (ww :: Int#) (w :: [a1]) ->
      case w of {
        [] -> [];
        : ipv1 ipv2 ->
          case ww of ds3 {
            __DEFAULT -> $wunsafeDrop (-# ds3 1#) ipv2;
            1# -> ipv2
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 18, types: 13, coercions: 0, joins: 0/0}
$wunsafeDrop1 :: forall a1. Int# -> [a1] -> [a1]
$wunsafeDrop1
  = \ (@ a1) (ww :: Int#) (w :: [a1]) ->
      case w of {
        [] -> [];
        : ipv1 ipv2 ->
          case ww of ds3 {
            __DEFAULT -> $wunsafeDrop1 (-# ds3 1#) ipv2;
            1# -> ipv2
          }
      }
end Rec }

Rec {
-- RHS size: {terms: 8, types: 18, coercions: 0, joins: 0/0}
$spoly_go
  :: forall n (v :: * -> *).
     Point v n -> Point v n -> [Point v n] -> Point v n
$spoly_go
  = \ (@ n)
      (@ (v :: * -> *))
      _
      (sc1 :: Point v n)
      (sc2 :: [Point v n]) ->
      poly_go sc2 sc1

-- RHS size: {terms: 12, types: 26, coercions: 0, joins: 0/0}
poly_go
  :: forall (v :: * -> *) n. [Point v n] -> Point v n -> Point v n
poly_go
  = \ (@ (v :: * -> *))
      (@ n)
      (ds :: [Point v n])
      (eta :: Point v n) ->
      case ds of {
        [] -> eta;
        : y ys -> poly_go ys y
      }
end Rec }

-- RHS size: {terms: 169, types: 297, coercions: 73, joins: 0/15}
segmentVertices'
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     n -> Point v n -> [Segment v n] -> [Point v n]
segmentVertices'
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n)
      (eta :: n)
      (eta1 :: Point v n)
      (eta2 :: [Segment v n]) ->
      let {
        $dFloating :: Floating n
        $dFloating = $p1(%,%) $d(%,%) } in
      let {
        $dFractional :: Fractional n
        $dFractional = $p1Floating $dFloating } in
      let {
        $dNum :: Num n
        $dNum = $p1Fractional $dFractional } in
      let {
        $dAdditive :: Additive v
        $dAdditive = $p1Metric $dMetric } in
      let {
        f3 :: v n -> v n -> v n
        f3 = ^+^ $dAdditive $dNum } in
      letrec {
        go1 :: [Segment v n] -> Point v n -> [Point v n]
        go1
          = \ (ds :: [Segment v n]) (eta3 :: Point v n) ->
              case ds of {
                [] -> [];
                : y ys ->
                  let {
                    b' :: v n
                    b'
                      = f3
                          (eta3 `cast` <Co:20>)
                          (($fHasSegmentsSegment_$coffset y) `cast` <Co:7>) } in
                  : (b' `cast` <Co:23>) (go1 ys (b' `cast` <Co:23>))
              }; } in
      case go1 eta2 eta1 of wild {
        [] -> : eta1 [];
        : ds ds1 ->
          : eta1
            (let {
               z :: Point v n
               z = $spoly_go lastError eta1 wild } in
             let {
               z1 :: [Point v n]
               z1 = : z [] } in
             letrec {
               go2 :: [Point v n] -> [Bool] -> [Point v n]
               go2
                 = \ (ds2 :: [Point v n]) (_ys :: [Bool]) ->
                     case ds2 of {
                       [] -> z1;
                       : ipv ipv1 ->
                         case _ys of {
                           [] -> z1;
                           : ipv2 ipv3 ->
                             case ipv2 of {
                               False -> go2 ipv1 ipv3;
                               True -> : ipv (go2 ipv1 ipv3)
                             }
                         }
                     }; } in
             go2
               ($s$wunsafeDrop eta1 wild 1#)
               (let {
                  lvl77 :: Functor v
                  lvl77 = $p1Additive $dAdditive } in
                let {
                  lvl78 :: n -> n
                  lvl78 = * $dNum (fromInteger $dNum lvl20) } in
                letrec {
                  go3 :: [Segment v n] -> [(v n, v n)]
                  go3
                    = \ (ds2 :: [Segment v n]) ->
                        case ds2 of {
                          [] -> [];
                          : y ys ->
                            : (signorm
                                 $dMetric
                                 $dFloating
                                 (case y of {
                                    Linear v1 -> v1;
                                    Cubic c1 ds3 ds4 -> fmap lvl77 lvl78 c1
                                  }),
                               signorm
                                 $dMetric
                                 $dFloating
                                 (case y of {
                                    Linear v1 -> v1;
                                    Cubic ds3 c2 c3 -> fmap lvl77 lvl78 (^-^ $dAdditive $dNum c3 c2)
                                  }))
                              (go3 ys)
                        }; } in
                let {
                  tans :: [(v n, v n)]
                  tans = go3 eta2 } in
                let {
                  $dOrd :: Ord n
                  $dOrd = $p2(%,%) $d(%,%) } in
                zipWith
                  (\ (p2 :: (v n, v n)) (q2 :: (v n, v n)) ->
                     > $dOrd
                       (quadrance
                          $dMetric
                          $dNum
                          (^-^
                             $dAdditive
                             $dNum
                             (case p2 of { (ds2, y) -> y })
                             (case q2 of { (x, ds2) -> x })))
                       eta)
                  tans
                  ($wunsafeDrop1 1# tans)))
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule4 :: Addr#
$trModule4 = "geometry-0.1.0.0-EBYaUc60xnmHzXjNb4ukHp"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule3 :: TrName
$trModule3 = TrNameS $trModule4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$trModule2 :: Addr#
$trModule2 = "Geometry.Trail"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$trModule1 :: TrName
$trModule1 = TrNameS $trModule2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$trModule :: Module
$trModule = Module $trModule3 $trModule1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep :: KindRep
$krep = KindRepTyConApp $tcDouble []

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep1 :: KindRep
$krep1 = KindRepTyConApp $tcCrossings []

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep2 :: KindRep
$krep2 = KindRepTyConApp $tcConstraint []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tcFromTrail1 :: KindRep
$tcFromTrail1 = KindRepFun krep$* $krep2

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tcLine1 :: KindRep
$tcLine1 = KindRepFun krep$*Arr* krep$*Arr*

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep3 :: KindRep
$krep3 = KindRepVar 1#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep4 :: KindRep
$krep4 = KindRepVar 0#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$krep5 :: KindRep
$krep5 = KindRepVar 0#

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep6 :: KindRep
$krep6 = KindRepApp $krep5 $krep3

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep7 :: [KindRep]
$krep7 = : $krep3 []

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep8 :: [KindRep]
$krep8 = : $krep5 $krep7

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep9 :: KindRep
$krep9 = KindRepTyConApp $tcClosingSegment $krep8

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep10 :: KindRep
$krep10 = KindRepTyConApp $tcSegment $krep8

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
$krep11 :: [KindRep]
$krep11 = : $krep10 []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep12 :: KindRep
$krep12 = KindRepTyConApp $tcSeq $krep11

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcLine3 :: Addr#
$tcLine3 = "Line"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcLine2 :: TrName
$tcLine2 = TrNameS $tcLine3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcLine :: TyCon
$tcLine
  = TyCon
      10599842442680185993##
      3157974576952205101##
      $trModule
      $tcLine2
      0#
      $tcLine1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep13 :: KindRep
$krep13 = KindRepTyConApp $tcLine $krep8

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep14 :: KindRep
$krep14 = KindRepFun $krep6 $krep13

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Line1 :: KindRep
$tc'Line1 = KindRepFun $krep12 $krep14

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Line3 :: Addr#
$tc'Line3 = "'Line"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Line2 :: TrName
$tc'Line2 = TrNameS $tc'Line3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Line :: TyCon
$tc'Line
  = TyCon
      5491874229475007528##
      8108445387518623767##
      $trModule
      $tc'Line2
      2#
      $tc'Line1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcPair2 :: Addr#
$tcPair2 = "Pair"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcPair1 :: TrName
$tcPair1 = TrNameS $tcPair2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcPair :: TyCon
$tcPair
  = TyCon
      5550976538993666465##
      5583433890292969354##
      $trModule
      $tcPair1
      0#
      krep$*->*->*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep15 :: [KindRep]
$krep15 = : $krep4 $krep7

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep16 :: KindRep
$krep16 = KindRepTyConApp $tcPair $krep15

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep17 :: KindRep
$krep17 = KindRepFun $krep3 $krep16

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Pair1 :: KindRep
$tc'Pair1 = KindRepFun $krep4 $krep17

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Pair3 :: Addr#
$tc'Pair3 = "'Pair"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Pair2 :: TrName
$tc'Pair2 = TrNameS $tc'Pair3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Pair :: TyCon
$tc'Pair
  = TyCon
      16950111609001420471##
      4121031608209132986##
      $trModule
      $tc'Pair2
      2#
      $tc'Pair1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcLE2D2 :: Addr#
$tcLE2D2 = "LE2D"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcLE2D1 :: TrName
$tcLE2D1 = TrNameS $tcLE2D2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcLE2D :: TyCon
$tcLE2D
  = TyCon
      4805952802968811477##
      4718929775272275132##
      $trModule
      $tcLE2D1
      0#
      krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep18 :: KindRep
$krep18 = KindRepTyConApp $tcLE2D []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep19 :: KindRep
$krep19 = KindRepFun $krep $krep18

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep20 :: KindRep
$krep20 = KindRepFun $krep $krep19

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep21 :: KindRep
$krep21 = KindRepFun $krep $krep20

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'LE2D1 :: KindRep
$tc'LE2D1 = KindRepFun $krep $krep21

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'LE2D3 :: Addr#
$tc'LE2D3 = "'LE2D"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'LE2D2 :: TrName
$tc'LE2D2 = TrNameS $tc'LE2D3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'LE2D :: TyCon
$tc'LE2D
  = TyCon
      6545283874834218348##
      9524406378710513032##
      $trModule
      $tc'LE2D2
      0#
      $tc'LE2D1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcLoop2 :: Addr#
$tcLoop2 = "Loop"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcLoop1 :: TrName
$tcLoop1 = TrNameS $tcLoop2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcLoop :: TyCon
$tcLoop
  = TyCon
      16909612854983310975##
      2774317663736964263##
      $trModule
      $tcLoop1
      0#
      $tcLine1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep22 :: KindRep
$krep22 = KindRepTyConApp $tcLoop $krep8

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep23 :: KindRep
$krep23 = KindRepFun $krep9 $krep22

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'Loop1 :: KindRep
$tc'Loop1 = KindRepFun $krep13 $krep23

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'Loop3 :: Addr#
$tc'Loop3 = "'Loop"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'Loop2 :: TrName
$tc'Loop2 = TrNameS $tc'Loop3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'Loop :: TyCon
$tc'Loop
  = TyCon
      18077197794569570746##
      12330627789172284519##
      $trModule
      $tc'Loop2
      2#
      $tc'Loop1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcLCD2 :: Addr#
$tcLCD2 = "LCD"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcLCD1 :: TrName
$tcLCD1 = TrNameS $tcLCD2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcLCD :: TyCon
$tcLCD
  = TyCon
      583875587951010295##
      8590364340211693151##
      $trModule
      $tcLCD1
      0#
      krep$*

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
$krep24 :: KindRep
$krep24 = KindRepTyConApp $tcLCD []

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep25 :: KindRep
$krep25 = KindRepFun $krep $krep24

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep26 :: KindRep
$krep26 = KindRepFun $krep $krep25

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'LCD1 :: KindRep
$tc'LCD1 = KindRepFun $krep1 $krep26

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'LCD3 :: Addr#
$tc'LCD3 = "'LCD"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'LCD2 :: TrName
$tc'LCD2 = TrNameS $tc'LCD3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'LCD :: TyCon
$tc'LCD
  = TyCon
      2634329795189182307##
      14676757086141806821##
      $trModule
      $tc'LCD2
      0#
      $tc'LCD1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcTrail2 :: Addr#
$tcTrail2 = "Trail"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcTrail1 :: TrName
$tcTrail1 = TrNameS $tcTrail2

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcTrail :: TyCon
$tcTrail
  = TyCon
      7682447035385575064##
      12094967030104683202##
      $trModule
      $tcTrail1
      0#
      $tcLine1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$krep27 :: KindRep
$krep27 = KindRepTyConApp $tcTrail $krep8

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'ClosedTrail1 :: KindRep
$tc'ClosedTrail1 = KindRepFun $krep22 $krep27

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'ClosedTrail3 :: Addr#
$tc'ClosedTrail3 = "'ClosedTrail"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'ClosedTrail2 :: TrName
$tc'ClosedTrail2 = TrNameS $tc'ClosedTrail3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'ClosedTrail :: TyCon
$tc'ClosedTrail
  = TyCon
      2258249851582763067##
      1890713006186293979##
      $trModule
      $tc'ClosedTrail2
      2#
      $tc'ClosedTrail1

-- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
$tc'OpenTrail1 :: KindRep
$tc'OpenTrail1 = KindRepFun $krep13 $krep27

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tc'OpenTrail3 :: Addr#
$tc'OpenTrail3 = "'OpenTrail"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tc'OpenTrail2 :: TrName
$tc'OpenTrail2 = TrNameS $tc'OpenTrail3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tc'OpenTrail :: TyCon
$tc'OpenTrail
  = TyCon
      13293815009783109095##
      16649000805595156405##
      $trModule
      $tc'OpenTrail2
      2#
      $tc'OpenTrail1

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$tcFromTrail3 :: Addr#
$tcFromTrail3 = "FromTrail"#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$tcFromTrail2 :: TrName
$tcFromTrail2 = TrNameS $tcFromTrail3

-- RHS size: {terms: 7, types: 0, coercions: 0, joins: 0/0}
$tcFromTrail :: TyCon
$tcFromTrail
  = TyCon
      4076381081954815528##
      14653569174034066077##
      $trModule
      $tcFromTrail2
      0#
      $tcFromTrail1

-- RHS size: {terms: 66, types: 84, coercions: 19, joins: 1/2}
$fHashable1Line_$cliftHashWithSalt
  :: forall (v :: * -> *).
     Hashable1 v =>
     forall a. (Int -> a -> Int) -> Int -> Line v a -> Int
$fHashable1Line_$cliftHashWithSalt
  = \ (@ (v :: * -> *))
      ($dHashable1 :: Hashable1 v)
      (@ a)
      (eta :: Int -> a -> Int)
      (eta1 :: Int)
      (eta2 :: Line v a) ->
      case eta2 of { Line ss ds ->
      join {
        $j :: Int# -> Int
        $j (y# :: Int#)
          = let {
              hws :: Int -> v a -> Int
              hws = ($dHashable1 `cast` <Co:2>) eta } in
            case $fFoldableFingerTree_$cfoldl'
                   ((\ (s :: Int) (a1 :: Segment v a) ->
                       case a1 of {
                         Linear v1 -> hws (case s of { I# x1 -> I# (*# x1 16777619#) }) v1;
                         Cubic c1 c2 c3 ->
                           hws
                             (hws
                                (hws (case s of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) }) c1)
                                c2)
                             c3
                       })
                    `cast` <Co:9>)
                   eta1
                   (ss `cast` <Co:4>)
            of
            { I# x1 ->
            I# (xorI# (*# x1 16777619#) y#)
            } } in
      case ss `cast` <Co:4> of {
        EmptyT -> jump $j 0#;
        Single x -> jump $j 1#;
        Deep dt7 ds1 ds2 ds3 -> jump $j dt7
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 12, joins: 0/0}
$fHashable1Line
  :: forall (v :: * -> *). Hashable1 v => Hashable1 (Line v)
$fHashable1Line = $fHashable1Line_$cliftHashWithSalt `cast` <Co:12>

-- RHS size: {terms: 97, types: 110, coercions: 21, joins: 1/4}
$fHashable1Loop_$cliftHashWithSalt
  :: forall (v :: * -> *).
     Hashable1 v =>
     forall a. (Int -> a -> Int) -> Int -> Loop v a -> Int
$fHashable1Loop_$cliftHashWithSalt
  = \ (@ (v :: * -> *))
      ($dHashable1 :: Hashable1 v)
      (@ a)
      (eta :: Int -> a -> Int)
      (eta1 :: Int)
      (eta2 :: Loop v a) ->
      case eta2 of { Loop l c ->
      case l of { Line ss ds ->
      join {
        $j :: Int# -> Int
        $j (y# :: Int#)
          = let {
              s :: Int
              s = let {
                    hws :: Int -> v a -> Int
                    hws = ($dHashable1 `cast` <Co:2>) eta } in
                  case $fFoldableFingerTree_$cfoldl'
                         ((\ (s1 :: Int) (a1 :: Segment v a) ->
                             case a1 of {
                               Linear v1 -> hws (case s1 of { I# x1 -> I# (*# x1 16777619#) }) v1;
                               Cubic c1 c2 c3 ->
                                 hws
                                   (hws
                                      (hws
                                         (case s1 of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) })
                                         c1)
                                      c2)
                                   c3
                             })
                          `cast` <Co:9>)
                         eta1
                         (ss `cast` <Co:4>)
                  of
                  { I# x1 ->
                  I# (xorI# (*# x1 16777619#) y#)
                  } } in
            case c of {
              LinearClosing -> case s of { I# x1 -> I# (*# x1 16777619#) };
              CubicClosing c1 c2 ->
                let {
                  hws :: Int -> v a -> Int
                  hws = ($dHashable1 `cast` <Co:2>) eta } in
                hws
                  (hws (case s of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) }) c1)
                  c2
            } } in
      case ss `cast` <Co:4> of {
        EmptyT -> jump $j 0#;
        Single x -> jump $j 1#;
        Deep dt7 ds1 ds2 ds3 -> jump $j dt7
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 12, joins: 0/0}
$fHashable1Loop
  :: forall (v :: * -> *). Hashable1 v => Hashable1 (Loop v)
$fHashable1Loop = $fHashable1Loop_$cliftHashWithSalt `cast` <Co:12>

-- RHS size: {terms: 175, types: 192, coercions: 40, joins: 2/6}
$fHashable1Trail_$cliftHashWithSalt
  :: forall (v :: * -> *).
     Hashable1 v =>
     forall a. (Int -> a -> Int) -> Int -> Trail v a -> Int
$fHashable1Trail_$cliftHashWithSalt
  = \ (@ (v :: * -> *))
      ($dHashable1 :: Hashable1 v)
      (@ a)
      (eta :: Int -> a -> Int)
      (eta1 :: Int)
      (eta2 :: Trail v a) ->
      case eta2 of {
        OpenTrail l ->
          case l of { Line ss ds ->
          join {
            $j :: Int# -> Int
            $j (y# :: Int#)
              = let {
                  hws :: Int -> v a -> Int
                  hws = ($dHashable1 `cast` <Co:2>) eta } in
                case $fFoldableFingerTree_$cfoldl'
                       ((\ (s :: Int) (a1 :: Segment v a) ->
                           case a1 of {
                             Linear v1 -> hws (case s of { I# x1 -> I# (*# x1 16777619#) }) v1;
                             Cubic c1 c2 c3 ->
                               hws
                                 (hws
                                    (hws
                                       (case s of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) }) c1)
                                    c2)
                                 c3
                           })
                        `cast` <Co:9>)
                       (case eta1 of { I# x1 -> I# (*# x1 16777619#) })
                       (ss `cast` <Co:4>)
                of
                { I# x1 ->
                I# (xorI# (*# x1 16777619#) y#)
                } } in
          case ss `cast` <Co:4> of {
            EmptyT -> jump $j 0#;
            Single x -> jump $j 1#;
            Deep dt7 ds1 ds2 ds3 -> jump $j dt7
          }
          };
        ClosedTrail l ->
          case l of { Loop l1 c ->
          case l1 of { Line ss ds ->
          join {
            $j :: Int# -> Int
            $j (y# :: Int#)
              = let {
                  s :: Int
                  s = let {
                        hws :: Int -> v a -> Int
                        hws = ($dHashable1 `cast` <Co:2>) eta } in
                      case $fFoldableFingerTree_$cfoldl'
                             ((\ (s1 :: Int) (a1 :: Segment v a) ->
                                 case a1 of {
                                   Linear v1 ->
                                     hws (case s1 of { I# x1 -> I# (*# x1 16777619#) }) v1;
                                   Cubic c1 c2 c3 ->
                                     hws
                                       (hws
                                          (hws
                                             (case s1 of { I# x1 ->
                                              I# (xorI# (*# x1 16777619#) 1#)
                                              })
                                             c1)
                                          c2)
                                       c3
                                 })
                              `cast` <Co:9>)
                             (case eta1 of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) })
                             (ss `cast` <Co:4>)
                      of
                      { I# x1 ->
                      I# (xorI# (*# x1 16777619#) y#)
                      } } in
                case c of {
                  LinearClosing -> case s of { I# x1 -> I# (*# x1 16777619#) };
                  CubicClosing c1 c2 ->
                    let {
                      hws :: Int -> v a -> Int
                      hws = ($dHashable1 `cast` <Co:2>) eta } in
                    hws
                      (hws (case s of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) }) c1)
                      c2
                } } in
          case ss `cast` <Co:4> of {
            EmptyT -> jump $j 0#;
            Single x -> jump $j 1#;
            Deep dt7 ds1 ds2 ds3 -> jump $j dt7
          }
          }
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 12, joins: 0/0}
$fHashable1Trail
  :: forall (v :: * -> *). Hashable1 v => Hashable1 (Trail v)
$fHashable1Trail
  = $fHashable1Trail_$cliftHashWithSalt `cast` <Co:12>

-- RHS size: {terms: 178, types: 195, coercions: 40, joins: 2/7}
$fHashableTrail_$chashWithSalt
  :: forall (v :: * -> *) n.
     (Hashable1 v, Hashable n) =>
     Int -> Trail v n -> Int
$fHashableTrail_$chashWithSalt
  = \ (@ (v :: * -> *))
      (@ n)
      ($dHashable1 :: Hashable1 v)
      ($dHashable :: Hashable n)
      (eta :: Int)
      (eta1 :: Trail v n) ->
      let {
        f3 :: Int -> n -> Int
        f3 = hashWithSalt $dHashable } in
      case eta1 of {
        OpenTrail l ->
          case l of { Line ss ds ->
          join {
            $j :: Int# -> Int
            $j (y# :: Int#)
              = let {
                  hws :: Int -> v n -> Int
                  hws = ($dHashable1 `cast` <Co:2>) f3 } in
                case $fFoldableFingerTree_$cfoldl'
                       ((\ (s :: Int) (a :: Segment v n) ->
                           case a of {
                             Linear v1 -> hws (case s of { I# x1 -> I# (*# x1 16777619#) }) v1;
                             Cubic c1 c2 c3 ->
                               hws
                                 (hws
                                    (hws
                                       (case s of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) }) c1)
                                    c2)
                                 c3
                           })
                        `cast` <Co:9>)
                       (case eta of { I# x1 -> I# (*# x1 16777619#) })
                       (ss `cast` <Co:4>)
                of
                { I# x1 ->
                I# (xorI# (*# x1 16777619#) y#)
                } } in
          case ss `cast` <Co:4> of {
            EmptyT -> jump $j 0#;
            Single x -> jump $j 1#;
            Deep dt7 ds1 ds2 ds3 -> jump $j dt7
          }
          };
        ClosedTrail l ->
          case l of { Loop l1 c ->
          case l1 of { Line ss ds ->
          join {
            $j :: Int# -> Int
            $j (y# :: Int#)
              = let {
                  s :: Int
                  s = let {
                        hws :: Int -> v n -> Int
                        hws = ($dHashable1 `cast` <Co:2>) f3 } in
                      case $fFoldableFingerTree_$cfoldl'
                             ((\ (s1 :: Int) (a :: Segment v n) ->
                                 case a of {
                                   Linear v1 ->
                                     hws (case s1 of { I# x1 -> I# (*# x1 16777619#) }) v1;
                                   Cubic c1 c2 c3 ->
                                     hws
                                       (hws
                                          (hws
                                             (case s1 of { I# x1 ->
                                              I# (xorI# (*# x1 16777619#) 1#)
                                              })
                                             c1)
                                          c2)
                                       c3
                                 })
                              `cast` <Co:9>)
                             (case eta of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) })
                             (ss `cast` <Co:4>)
                      of
                      { I# x1 ->
                      I# (xorI# (*# x1 16777619#) y#)
                      } } in
                case c of {
                  LinearClosing -> case s of { I# x1 -> I# (*# x1 16777619#) };
                  CubicClosing c1 c2 ->
                    let {
                      hws :: Int -> v n -> Int
                      hws = ($dHashable1 `cast` <Co:2>) f3 } in
                    hws
                      (hws (case s of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) }) c1)
                      c2
                } } in
          case ss `cast` <Co:4> of {
            EmptyT -> jump $j 0#;
            Single x -> jump $j 1#;
            Deep dt7 ds1 ds2 ds3 -> jump $j dt7
          }
          }
          }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl40 :: Int
lvl40 = I# 839657738087498284#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl41 :: Int
lvl41 = I# 839657738087498285#

-- RHS size: {terms: 163, types: 190, coercions: 40, joins: 2/7}
$fHashableTrail_$chash
  :: forall (v :: * -> *) n.
     (Hashable1 v, Hashable n) =>
     Trail v n -> Int
$fHashableTrail_$chash
  = \ (@ (v :: * -> *))
      (@ n)
      ($dHashable1 :: Hashable1 v)
      ($dHashable :: Hashable n)
      (eta :: Trail v n) ->
      let {
        f3 :: Int -> n -> Int
        f3 = hashWithSalt $dHashable } in
      case eta of {
        OpenTrail l ->
          case l of { Line ss ds ->
          join {
            $j :: Int# -> Int
            $j (y# :: Int#)
              = let {
                  hws :: Int -> v n -> Int
                  hws = ($dHashable1 `cast` <Co:2>) f3 } in
                case $fFoldableFingerTree_$cfoldl'
                       ((\ (s :: Int) (a :: Segment v n) ->
                           case a of {
                             Linear v1 -> hws (case s of { I# x1 -> I# (*# x1 16777619#) }) v1;
                             Cubic c1 c2 c3 ->
                               hws
                                 (hws
                                    (hws
                                       (case s of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) }) c1)
                                    c2)
                                 c3
                           })
                        `cast` <Co:9>)
                       lvl40
                       (ss `cast` <Co:4>)
                of
                { I# x1 ->
                I# (xorI# (*# x1 16777619#) y#)
                } } in
          case ss `cast` <Co:4> of {
            EmptyT -> jump $j 0#;
            Single x -> jump $j 1#;
            Deep dt7 ds1 ds2 ds3 -> jump $j dt7
          }
          };
        ClosedTrail l ->
          case l of { Loop l1 c ->
          case l1 of { Line ss ds ->
          join {
            $j :: Int# -> Int
            $j (y# :: Int#)
              = let {
                  s :: Int
                  s = let {
                        hws :: Int -> v n -> Int
                        hws = ($dHashable1 `cast` <Co:2>) f3 } in
                      case $fFoldableFingerTree_$cfoldl'
                             ((\ (s1 :: Int) (a :: Segment v n) ->
                                 case a of {
                                   Linear v1 ->
                                     hws (case s1 of { I# x1 -> I# (*# x1 16777619#) }) v1;
                                   Cubic c1 c2 c3 ->
                                     hws
                                       (hws
                                          (hws
                                             (case s1 of { I# x1 ->
                                              I# (xorI# (*# x1 16777619#) 1#)
                                              })
                                             c1)
                                          c2)
                                       c3
                                 })
                              `cast` <Co:9>)
                             lvl41
                             (ss `cast` <Co:4>)
                      of
                      { I# x1 ->
                      I# (xorI# (*# x1 16777619#) y#)
                      } } in
                case c of {
                  LinearClosing -> case s of { I# x1 -> I# (*# x1 16777619#) };
                  CubicClosing c1 c2 ->
                    let {
                      hws :: Int -> v n -> Int
                      hws = ($dHashable1 `cast` <Co:2>) f3 } in
                    hws
                      (hws (case s of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) }) c1)
                      c2
                } } in
          case ss `cast` <Co:4> of {
            EmptyT -> jump $j 0#;
            Single x -> jump $j 1#;
            Deep dt7 ds1 ds2 ds3 -> jump $j dt7
          }
          }
          }
      }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fHashableTrail
  :: forall (v :: * -> *) n.
     (Hashable1 v, Hashable n) =>
     Hashable (Trail v n)
$fHashableTrail
  = \ (@ (v :: * -> *))
      (@ n)
      ($dHashable1 :: Hashable1 v)
      ($dHashable :: Hashable n) ->
      C:Hashable
        ($fHashableTrail_$chashWithSalt $dHashable1 $dHashable)
        ($fHashableTrail_$chash $dHashable1 $dHashable)

-- RHS size: {terms: 100, types: 113, coercions: 21, joins: 1/5}
$fHashableLoop_$chashWithSalt
  :: forall (v :: * -> *) n.
     (Hashable1 v, Hashable n) =>
     Int -> Loop v n -> Int
$fHashableLoop_$chashWithSalt
  = \ (@ (v :: * -> *))
      (@ n)
      ($dHashable1 :: Hashable1 v)
      ($dHashable :: Hashable n)
      (eta :: Int)
      (eta1 :: Loop v n) ->
      case eta1 of { Loop l c ->
      case l of { Line ss ds ->
      join {
        $j :: Int# -> Int
        $j (y# :: Int#)
          = let {
              f3 :: Int -> n -> Int
              f3 = hashWithSalt $dHashable } in
            let {
              s :: Int
              s = let {
                    hws :: Int -> v n -> Int
                    hws = ($dHashable1 `cast` <Co:2>) f3 } in
                  case $fFoldableFingerTree_$cfoldl'
                         ((\ (s1 :: Int) (a :: Segment v n) ->
                             case a of {
                               Linear v1 -> hws (case s1 of { I# x1 -> I# (*# x1 16777619#) }) v1;
                               Cubic c1 c2 c3 ->
                                 hws
                                   (hws
                                      (hws
                                         (case s1 of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) })
                                         c1)
                                      c2)
                                   c3
                             })
                          `cast` <Co:9>)
                         eta
                         (ss `cast` <Co:4>)
                  of
                  { I# x1 ->
                  I# (xorI# (*# x1 16777619#) y#)
                  } } in
            case c of {
              LinearClosing -> case s of { I# x1 -> I# (*# x1 16777619#) };
              CubicClosing c1 c2 ->
                let {
                  hws :: Int -> v n -> Int
                  hws = ($dHashable1 `cast` <Co:2>) f3 } in
                hws
                  (hws (case s of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) }) c1)
                  c2
            } } in
      case ss `cast` <Co:4> of {
        EmptyT -> jump $j 0#;
        Single x -> jump $j 1#;
        Deep dt7 ds1 ds2 ds3 -> jump $j dt7
      }
      }
      }

-- RHS size: {terms: 94, types: 98, coercions: 21, joins: 1/5}
$w$chash1
  :: forall (v :: * -> *) n.
     (Hashable1 v, Hashable n) =>
     Seq (Segment v n) -> ClosingSegment v n -> Int
$w$chash1
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Hashable1 v)
      (w1 :: Hashable n)
      (ww
         :: Seq (Segment v n)
         Unf=OtherCon [])
      (ww1
         :: ClosingSegment v n
         Unf=OtherCon []) ->
      join {
        $j :: Int# -> Int
        $j (y# :: Int#)
          = let {
              f3 :: Int -> n -> Int
              f3 = hashWithSalt w1 } in
            let {
              s :: Int
              s = let {
                    hws :: Int -> v n -> Int
                    hws = (w `cast` <Co:2>) f3 } in
                  case $fFoldableFingerTree_$cfoldl'
                         ((\ (s1 :: Int) (a :: Segment v n) ->
                             case a of {
                               Linear v1 -> hws (case s1 of { I# x1 -> I# (*# x1 16777619#) }) v1;
                               Cubic c1 c2 c3 ->
                                 hws
                                   (hws
                                      (hws
                                         (case s1 of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) })
                                         c1)
                                      c2)
                                   c3
                             })
                          `cast` <Co:9>)
                         defaultSalt
                         (ww `cast` <Co:4>)
                  of
                  { I# x1 ->
                  I# (xorI# (*# x1 16777619#) y#)
                  } } in
            case ww1 of {
              LinearClosing -> case s of { I# x1 -> I# (*# x1 16777619#) };
              CubicClosing c1 c2 ->
                let {
                  hws :: Int -> v n -> Int
                  hws = (w `cast` <Co:2>) f3 } in
                hws
                  (hws (case s of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) }) c1)
                  c2
            } } in
      case ww `cast` <Co:4> of {
        EmptyT -> jump $j 0#;
        Single x -> jump $j 1#;
        Deep dt7 ds1 ds2 ds3 -> jump $j dt7
      }

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
$fHashableLoop_$chash
  :: forall (v :: * -> *) n.
     (Hashable1 v, Hashable n) =>
     Loop v n -> Int
$fHashableLoop_$chash
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Hashable1 v)
      (w1 :: Hashable n)
      (w2 :: Loop v n) ->
      case w2 of { Loop ww1 ww2 ->
      case ww1 of { Line ww4 ww5 -> $w$chash1 w w1 ww4 ww2 }
      }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fHashableLoop
  :: forall (v :: * -> *) n.
     (Hashable1 v, Hashable n) =>
     Hashable (Loop v n)
$fHashableLoop
  = \ (@ (v :: * -> *))
      (@ n)
      ($dHashable1 :: Hashable1 v)
      ($dHashable :: Hashable n) ->
      C:Hashable
        ($fHashableLoop_$chashWithSalt $dHashable1 $dHashable)
        ($fHashableLoop_$chash $dHashable1 $dHashable)

-- RHS size: {terms: 67, types: 84, coercions: 19, joins: 1/2}
$fHashableLine_$chashWithSalt
  :: forall (v :: * -> *) n.
     (Hashable1 v, Hashable n) =>
     Int -> Line v n -> Int
$fHashableLine_$chashWithSalt
  = \ (@ (v :: * -> *))
      (@ n)
      ($dHashable1 :: Hashable1 v)
      ($dHashable :: Hashable n)
      (eta :: Int)
      (eta1 :: Line v n) ->
      case eta1 of { Line ss ds ->
      join {
        $j :: Int# -> Int
        $j (y# :: Int#)
          = let {
              hws :: Int -> v n -> Int
              hws = ($dHashable1 `cast` <Co:2>) (hashWithSalt $dHashable) } in
            case $fFoldableFingerTree_$cfoldl'
                   ((\ (s :: Int) (a :: Segment v n) ->
                       case a of {
                         Linear v1 -> hws (case s of { I# x1 -> I# (*# x1 16777619#) }) v1;
                         Cubic c1 c2 c3 ->
                           hws
                             (hws
                                (hws (case s of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) }) c1)
                                c2)
                             c3
                       })
                    `cast` <Co:9>)
                   eta
                   (ss `cast` <Co:4>)
            of
            { I# x1 ->
            I# (xorI# (*# x1 16777619#) y#)
            } } in
      case ss `cast` <Co:4> of {
        EmptyT -> jump $j 0#;
        Single x -> jump $j 1#;
        Deep dt7 ds1 ds2 ds3 -> jump $j dt7
      }
      }

-- RHS size: {terms: 62, types: 75, coercions: 19, joins: 1/2}
$w$chash
  :: forall (v :: * -> *) n.
     (Hashable1 v, Hashable n) =>
     Seq (Segment v n) -> Int#
$w$chash
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Hashable1 v)
      (w1 :: Hashable n)
      (ww
         :: Seq (Segment v n)
         Unf=OtherCon []) ->
      join {
        $j :: Int# -> Int#
        $j (y# :: Int#)
          = let {
              hws :: Int -> v n -> Int
              hws = (w `cast` <Co:2>) (hashWithSalt w1) } in
            case $fFoldableFingerTree_$cfoldl'
                   ((\ (s :: Int) (a :: Segment v n) ->
                       case a of {
                         Linear v1 -> hws (case s of { I# x1 -> I# (*# x1 16777619#) }) v1;
                         Cubic c1 c2 c3 ->
                           hws
                             (hws
                                (hws (case s of { I# x1 -> I# (xorI# (*# x1 16777619#) 1#) }) c1)
                                c2)
                             c3
                       })
                    `cast` <Co:9>)
                   defaultSalt
                   (ww `cast` <Co:4>)
            of
            { I# x1 ->
            xorI# (*# x1 16777619#) y#
            } } in
      case ww `cast` <Co:4> of {
        EmptyT -> jump $j 0#;
        Single x -> jump $j 1#;
        Deep dt7 ds1 ds2 ds3 -> jump $j dt7
      }

-- RHS size: {terms: 16, types: 25, coercions: 0, joins: 0/0}
$fHashableLine_$chash
  :: forall (v :: * -> *) n.
     (Hashable1 v, Hashable n) =>
     Line v n -> Int
$fHashableLine_$chash
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Hashable1 v)
      (w1 :: Hashable n)
      (w2 :: Line v n) ->
      case w2 of { Line ww1 ww2 ->
      case $w$chash w w1 ww1 of ww3 { __DEFAULT -> I# ww3 }
      }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fHashableLine
  :: forall (v :: * -> *) n.
     (Hashable1 v, Hashable n) =>
     Hashable (Line v n)
$fHashableLine
  = \ (@ (v :: * -> *))
      (@ n)
      ($dHashable1 :: Hashable1 v)
      ($dHashable :: Hashable n) ->
      C:Hashable
        ($fHashableLine_$chashWithSalt $dHashable1 $dHashable)
        ($fHashableLine_$chash $dHashable1 $dHashable)

-- RHS size: {terms: 42, types: 103, coercions: 36, joins: 0/3}
$fHasSegmentsLine_$csegments
  :: forall (v :: * -> *) n.
     Fold (Line v n) (Segment (V (Line v n)) (N (Line v n)))
$fHasSegmentsLine_$csegments
  = \ (@ (v :: * -> *))
      (@ n)
      (@ (f3 :: * -> *))
      ($dContravariant :: Contravariant f3)
      ($dApplicative :: Applicative f3)
      (eta
         :: Segment (V (Line v n)) (N (Line v n))
            -> f3 (Segment (V (Line v n)) (N (Line v n)))) ->
      lineSeq
        ($p1Applicative $dApplicative)
        (let {
           $dFunctor :: Functor f3
           $dFunctor = $p1Applicative $dApplicative } in
         let {
           f4 :: Segment v n -> f3 (Segment v n) -> f3 (Segment v n)
           f4
             = \ (a1 :: Segment v n) (fa :: f3 (Segment v n)) ->
                 *> $dApplicative ((eta (a1 `cast` <Co:10>)) `cast` <Co:8>) fa } in
         let {
           z :: f3 (Segment v n)
           z = >$
                 $dContravariant
                 ()
                 (<$ ($p1Applicative $dApplicative) () (pure $dApplicative ())) } in
         \ (x :: Seq (Segment v n)) ->
           >$
             $dContravariant
             ()
             (<$
                $dFunctor
                ()
                ($fEq1Seq_$cfoldr (f4 `cast` <Co:14>) z (x `cast` <Co:4>))))

-- RHS size: {terms: 6, types: 15, coercions: 0, joins: 0/0}
$fHasSegmentsLine :: forall (v :: * -> *) n. HasSegments (Line v n)
$fHasSegmentsLine
  = \ (@ (v :: * -> *)) (@ n) ->
      C:HasSegments
        $fHasSegmentsLine_$csegments
        $fHasSegmentsLine_$coffset
        $fHasSegmentsLine_$cnumSegments

-- RHS size: {terms: 9, types: 27, coercions: 17, joins: 0/0}
trailPoints1
  :: forall (v :: * -> *) n.
     Segment v n
     -> Const (Endo [Segment v n]) (Segment v n)
     -> [Segment v n]
     -> [Segment v n]
trailPoints1
  = \ (@ (v :: * -> *))
      (@ n)
      (a1 :: Segment v n)
      (fa :: Const (Endo [Segment v n]) (Segment v n))
      (x :: [Segment v n]) ->
      : a1 ((fa `cast` <Co:17>) x)

-- RHS size: {terms: 22, types: 66, coercions: 112, joins: 0/0}
lineVertices'
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     n -> Located (Line v n) -> [Point v n]
lineVertices'
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Metric v)
      (w1 :: OrderedField n)
      (w2 :: n)
      (w3 :: Located (Line v n)) ->
      case w3 of { Loc ww1 ww2 ->
      case ww2 of { Line ww4 ww5 ->
      segmentVertices'
        w
        w1
        w2
        (ww1 `cast` <Co:8>)
        ((($fEq1Seq_$cfoldr
             (trailPoints1 `cast` <Co:64>)
             (id `cast` <Co:19>)
             (ww4 `cast` <Co:4>))
          `cast` <Co:17>)
           [])
      }
      }

-- RHS size: {terms: 27, types: 72, coercions: 112, joins: 0/1}
lineVertices
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Located (Line v n) -> [Point v n]
lineVertices
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n) ->
      let {
        w :: n
        w = fromRational
              ($p1Floating ($p1(%,%) $d(%,%))) lineVertices1 } in
      \ (w1 :: Located (Line v n)) ->
        case w1 of { Loc ww1 ww2 ->
        case ww2 of { Line ww4 ww5 ->
        segmentVertices'
          $dMetric
          $d(%,%)
          w
          (ww1 `cast` <Co:8>)
          ((($fEq1Seq_$cfoldr
               (trailPoints1 `cast` <Co:64>)
               (id `cast` <Co:19>)
               (ww4 `cast` <Co:4>))
            `cast` <Co:17>)
             [])
        }
        }

-- RHS size: {terms: 40, types: 111, coercions: 193, joins: 0/3}
$wloopPoints
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Point (V (Loop v n)) (N (Loop v n))
     -> Line v n -> (# Point v n, [Point v n] #)
$wloopPoints
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (ww
         :: Point (V (Loop v n)) (N (Loop v n))
         Unf=OtherCon [])
      (ww1
         :: Line v n
         Unf=OtherCon []) ->
      case ww1 of { Line s o ->
      (# ww `cast` <Co:8>,
         let {
           f3 :: v n -> v n -> v n
           f3 = ^+^ w w1 } in
         letrec {
           go1 :: [Segment v n] -> Point v n -> [Point v n]
           go1
             = \ (ds :: [Segment v n]) (eta :: Point v n) ->
                 case ds of {
                   [] -> [];
                   : y ys ->
                     let {
                       b' :: v n
                       b'
                         = f3
                             (eta `cast` <Co:20>)
                             (($fHasSegmentsSegment_$coffset y) `cast` <Co:7>) } in
                     : (b' `cast` <Co:23>) (go1 ys (b' `cast` <Co:23>))
                 }; } in
         go1
           ((($fEq1Seq_$cfoldr
                (trailPoints1 `cast` <Co:64>)
                (id `cast` <Co:19>)
                (s `cast` <Co:4>))
             `cast` <Co:17>)
              [])
           (ww `cast` <Co:8>) #)
      }

-- RHS size: {terms: 21, types: 61, coercions: 0, joins: 0/0}
loopPoints
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Located (Loop v n) -> [Point v n]
loopPoints
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (w2 :: Located (Loop v n)) ->
      case w2 of { Loc ww1 ww2 ->
      case ww2 of { Loop ww4 ww5 ->
      case $wloopPoints w w1 ww1 ww4 of { (# ww7, ww8 #) -> : ww7 ww8 }
      }
      }

-- RHS size: {terms: 37, types: 103, coercions: 193, joins: 0/3}
$wlinePoints
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Point (V (Line v n)) (N (Line v n))
     -> Seq (Segment v n) -> (# Point v n, [Point v n] #)
$wlinePoints
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (ww
         :: Point (V (Line v n)) (N (Line v n))
         Unf=OtherCon [])
      (ww1
         :: Seq (Segment v n)
         Unf=OtherCon []) ->
      (# ww `cast` <Co:8>,
         let {
           f3 :: v n -> v n -> v n
           f3 = ^+^ w w1 } in
         letrec {
           go1 :: [Segment v n] -> Point v n -> [Point v n]
           go1
             = \ (ds :: [Segment v n]) (eta :: Point v n) ->
                 case ds of {
                   [] -> [];
                   : y ys ->
                     let {
                       b' :: v n
                       b'
                         = f3
                             (eta `cast` <Co:20>)
                             (($fHasSegmentsSegment_$coffset y) `cast` <Co:7>) } in
                     : (b' `cast` <Co:23>) (go1 ys (b' `cast` <Co:23>))
                 }; } in
         go1
           ((($fEq1Seq_$cfoldr
                (trailPoints1 `cast` <Co:64>)
                (id `cast` <Co:19>)
                (ww1 `cast` <Co:4>))
             `cast` <Co:17>)
              [])
           (ww `cast` <Co:8>) #)

-- RHS size: {terms: 21, types: 61, coercions: 0, joins: 0/0}
linePoints
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Located (Line v n) -> [Point v n]
linePoints
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (w2 :: Located (Line v n)) ->
      case w2 of { Loc ww1 ww2 ->
      case ww2 of { Line ww4 ww5 ->
      case $wlinePoints w w1 ww1 ww4 of { (# ww7, ww8 #) -> : ww7 ww8 }
      }
      }

-- RHS size: {terms: 83, types: 214, coercions: 386, joins: 0/6}
trailPoints
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Located (Trail v n) -> [Point v n]
trailPoints
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (w2 :: Located (Trail v n)) ->
      case w2 of { Loc ww1 ww2 ->
      case ww2 of {
        OpenTrail line ->
          case line of { Line s o ->
          : (ww1 `cast` <Co:8>)
            (let {
               f3 :: v n -> v n -> v n
               f3 = ^+^ w w1 } in
             letrec {
               go1 :: [Segment v n] -> Point v n -> [Point v n]
               go1
                 = \ (ds :: [Segment v n]) (eta :: Point v n) ->
                     case ds of {
                       [] -> [];
                       : y ys ->
                         let {
                           b' :: v n
                           b'
                             = f3
                                 (eta `cast` <Co:20>)
                                 (($fHasSegmentsSegment_$coffset y) `cast` <Co:7>) } in
                         : (b' `cast` <Co:23>) (go1 ys (b' `cast` <Co:23>))
                     }; } in
             go1
               ((($fEq1Seq_$cfoldr
                    (trailPoints1 `cast` <Co:64>)
                    (id `cast` <Co:19>)
                    (s `cast` <Co:4>))
                 `cast` <Co:17>)
                  [])
               (ww1 `cast` <Co:8>))
          };
        ClosedTrail loop ->
          case loop of { Loop t c ->
          case t of { Line s o ->
          : (ww1 `cast` <Co:8>)
            (let {
               f3 :: v n -> v n -> v n
               f3 = ^+^ w w1 } in
             letrec {
               go1 :: [Segment v n] -> Point v n -> [Point v n]
               go1
                 = \ (ds :: [Segment v n]) (eta :: Point v n) ->
                     case ds of {
                       [] -> [];
                       : y ys ->
                         let {
                           b' :: v n
                           b'
                             = f3
                                 (eta `cast` <Co:20>)
                                 (($fHasSegmentsSegment_$coffset y) `cast` <Co:7>) } in
                         : (b' `cast` <Co:23>) (go1 ys (b' `cast` <Co:23>))
                     }; } in
             go1
               ((($fEq1Seq_$cfoldr
                    (trailPoints1 `cast` <Co:64>)
                    (id `cast` <Co:19>)
                    (s `cast` <Co:4>))
                 `cast` <Co:17>)
                  [])
               (ww1 `cast` <Co:8>))
          }
          }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 48, joins: 0/0}
$fFromTrail[]
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     FromTrail [Point v n]
$fFromTrail[] = trailPoints `cast` <Co:48>

-- RHS size: {terms: 136, types: 231, coercions: 1,169, joins: 1/2}
cutLoop
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Loop v n -> Line v n
cutLoop
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (eta :: Loop v n) ->
      case eta of { Loop ds ds1 ->
      case ds of { Line ds2 o ->
      case ds2 `cast` <Co:4> of wild2 {
        __DEFAULT ->
          let {
            y :: Segment v n
            y = case ds1 of {
                  LinearClosing ->
                    case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
                    { __DEFAULT ->
                    Linear dt7
                    };
                  CubicClosing c1 c2 ->
                    case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
                    { __DEFAULT ->
                    Cubic c1 c2 dt7
                    }
                } } in
          join {
            $j :: Seq (Segment v n) -> Line v n
            $j (dt7 :: Seq (Segment v n))
              = case ^+^
                       $dAdditive
                       $dNum
                       o
                       (case y of {
                          Linear v1 -> v1;
                          Cubic ds3 ds4 v1 -> v1
                        })
                of dt8
                { __DEFAULT ->
                Line dt7 dt8
                } } in
          case wild2 of {
            Single a2 ->
              jump $j
                ((Deep 2# (One a2) EmptyT (One (y `cast` <Co:32>)))
                 `cast` <Co:200>);
            Deep dt7 pr m ds3 ->
              case ds3 of {
                One a2 ->
                  jump $j
                    ((Deep (+# dt7 1#) pr m (Two a2 (y `cast` <Co:32>)))
                     `cast` <Co:200>);
                Two a2 b ->
                  jump $j
                    ((Deep (+# dt7 1#) pr m (Three a2 b (y `cast` <Co:32>)))
                     `cast` <Co:200>);
                Three a2 b c ->
                  jump $j
                    ((Deep (+# dt7 1#) pr m (Four a2 b c (y `cast` <Co:32>)))
                     `cast` <Co:200>);
                Four a2 b c d ->
                  case m of m1 { __DEFAULT ->
                  jump $j
                    ((Deep
                        (+# dt7 1#)
                        pr
                        ($b:|>_$s$ssnocTree 3# a2 b c m1)
                        (Two d (y `cast` <Co:32>)))
                     `cast` <Co:200>)
                  }
              }
          };
        EmptyT ->
          case zero $dAdditive $dNum of dt7 { __DEFAULT ->
          Line (EmptyT `cast` <Co:5>) dt7
          }
      }
      }
      }

-- RHS size: {terms: 143, types: 244, coercions: 1,169, joins: 1/2}
cutTrail
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Trail v n -> Trail v n
cutTrail
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (eta :: Trail v n) ->
      case eta of wild {
        OpenTrail line -> wild;
        ClosedTrail loop ->
          case loop of { Loop ds ds1 ->
          case ds of { Line ds2 o ->
          case ds2 `cast` <Co:4> of wild3 {
            __DEFAULT ->
              let {
                y :: Segment v n
                y = case ds1 of {
                      LinearClosing ->
                        case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
                        { __DEFAULT ->
                        Linear dt7
                        };
                      CubicClosing c1 c2 ->
                        case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
                        { __DEFAULT ->
                        Cubic c1 c2 dt7
                        }
                    } } in
              join {
                $j :: Seq (Segment v n) -> Trail v n
                $j (dt7 :: Seq (Segment v n))
                  = case ^+^
                           $dAdditive
                           $dNum
                           o
                           (case y of {
                              Linear v1 -> v1;
                              Cubic ds3 ds4 v1 -> v1
                            })
                    of dt8
                    { __DEFAULT ->
                    OpenTrail (Line dt7 dt8)
                    } } in
              case wild3 of {
                Single a2 ->
                  jump $j
                    ((Deep 2# (One a2) EmptyT (One (y `cast` <Co:32>)))
                     `cast` <Co:200>);
                Deep dt7 pr m ds3 ->
                  case ds3 of {
                    One a2 ->
                      jump $j
                        ((Deep (+# dt7 1#) pr m (Two a2 (y `cast` <Co:32>)))
                         `cast` <Co:200>);
                    Two a2 b ->
                      jump $j
                        ((Deep (+# dt7 1#) pr m (Three a2 b (y `cast` <Co:32>)))
                         `cast` <Co:200>);
                    Three a2 b c ->
                      jump $j
                        ((Deep (+# dt7 1#) pr m (Four a2 b c (y `cast` <Co:32>)))
                         `cast` <Co:200>);
                    Four a2 b c d ->
                      case m of m1 { __DEFAULT ->
                      jump $j
                        ((Deep
                            (+# dt7 1#)
                            pr
                            ($b:|>_$s$ssnocTree 3# a2 b c m1)
                            (Two d (y `cast` <Co:32>)))
                         `cast` <Co:200>)
                      }
                  }
              };
            EmptyT ->
              case zero $dAdditive $dNum of dt7 { __DEFAULT ->
              OpenTrail (Line (EmptyT `cast` <Co:5>) dt7)
              }
          }
          }
          }
      }

-- RHS size: {terms: 145, types: 246, coercions: 1,169, joins: 1/2}
withLine
  :: forall (v :: * -> *) n r.
     (Additive v, Num n) =>
     (Line v n -> r) -> Trail v n -> r
withLine
  = \ (@ (v :: * -> *))
      (@ n)
      (@ r)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (f3 :: Line v n -> r)
      (ds :: Trail v n) ->
      case ds of {
        OpenTrail line -> f3 line;
        ClosedTrail loop ->
          case loop of { Loop ds1 ds2 ->
          case ds1 of { Line ds3 o ->
          f3
            (case ds3 `cast` <Co:4> of wild3 {
               __DEFAULT ->
                 let {
                   y :: Segment v n
                   y = case ds2 of {
                         LinearClosing ->
                           case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
                           { __DEFAULT ->
                           Linear dt7
                           };
                         CubicClosing c1 c2 ->
                           case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
                           { __DEFAULT ->
                           Cubic c1 c2 dt7
                           }
                       } } in
                 join {
                   $j :: Seq (Segment v n) -> Line v n
                   $j (dt7 :: Seq (Segment v n))
                     = case ^+^
                              $dAdditive
                              $dNum
                              o
                              (case y of {
                                 Linear v1 -> v1;
                                 Cubic ds4 ds5 v1 -> v1
                               })
                       of dt8
                       { __DEFAULT ->
                       Line dt7 dt8
                       } } in
                 case wild3 of {
                   Single a2 ->
                     jump $j
                       ((Deep 2# (One a2) EmptyT (One (y `cast` <Co:32>)))
                        `cast` <Co:200>);
                   Deep dt7 pr m ds4 ->
                     case ds4 of {
                       One a2 ->
                         jump $j
                           ((Deep (+# dt7 1#) pr m (Two a2 (y `cast` <Co:32>)))
                            `cast` <Co:200>);
                       Two a2 b ->
                         jump $j
                           ((Deep (+# dt7 1#) pr m (Three a2 b (y `cast` <Co:32>)))
                            `cast` <Co:200>);
                       Three a2 b c ->
                         jump $j
                           ((Deep (+# dt7 1#) pr m (Four a2 b c (y `cast` <Co:32>)))
                            `cast` <Co:200>);
                       Four a2 b c d ->
                         case m of m1 { __DEFAULT ->
                         jump $j
                           ((Deep
                               (+# dt7 1#)
                               pr
                               ($b:|>_$s$ssnocTree 3# a2 b c m1)
                               (Two d (y `cast` <Co:32>)))
                            `cast` <Co:200>)
                         }
                     }
                 };
               EmptyT ->
                 case zero $dAdditive $dNum of dt7 { __DEFAULT ->
                 Line (EmptyT `cast` <Co:5>) dt7
                 }
             })
          }
          }
      }

-- RHS size: {terms: 68, types: 118, coercions: 13, joins: 2/2}
$fMonoidTrail_$c<>
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Trail v n -> Trail v n -> Trail v n
$fMonoidTrail_$c<>
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (eta :: Trail v n)
      (eta1 :: Trail v n) ->
      join {
        $j :: Trail v n
        $j
          = join {
              $j1 :: Trail v n
              $j1
                = withLine
                    $dAdditive
                    $dNum
                    (\ (l1 :: Line v n) ->
                       withLine
                         $dAdditive
                         $dNum
                         (\ (l2 :: Line v n) ->
                            case l1 of { Line s1 o1 ->
                            case l2 of { Line s2 o2 ->
                            case $fAlternativeSeq2 s1 s2 of nt { __DEFAULT ->
                            case ^+^ $dAdditive $dNum o1 o2 of dt7 { __DEFAULT ->
                            OpenTrail (Line (nt `cast` <Co:5>) dt7)
                            }
                            }
                            }
                            })
                         eta1)
                    eta } in
            case eta1 of {
              OpenTrail ds ->
                case ds of { Line s ds1 ->
                case s `cast` <Co:4> of {
                  __DEFAULT -> jump $j1;
                  EmptyT -> eta
                }
                };
              ClosedTrail ipv -> jump $j1
            } } in
      case eta of {
        OpenTrail ds ->
          case ds of { Line s ds1 ->
          case s `cast` <Co:4> of {
            __DEFAULT -> jump $j;
            EmptyT -> eta1
          }
          };
        ClosedTrail ipv -> jump $j
      }

-- RHS size: {terms: 83, types: 150, coercions: 13, joins: 2/4}
$w$csconcat1
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Trail v n -> [Trail v n] -> Trail v n
$w$csconcat1
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (ww :: Trail v n)
      (ww1 :: [Trail v n]) ->
      letrec {
        go1 :: Trail v n -> [Trail v n] -> Trail v n
        go1
          = \ (b :: Trail v n) (ds1 :: [Trail v n]) ->
              case ds1 of {
                [] -> b;
                : c cs ->
                  let {
                    t2 :: Trail v n
                    t2 = go1 c cs } in
                  join {
                    $j :: Trail v n
                    $j
                      = join {
                          $j1 :: Trail v n
                          $j1
                            = withLine
                                w
                                w1
                                (\ (l1 :: Line v n) ->
                                   withLine
                                     w
                                     w1
                                     (\ (l2 :: Line v n) ->
                                        case l1 of { Line s1 o1 ->
                                        case l2 of { Line s2 o2 ->
                                        case $fAlternativeSeq2 s1 s2 of nt { __DEFAULT ->
                                        case ^+^ w w1 o1 o2 of dt7 { __DEFAULT ->
                                        OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                        }
                                        }
                                        }
                                        })
                                     t2)
                                b } in
                        case t2 of {
                          OpenTrail ds ->
                            case ds of { Line s ds2 ->
                            case s `cast` <Co:4> of {
                              __DEFAULT -> jump $j1;
                              EmptyT -> b
                            }
                            };
                          ClosedTrail ipv -> jump $j1
                        } } in
                  case b of {
                    OpenTrail ds ->
                      case ds of { Line s ds2 ->
                      case s `cast` <Co:4> of {
                        __DEFAULT -> jump $j;
                        EmptyT -> t2
                      }
                      };
                    ClosedTrail ipv -> jump $j
                  }
              }; } in
      go1 ww ww1

-- RHS size: {terms: 13, types: 27, coercions: 0, joins: 0/0}
$fSemigroupTrail_$csconcat
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     NonEmpty (Trail v n) -> Trail v n
$fSemigroupTrail_$csconcat
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (w2 :: NonEmpty (Trail v n)) ->
      case w2 of { :| ww1 ww2 -> $w$csconcat1 w w1 ww1 ww2 }

-- RHS size: {terms: 4, types: 10, coercions: 0, joins: 0/0}
lvl42 :: forall (v :: * -> *) n. Trail v n
lvl42 = \ (@ (v :: * -> *)) (@ n) -> errorWithoutStackTrace lvl2

-- RHS size: {terms: 2,233,
              types: 3,905,
              coercions: 1,328,
              joins: 25/104}
$fSemigroupTrail_$cstimes
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     forall b. Integral b => b -> Trail v n -> Trail v n
$fSemigroupTrail_$cstimes
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (@ b)
      ($dIntegral :: Integral b)
      (eta :: b)
      (eta1 :: Trail v n) ->
      let {
        $dReal :: Real b
        $dReal = $p1Integral $dIntegral } in
      case <= ($p2Real $dReal) eta (fromInteger ($p1Real $dReal) lvl4)
      of {
        False ->
          let {
            $dNum1 :: Num b
            $dNum1 = $p1Real $dReal } in
          let {
            lvl77 :: b
            lvl77 = fromInteger $dNum1 lvl } in
          let {
            lvl78 :: b
            lvl78 = fromInteger $dNum1 lineVertices3 } in
          let {
            $dEq :: Ord b
            $dEq = $p2Real $dReal } in
          let {
            $dEq1 :: Eq b
            $dEq1 = $p1Ord $dEq } in
          let {
            $dEnum :: Enum b
            $dEnum = $p2Integral $dIntegral } in
          joinrec {
            $sf :: b -> Seq (Segment v n) -> v n -> Trail v n
            $sf (sc :: b) (sc1 :: Seq (Segment v n)) (sc2 :: v n)
              = case even $dIntegral sc of {
                  False ->
                    case == $dEq1 sc lvl78 of {
                      False ->
                        let {
                          karg :: b
                          karg = quot $dIntegral (pred $dEnum sc) lvl77 } in
                        joinrec {
                          $sg :: Seq (Segment v n) -> v n -> b -> Trail v n -> Trail v n
                          $sg (sc3 :: Seq (Segment v n))
                              (sc4 :: v n)
                              (sc5 :: b)
                              (sc6 :: Trail v n)
                            = case even $dIntegral sc5 of {
                                False ->
                                  case == $dEq1 sc5 lvl78 of {
                                    False ->
                                      let {
                                        karg1 :: b
                                        karg1 = quot $dIntegral (pred $dEnum sc5) lvl77 } in
                                      let {
                                        karg2 :: Trail v n
                                        karg2
                                          = join {
                                              $j :: Trail v n
                                              $j
                                                = case sc3 `cast` <Co:4> of wild7 {
                                                    __DEFAULT ->
                                                      withLine
                                                        $dAdditive
                                                        $dNum
                                                        (\ (l1 :: Line v n) ->
                                                           withLine
                                                             $dAdditive
                                                             $dNum
                                                             (\ (l2 :: Line v n) ->
                                                                case l1 of { Line s1 o1 ->
                                                                case l2 of { Line s2 o2 ->
                                                                case $fAlternativeSeq2 s1 s2 of nt
                                                                { __DEFAULT ->
                                                                case ^+^ $dAdditive $dNum o1 o2
                                                                of dt7
                                                                { __DEFAULT ->
                                                                OpenTrail
                                                                  (Line (nt `cast` <Co:5>) dt7)
                                                                }
                                                                }
                                                                }
                                                                })
                                                             (OpenTrail
                                                                (Line (wild7 `cast` <Co:5>) sc4)))
                                                        sc6;
                                                    EmptyT -> sc6
                                                  } } in
                                            case sc6 of {
                                              OpenTrail ds ->
                                                case ds of { Line s ds1 ->
                                                case s `cast` <Co:4> of {
                                                  __DEFAULT -> jump $j;
                                                  EmptyT -> OpenTrail (Line sc3 sc4)
                                                }
                                                };
                                              ClosedTrail ipv -> jump $j
                                            } } in
                                      join {
                                        $j :: Trail v n
                                        $j
                                          = jump g
                                              (withLine
                                                 $dAdditive
                                                 $dNum
                                                 (\ (l1 :: Line v n) ->
                                                    withLine
                                                      $dAdditive
                                                      $dNum
                                                      (\ (l2 :: Line v n) ->
                                                         case l1 of { Line s1 o1 ->
                                                         case l2 of { Line s2 o2 ->
                                                         case $fAlternativeSeq2 s1 s2 of nt
                                                         { __DEFAULT ->
                                                         case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                         { __DEFAULT ->
                                                         OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                         }
                                                         }
                                                         }
                                                         })
                                                      sc6)
                                                 sc6)
                                              karg1
                                              karg2 } in
                                      case sc6 of wild7 {
                                        OpenTrail ds ->
                                          case ds of { Line s ds1 ->
                                          case s `cast` <Co:4> of {
                                            __DEFAULT -> jump $j;
                                            EmptyT -> jump g wild7 karg1 karg2
                                          }
                                          };
                                        ClosedTrail ipv -> jump $j
                                      };
                                    True ->
                                      let {
                                        $dAsEmpty
                                          :: forall (p :: * -> * -> *) (f4 :: * -> *).
                                             (Choice p, Applicative f4) =>
                                             p () (f4 ()) -> p (Trail v n) (f4 (Trail v n))
                                        $dAsEmpty
                                          = \ (@ (p :: * -> * -> *))
                                              (@ (f4 :: * -> *))
                                              ($dChoice :: Choice p)
                                              ($dApplicative :: Applicative f4) ->
                                              let {
                                                $dAsEmpty1
                                                  :: forall (p1 :: * -> * -> *) (f5 :: * -> *).
                                                     (Choice p1, Applicative f5) =>
                                                     p1 () (f5 ()) -> p1 (Line v n) (f5 (Line v n))
                                                $dAsEmpty1
                                                  = \ (@ (p1 :: * -> * -> *))
                                                      (@ (f5 :: * -> *))
                                                      ($dChoice1 :: Choice p1)
                                                      ($dApplicative1 :: Applicative f5) ->
                                                      let {
                                                        dk :: Line v n
                                                        dk
                                                          = case zero $dAdditive $dNum of dt7
                                                            { __DEFAULT ->
                                                            Line (EmptyT `cast` <Co:5>) dt7
                                                            } } in
                                                      let {
                                                        f6
                                                          :: p1 (Either (Line v n) ()) (Either
                                                                                          (Line v n)
                                                                                          (f5 ()))
                                                             -> p1 (Line v n) (f5 (Line v n))
                                                        f6
                                                          = dimap
                                                              ($p1Choice $dChoice1)
                                                              (\ (s :: Line v n) ->
                                                                 case s of wild7 { Line s1 ds ->
                                                                 case s1 `cast` <Co:4> of {
                                                                   __DEFAULT -> Left wild7;
                                                                   EmptyT -> Right ()
                                                                 }
                                                                 })
                                                              (let {
                                                                 f7 :: Line v n -> f5 (Line v n)
                                                                 f7 = pure $dApplicative1 } in
                                                               let {
                                                                 ds :: f5 () -> f5 (Line v n)
                                                                 ds
                                                                   = fmap
                                                                       ($p1Applicative
                                                                          $dApplicative1)
                                                                       (\ (ds1 :: ()) ->
                                                                          case ds1 of { () ->
                                                                          dk
                                                                          }) } in
                                                               \ (ds1
                                                                    :: Either (Line v n) (f5 ())) ->
                                                                 case ds1 of {
                                                                   Left x -> f7 x;
                                                                   Right y -> ds y
                                                                 }) } in
                                                      let {
                                                        g1
                                                          :: p1 () (f5 ())
                                                             -> p1 (Either (Line v n) ()) (Either
                                                                                             (Line
                                                                                                v n)
                                                                                             (f5 ()))
                                                        g1 = right' $dChoice1 } in
                                                      \ (x :: p1 () (f5 ())) -> f6 (g1 x) } in
                                              let {
                                                dk :: Trail v n
                                                dk
                                                  = case ($dAsEmpty1
                                                            $fChoiceTagged
                                                            $fApplicativeIdentity
                                                            (() `cast` <Co:65>))
                                                         `cast` <Co:62>
                                                    of dt7
                                                    { Line ipv ipv1 ->
                                                    OpenTrail dt7
                                                    } } in
                                              let {
                                                f5
                                                  :: p (Either (Trail v n) ()) (Either
                                                                                  (Trail v n)
                                                                                  (f4 ()))
                                                     -> p (Trail v n) (f4 (Trail v n))
                                                f5
                                                  = dimap
                                                      ($p1Choice $dChoice)
                                                      (\ (s :: Trail v n) ->
                                                         case s of wild7 {
                                                           OpenTrail ds ->
                                                             case ($dAsEmpty1
                                                                     $fChoice(->)
                                                                     $mEmpty_$s$fApplicativeConst
                                                                     ($mEmpty1 `cast` <Co:13>)
                                                                     ds)
                                                                  `cast` <Co:18>
                                                             of {
                                                               False -> Left wild7;
                                                               True -> Right ()
                                                             };
                                                           ClosedTrail ipv -> Left wild7
                                                         })
                                                      (let {
                                                         f6 :: Trail v n -> f4 (Trail v n)
                                                         f6 = pure $dApplicative } in
                                                       let {
                                                         ds :: f4 () -> f4 (Trail v n)
                                                         ds
                                                           = fmap
                                                               ($p1Applicative $dApplicative)
                                                               (\ (ds1 :: ()) ->
                                                                  case ds1 of { () -> dk }) } in
                                                       \ (ds1 :: Either (Trail v n) (f4 ())) ->
                                                         case ds1 of {
                                                           Left x -> f6 x;
                                                           Right y -> ds y
                                                         }) } in
                                              let {
                                                g1
                                                  :: p () (f4 ())
                                                     -> p (Either (Trail v n) ()) (Either
                                                                                     (Trail v n)
                                                                                     (f4 ()))
                                                g1 = right' $dChoice } in
                                              \ (x :: p () (f4 ())) -> f5 (g1 x) } in
                                      let {
                                        t2 :: Line v n
                                        t2 = Line sc3 sc4 } in
                                      let {
                                        t1 :: Trail v n
                                        t1 = OpenTrail t2 } in
                                      case ($dAsEmpty
                                              $fChoice(->)
                                              $mEmpty_$s$fApplicativeConst
                                              ($mEmpty1 `cast` <Co:13>)
                                              sc6)
                                           `cast` <Co:18>
                                      of {
                                        False ->
                                          case ($dAsEmpty
                                                  $fChoice(->)
                                                  $mEmpty_$s$fApplicativeConst
                                                  ($mEmpty1 `cast` <Co:13>)
                                                  t1)
                                               `cast` <Co:18>
                                          of {
                                            False ->
                                              withLine
                                                $dAdditive
                                                $dNum
                                                (\ (l1 :: Line v n) ->
                                                   withLine
                                                     $dAdditive
                                                     $dNum
                                                     (\ (l2 :: Line v n) ->
                                                        case l1 of { Line s1 o1 ->
                                                        case l2 of { Line s2 o2 ->
                                                        case $fAlternativeSeq2 s1 s2 of nt
                                                        { __DEFAULT ->
                                                        case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                        { __DEFAULT ->
                                                        OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                        }
                                                        }
                                                        }
                                                        })
                                                     t1)
                                                sc6;
                                            True -> sc6
                                          };
                                        True -> t1
                                      }
                                  };
                                True ->
                                  join {
                                    $j :: Trail v n
                                    $j
                                      = jump $sg
                                          sc3
                                          sc4
                                          (quot $dIntegral sc5 lvl77)
                                          (withLine
                                             $dAdditive
                                             $dNum
                                             (\ (l1 :: Line v n) ->
                                                withLine
                                                  $dAdditive
                                                  $dNum
                                                  (\ (l2 :: Line v n) ->
                                                     case l1 of { Line s1 o1 ->
                                                     case l2 of { Line s2 o2 ->
                                                     case $fAlternativeSeq2 s1 s2 of nt
                                                     { __DEFAULT ->
                                                     case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                     { __DEFAULT ->
                                                     OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                     }
                                                     }
                                                     }
                                                     })
                                                  sc6)
                                             sc6) } in
                                  case sc6 of wild4 {
                                    OpenTrail ds ->
                                      case ds of { Line s ds1 ->
                                      case s `cast` <Co:4> of {
                                        __DEFAULT -> jump $j;
                                        EmptyT -> jump $sg sc3 sc4 (quot $dIntegral sc5 lvl77) wild4
                                      }
                                      };
                                    ClosedTrail ipv -> jump $j
                                  }
                              };
                          g :: Trail v n -> b -> Trail v n -> Trail v n
                          g (x1 :: Trail v n) (y1 :: b) (z :: Trail v n)
                            = case even $dIntegral y1 of {
                                False ->
                                  case == $dEq1 y1 lvl78 of {
                                    False ->
                                      let {
                                        karg1 :: b
                                        karg1 = quot $dIntegral (pred $dEnum y1) lvl77 } in
                                      let {
                                        karg2 :: Trail v n
                                        karg2
                                          = join {
                                              $j :: Trail v n
                                              $j
                                                = join {
                                                    $j1 :: Trail v n
                                                    $j1
                                                      = withLine
                                                          $dAdditive
                                                          $dNum
                                                          (\ (l1 :: Line v n) ->
                                                             withLine
                                                               $dAdditive
                                                               $dNum
                                                               (\ (l2 :: Line v n) ->
                                                                  case l1 of { Line s1 o1 ->
                                                                  case l2 of { Line s2 o2 ->
                                                                  case $fAlternativeSeq2 s1 s2 of nt
                                                                  { __DEFAULT ->
                                                                  case ^+^ $dAdditive $dNum o1 o2
                                                                  of dt7
                                                                  { __DEFAULT ->
                                                                  OpenTrail
                                                                    (Line (nt `cast` <Co:5>) dt7)
                                                                  }
                                                                  }
                                                                  }
                                                                  })
                                                               z)
                                                          x1 } in
                                                  case z of {
                                                    OpenTrail ds ->
                                                      case ds of { Line s ds1 ->
                                                      case s `cast` <Co:4> of {
                                                        __DEFAULT -> jump $j1;
                                                        EmptyT -> x1
                                                      }
                                                      };
                                                    ClosedTrail ipv -> jump $j1
                                                  } } in
                                            case x1 of {
                                              OpenTrail ds ->
                                                case ds of { Line s ds1 ->
                                                case s `cast` <Co:4> of {
                                                  __DEFAULT -> jump $j;
                                                  EmptyT -> z
                                                }
                                                };
                                              ClosedTrail ipv -> jump $j
                                            } } in
                                      join {
                                        $j :: Trail v n
                                        $j
                                          = jump g
                                              (withLine
                                                 $dAdditive
                                                 $dNum
                                                 (\ (l1 :: Line v n) ->
                                                    withLine
                                                      $dAdditive
                                                      $dNum
                                                      (\ (l2 :: Line v n) ->
                                                         case l1 of { Line s1 o1 ->
                                                         case l2 of { Line s2 o2 ->
                                                         case $fAlternativeSeq2 s1 s2 of nt
                                                         { __DEFAULT ->
                                                         case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                         { __DEFAULT ->
                                                         OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                         }
                                                         }
                                                         }
                                                         })
                                                      x1)
                                                 x1)
                                              karg1
                                              karg2 } in
                                      case x1 of wild7 {
                                        OpenTrail ds ->
                                          case ds of { Line s ds1 ->
                                          case s `cast` <Co:4> of {
                                            __DEFAULT -> jump $j;
                                            EmptyT -> jump g wild7 karg1 karg2
                                          }
                                          };
                                        ClosedTrail ipv -> jump $j
                                      };
                                    True -> $fMonoidTrail_$c<> $dAdditive $dNum x1 z
                                  };
                                True ->
                                  join {
                                    $j :: Trail v n
                                    $j
                                      = jump g
                                          (withLine
                                             $dAdditive
                                             $dNum
                                             (\ (l1 :: Line v n) ->
                                                withLine
                                                  $dAdditive
                                                  $dNum
                                                  (\ (l2 :: Line v n) ->
                                                     case l1 of { Line s1 o1 ->
                                                     case l2 of { Line s2 o2 ->
                                                     case $fAlternativeSeq2 s1 s2 of nt
                                                     { __DEFAULT ->
                                                     case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                     { __DEFAULT ->
                                                     OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                     }
                                                     }
                                                     }
                                                     })
                                                  x1)
                                             x1)
                                          (quot $dIntegral y1 lvl77)
                                          z } in
                                  case x1 of wild4 {
                                    OpenTrail ds ->
                                      case ds of { Line s ds1 ->
                                      case s `cast` <Co:4> of {
                                        __DEFAULT -> jump $j;
                                        EmptyT -> jump g wild4 (quot $dIntegral y1 lvl77) z
                                      }
                                      };
                                    ClosedTrail ipv -> jump $j
                                  }
                              }; } in
                        case sc1 `cast` <Co:4> of wild4 {
                          __DEFAULT ->
                            jump $sg
                              (wild4 `cast` <Co:5>)
                              sc2
                              karg
                              (withLine
                                 $dAdditive
                                 $dNum
                                 (\ (l1 :: Line v n) ->
                                    withLine
                                      $dAdditive
                                      $dNum
                                      (\ (l2 :: Line v n) ->
                                         case l1 of { Line s1 o1 ->
                                         case l2 of { Line s2 o2 ->
                                         case $fAlternativeSeq2 s1 s2 of nt { __DEFAULT ->
                                         case ^+^ $dAdditive $dNum o1 o2 of dt7 { __DEFAULT ->
                                         OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                         }
                                         }
                                         }
                                         })
                                      (OpenTrail (Line (wild4 `cast` <Co:5>) sc2)))
                                 (OpenTrail (Line (wild4 `cast` <Co:5>) sc2)));
                          EmptyT ->
                            jump $sg
                              (EmptyT `cast` <Co:5>)
                              sc2
                              karg
                              (OpenTrail (Line (EmptyT `cast` <Co:5>) sc2))
                        };
                      True -> OpenTrail (Line sc1 sc2)
                    };
                  True ->
                    case sc1 `cast` <Co:4> of wild2 {
                      __DEFAULT ->
                        jump f3
                          (withLine
                             $dAdditive
                             $dNum
                             (\ (l1 :: Line v n) ->
                                withLine
                                  $dAdditive
                                  $dNum
                                  (\ (l2 :: Line v n) ->
                                     case l1 of { Line s1 o1 ->
                                     case l2 of { Line s2 o2 ->
                                     case $fAlternativeSeq2 s1 s2 of nt { __DEFAULT ->
                                     case ^+^ $dAdditive $dNum o1 o2 of dt7 { __DEFAULT ->
                                     OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                     }
                                     }
                                     }
                                     })
                                  (OpenTrail (Line (wild2 `cast` <Co:5>) sc2)))
                             (OpenTrail (Line (wild2 `cast` <Co:5>) sc2)))
                          (quot $dIntegral sc lvl77);
                      EmptyT ->
                        jump $sf (quot $dIntegral sc lvl77) (EmptyT `cast` <Co:5>) sc2
                    }
                };
            f3 :: Trail v n -> b -> Trail v n
            f3 (x :: Trail v n) (y :: b)
              = case even $dIntegral y of {
                  False ->
                    case == $dEq1 y lvl78 of {
                      False ->
                        let {
                          karg :: b
                          karg = quot $dIntegral (pred $dEnum y) lvl77 } in
                        joinrec {
                          $sg :: Trail v n -> b -> Seq (Segment v n) -> v n -> Trail v n
                          $sg (sc :: Trail v n)
                              (sc1 :: b)
                              (sc2 :: Seq (Segment v n))
                              (sc3 :: v n)
                            = case even $dIntegral sc1 of {
                                False ->
                                  case == $dEq1 sc1 lvl78 of {
                                    False ->
                                      let {
                                        karg1 :: b
                                        karg1 = quot $dIntegral (pred $dEnum sc1) lvl77 } in
                                      let {
                                        karg2 :: Trail v n
                                        karg2
                                          = case sc2 `cast` <Co:4> of wild7 {
                                              __DEFAULT ->
                                                join {
                                                  $j :: Trail v n
                                                  $j
                                                    = withLine
                                                        $dAdditive
                                                        $dNum
                                                        (\ (l1 :: Line v n) ->
                                                           withLine
                                                             $dAdditive
                                                             $dNum
                                                             (\ (l2 :: Line v n) ->
                                                                case l1 of { Line s1 o1 ->
                                                                case l2 of { Line s2 o2 ->
                                                                case $fAlternativeSeq2 s1 s2 of nt
                                                                { __DEFAULT ->
                                                                case ^+^ $dAdditive $dNum o1 o2
                                                                of dt7
                                                                { __DEFAULT ->
                                                                OpenTrail
                                                                  (Line (nt `cast` <Co:5>) dt7)
                                                                }
                                                                }
                                                                }
                                                                })
                                                             sc)
                                                        (OpenTrail
                                                           (Line (wild7 `cast` <Co:5>) sc3)) } in
                                                case sc of {
                                                  OpenTrail ds ->
                                                    case ds of { Line s ds1 ->
                                                    case s `cast` <Co:4> of {
                                                      __DEFAULT -> jump $j;
                                                      EmptyT ->
                                                        OpenTrail (Line (wild7 `cast` <Co:5>) sc3)
                                                    }
                                                    };
                                                  ClosedTrail ipv -> jump $j
                                                };
                                              EmptyT -> sc
                                            } } in
                                      case sc2 `cast` <Co:4> of wild7 {
                                        __DEFAULT ->
                                          jump g
                                            (withLine
                                               $dAdditive
                                               $dNum
                                               (\ (l1 :: Line v n) ->
                                                  withLine
                                                    $dAdditive
                                                    $dNum
                                                    (\ (l2 :: Line v n) ->
                                                       case l1 of { Line s1 o1 ->
                                                       case l2 of { Line s2 o2 ->
                                                       case $fAlternativeSeq2 s1 s2 of nt
                                                       { __DEFAULT ->
                                                       case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                       { __DEFAULT ->
                                                       OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                       }
                                                       }
                                                       }
                                                       })
                                                    (OpenTrail (Line (wild7 `cast` <Co:5>) sc3)))
                                               (OpenTrail (Line (wild7 `cast` <Co:5>) sc3)))
                                            karg1
                                            karg2;
                                        EmptyT -> jump $sg karg2 karg1 (EmptyT `cast` <Co:5>) sc3
                                      };
                                    True ->
                                      let {
                                        $dAsEmpty
                                          :: forall (p :: * -> * -> *) (f4 :: * -> *).
                                             (Choice p, Applicative f4) =>
                                             p () (f4 ()) -> p (Trail v n) (f4 (Trail v n))
                                        $dAsEmpty
                                          = \ (@ (p :: * -> * -> *))
                                              (@ (f4 :: * -> *))
                                              ($dChoice :: Choice p)
                                              ($dApplicative :: Applicative f4) ->
                                              let {
                                                $dAsEmpty1
                                                  :: forall (p1 :: * -> * -> *) (f5 :: * -> *).
                                                     (Choice p1, Applicative f5) =>
                                                     p1 () (f5 ()) -> p1 (Line v n) (f5 (Line v n))
                                                $dAsEmpty1
                                                  = \ (@ (p1 :: * -> * -> *))
                                                      (@ (f5 :: * -> *))
                                                      ($dChoice1 :: Choice p1)
                                                      ($dApplicative1 :: Applicative f5) ->
                                                      let {
                                                        dk :: Line v n
                                                        dk
                                                          = case zero $dAdditive $dNum of dt7
                                                            { __DEFAULT ->
                                                            Line (EmptyT `cast` <Co:5>) dt7
                                                            } } in
                                                      let {
                                                        f6
                                                          :: p1 (Either (Line v n) ()) (Either
                                                                                          (Line v n)
                                                                                          (f5 ()))
                                                             -> p1 (Line v n) (f5 (Line v n))
                                                        f6
                                                          = dimap
                                                              ($p1Choice $dChoice1)
                                                              (\ (s :: Line v n) ->
                                                                 case s of wild7 { Line s1 ds ->
                                                                 case s1 `cast` <Co:4> of {
                                                                   __DEFAULT -> Left wild7;
                                                                   EmptyT -> Right ()
                                                                 }
                                                                 })
                                                              (let {
                                                                 f7 :: Line v n -> f5 (Line v n)
                                                                 f7 = pure $dApplicative1 } in
                                                               let {
                                                                 ds :: f5 () -> f5 (Line v n)
                                                                 ds
                                                                   = fmap
                                                                       ($p1Applicative
                                                                          $dApplicative1)
                                                                       (\ (ds1 :: ()) ->
                                                                          case ds1 of { () ->
                                                                          dk
                                                                          }) } in
                                                               \ (ds1
                                                                    :: Either (Line v n) (f5 ())) ->
                                                                 case ds1 of {
                                                                   Left x1 -> f7 x1;
                                                                   Right y1 -> ds y1
                                                                 }) } in
                                                      let {
                                                        g1
                                                          :: p1 () (f5 ())
                                                             -> p1 (Either (Line v n) ()) (Either
                                                                                             (Line
                                                                                                v n)
                                                                                             (f5 ()))
                                                        g1 = right' $dChoice1 } in
                                                      \ (x1 :: p1 () (f5 ())) -> f6 (g1 x1) } in
                                              let {
                                                dk :: Trail v n
                                                dk
                                                  = case ($dAsEmpty1
                                                            $fChoiceTagged
                                                            $fApplicativeIdentity
                                                            (() `cast` <Co:65>))
                                                         `cast` <Co:62>
                                                    of dt7
                                                    { Line ipv ipv1 ->
                                                    OpenTrail dt7
                                                    } } in
                                              let {
                                                f5
                                                  :: p (Either (Trail v n) ()) (Either
                                                                                  (Trail v n)
                                                                                  (f4 ()))
                                                     -> p (Trail v n) (f4 (Trail v n))
                                                f5
                                                  = dimap
                                                      ($p1Choice $dChoice)
                                                      (\ (s :: Trail v n) ->
                                                         case s of wild7 {
                                                           OpenTrail ds ->
                                                             case ($dAsEmpty1
                                                                     $fChoice(->)
                                                                     $mEmpty_$s$fApplicativeConst
                                                                     ($mEmpty1 `cast` <Co:13>)
                                                                     ds)
                                                                  `cast` <Co:18>
                                                             of {
                                                               False -> Left wild7;
                                                               True -> Right ()
                                                             };
                                                           ClosedTrail ipv -> Left wild7
                                                         })
                                                      (let {
                                                         f6 :: Trail v n -> f4 (Trail v n)
                                                         f6 = pure $dApplicative } in
                                                       let {
                                                         ds :: f4 () -> f4 (Trail v n)
                                                         ds
                                                           = fmap
                                                               ($p1Applicative $dApplicative)
                                                               (\ (ds1 :: ()) ->
                                                                  case ds1 of { () -> dk }) } in
                                                       \ (ds1 :: Either (Trail v n) (f4 ())) ->
                                                         case ds1 of {
                                                           Left x1 -> f6 x1;
                                                           Right y1 -> ds y1
                                                         }) } in
                                              let {
                                                g1
                                                  :: p () (f4 ())
                                                     -> p (Either (Trail v n) ()) (Either
                                                                                     (Trail v n)
                                                                                     (f4 ()))
                                                g1 = right' $dChoice } in
                                              \ (x1 :: p () (f4 ())) -> f5 (g1 x1) } in
                                      let {
                                        ds :: Line v n
                                        ds = Line sc2 sc3 } in
                                      let {
                                        ds1 :: Trail v n
                                        ds1 = OpenTrail ds } in
                                      case ($dAsEmpty
                                              $fChoice(->)
                                              $mEmpty_$s$fApplicativeConst
                                              ($mEmpty1 `cast` <Co:13>)
                                              ds1)
                                           `cast` <Co:18>
                                      of {
                                        False ->
                                          case ($dAsEmpty
                                                  $fChoice(->)
                                                  $mEmpty_$s$fApplicativeConst
                                                  ($mEmpty1 `cast` <Co:13>)
                                                  sc)
                                               `cast` <Co:18>
                                          of {
                                            False ->
                                              withLine
                                                $dAdditive
                                                $dNum
                                                (\ (l1 :: Line v n) ->
                                                   withLine
                                                     $dAdditive
                                                     $dNum
                                                     (\ (l2 :: Line v n) ->
                                                        case l1 of { Line s1 o1 ->
                                                        case l2 of { Line s2 o2 ->
                                                        case $fAlternativeSeq2 s1 s2 of nt
                                                        { __DEFAULT ->
                                                        case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                        { __DEFAULT ->
                                                        OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                        }
                                                        }
                                                        }
                                                        })
                                                     sc)
                                                ds1;
                                            True -> ds1
                                          };
                                        True -> sc
                                      }
                                  };
                                True ->
                                  case sc2 `cast` <Co:4> of wild4 {
                                    __DEFAULT ->
                                      jump g
                                        (withLine
                                           $dAdditive
                                           $dNum
                                           (\ (l1 :: Line v n) ->
                                              withLine
                                                $dAdditive
                                                $dNum
                                                (\ (l2 :: Line v n) ->
                                                   case l1 of { Line s1 o1 ->
                                                   case l2 of { Line s2 o2 ->
                                                   case $fAlternativeSeq2 s1 s2 of nt { __DEFAULT ->
                                                   case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                   { __DEFAULT ->
                                                   OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                   }
                                                   }
                                                   }
                                                   })
                                                (OpenTrail (Line (wild4 `cast` <Co:5>) sc3)))
                                           (OpenTrail (Line (wild4 `cast` <Co:5>) sc3)))
                                        (quot $dIntegral sc1 lvl77)
                                        sc;
                                    EmptyT ->
                                      jump $sg
                                        sc (quot $dIntegral sc1 lvl77) (EmptyT `cast` <Co:5>) sc3
                                  }
                              };
                          g :: Trail v n -> b -> Trail v n -> Trail v n
                          g (x1 :: Trail v n) (y1 :: b) (z :: Trail v n)
                            = case even $dIntegral y1 of {
                                False ->
                                  case == $dEq1 y1 lvl78 of {
                                    False ->
                                      let {
                                        karg1 :: b
                                        karg1 = quot $dIntegral (pred $dEnum y1) lvl77 } in
                                      let {
                                        karg2 :: Trail v n
                                        karg2
                                          = join {
                                              $j :: Trail v n
                                              $j
                                                = join {
                                                    $j1 :: Trail v n
                                                    $j1
                                                      = withLine
                                                          $dAdditive
                                                          $dNum
                                                          (\ (l1 :: Line v n) ->
                                                             withLine
                                                               $dAdditive
                                                               $dNum
                                                               (\ (l2 :: Line v n) ->
                                                                  case l1 of { Line s1 o1 ->
                                                                  case l2 of { Line s2 o2 ->
                                                                  case $fAlternativeSeq2 s1 s2 of nt
                                                                  { __DEFAULT ->
                                                                  case ^+^ $dAdditive $dNum o1 o2
                                                                  of dt7
                                                                  { __DEFAULT ->
                                                                  OpenTrail
                                                                    (Line (nt `cast` <Co:5>) dt7)
                                                                  }
                                                                  }
                                                                  }
                                                                  })
                                                               z)
                                                          x1 } in
                                                  case z of {
                                                    OpenTrail ds ->
                                                      case ds of { Line s ds1 ->
                                                      case s `cast` <Co:4> of {
                                                        __DEFAULT -> jump $j1;
                                                        EmptyT -> x1
                                                      }
                                                      };
                                                    ClosedTrail ipv -> jump $j1
                                                  } } in
                                            case x1 of {
                                              OpenTrail ds ->
                                                case ds of { Line s ds1 ->
                                                case s `cast` <Co:4> of {
                                                  __DEFAULT -> jump $j;
                                                  EmptyT -> z
                                                }
                                                };
                                              ClosedTrail ipv -> jump $j
                                            } } in
                                      join {
                                        $j :: Trail v n
                                        $j
                                          = jump g
                                              (withLine
                                                 $dAdditive
                                                 $dNum
                                                 (\ (l1 :: Line v n) ->
                                                    withLine
                                                      $dAdditive
                                                      $dNum
                                                      (\ (l2 :: Line v n) ->
                                                         case l1 of { Line s1 o1 ->
                                                         case l2 of { Line s2 o2 ->
                                                         case $fAlternativeSeq2 s1 s2 of nt
                                                         { __DEFAULT ->
                                                         case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                         { __DEFAULT ->
                                                         OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                         }
                                                         }
                                                         }
                                                         })
                                                      x1)
                                                 x1)
                                              karg1
                                              karg2 } in
                                      case x1 of {
                                        OpenTrail ds ->
                                          case ds of { Line s ds1 ->
                                          case s `cast` <Co:4> of {
                                            __DEFAULT -> jump $j;
                                            EmptyT ->
                                              jump $sg karg2 karg1 (EmptyT `cast` <Co:5>) ds1
                                          }
                                          };
                                        ClosedTrail ipv -> jump $j
                                      };
                                    True -> $fMonoidTrail_$c<> $dAdditive $dNum x1 z
                                  };
                                True ->
                                  join {
                                    $j :: Trail v n
                                    $j
                                      = jump g
                                          (withLine
                                             $dAdditive
                                             $dNum
                                             (\ (l1 :: Line v n) ->
                                                withLine
                                                  $dAdditive
                                                  $dNum
                                                  (\ (l2 :: Line v n) ->
                                                     case l1 of { Line s1 o1 ->
                                                     case l2 of { Line s2 o2 ->
                                                     case $fAlternativeSeq2 s1 s2 of nt
                                                     { __DEFAULT ->
                                                     case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                     { __DEFAULT ->
                                                     OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                     }
                                                     }
                                                     }
                                                     })
                                                  x1)
                                             x1)
                                          (quot $dIntegral y1 lvl77)
                                          z } in
                                  case x1 of {
                                    OpenTrail ds ->
                                      case ds of { Line s ds1 ->
                                      case s `cast` <Co:4> of {
                                        __DEFAULT -> jump $j;
                                        EmptyT ->
                                          jump $sg
                                            z (quot $dIntegral y1 lvl77) (EmptyT `cast` <Co:5>) ds1
                                      }
                                      };
                                    ClosedTrail ipv -> jump $j
                                  }
                              };
                          $sg1 :: Seq (Segment v n) -> v n -> b -> Trail v n -> Trail v n
                          $sg1 (sc :: Seq (Segment v n))
                               (sc1 :: v n)
                               (sc2 :: b)
                               (sc3 :: Trail v n)
                            = case even $dIntegral sc2 of {
                                False ->
                                  case == $dEq1 sc2 lvl78 of {
                                    False ->
                                      let {
                                        karg1 :: b
                                        karg1 = quot $dIntegral (pred $dEnum sc2) lvl77 } in
                                      let {
                                        karg2 :: Trail v n
                                        karg2
                                          = join {
                                              $j :: Trail v n
                                              $j
                                                = case sc `cast` <Co:4> of wild7 {
                                                    __DEFAULT ->
                                                      withLine
                                                        $dAdditive
                                                        $dNum
                                                        (\ (l1 :: Line v n) ->
                                                           withLine
                                                             $dAdditive
                                                             $dNum
                                                             (\ (l2 :: Line v n) ->
                                                                case l1 of { Line s1 o1 ->
                                                                case l2 of { Line s2 o2 ->
                                                                case $fAlternativeSeq2 s1 s2 of nt
                                                                { __DEFAULT ->
                                                                case ^+^ $dAdditive $dNum o1 o2
                                                                of dt7
                                                                { __DEFAULT ->
                                                                OpenTrail
                                                                  (Line (nt `cast` <Co:5>) dt7)
                                                                }
                                                                }
                                                                }
                                                                })
                                                             (OpenTrail
                                                                (Line (wild7 `cast` <Co:5>) sc1)))
                                                        sc3;
                                                    EmptyT -> sc3
                                                  } } in
                                            case sc3 of {
                                              OpenTrail ds ->
                                                case ds of { Line s ds1 ->
                                                case s `cast` <Co:4> of {
                                                  __DEFAULT -> jump $j;
                                                  EmptyT -> OpenTrail (Line sc sc1)
                                                }
                                                };
                                              ClosedTrail ipv -> jump $j
                                            } } in
                                      join {
                                        $j :: Trail v n
                                        $j
                                          = jump g
                                              (withLine
                                                 $dAdditive
                                                 $dNum
                                                 (\ (l1 :: Line v n) ->
                                                    withLine
                                                      $dAdditive
                                                      $dNum
                                                      (\ (l2 :: Line v n) ->
                                                         case l1 of { Line s1 o1 ->
                                                         case l2 of { Line s2 o2 ->
                                                         case $fAlternativeSeq2 s1 s2 of nt
                                                         { __DEFAULT ->
                                                         case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                         { __DEFAULT ->
                                                         OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                         }
                                                         }
                                                         }
                                                         })
                                                      sc3)
                                                 sc3)
                                              karg1
                                              karg2 } in
                                      case sc3 of {
                                        OpenTrail ds ->
                                          case ds of { Line s ds1 ->
                                          case s `cast` <Co:4> of {
                                            __DEFAULT -> jump $j;
                                            EmptyT ->
                                              jump $sg karg2 karg1 (EmptyT `cast` <Co:5>) ds1
                                          }
                                          };
                                        ClosedTrail ipv -> jump $j
                                      };
                                    True ->
                                      let {
                                        $dAsEmpty
                                          :: forall (p :: * -> * -> *) (f4 :: * -> *).
                                             (Choice p, Applicative f4) =>
                                             p () (f4 ()) -> p (Trail v n) (f4 (Trail v n))
                                        $dAsEmpty
                                          = \ (@ (p :: * -> * -> *))
                                              (@ (f4 :: * -> *))
                                              ($dChoice :: Choice p)
                                              ($dApplicative :: Applicative f4) ->
                                              let {
                                                $dAsEmpty1
                                                  :: forall (p1 :: * -> * -> *) (f5 :: * -> *).
                                                     (Choice p1, Applicative f5) =>
                                                     p1 () (f5 ()) -> p1 (Line v n) (f5 (Line v n))
                                                $dAsEmpty1
                                                  = \ (@ (p1 :: * -> * -> *))
                                                      (@ (f5 :: * -> *))
                                                      ($dChoice1 :: Choice p1)
                                                      ($dApplicative1 :: Applicative f5) ->
                                                      let {
                                                        dk :: Line v n
                                                        dk
                                                          = case zero $dAdditive $dNum of dt7
                                                            { __DEFAULT ->
                                                            Line (EmptyT `cast` <Co:5>) dt7
                                                            } } in
                                                      let {
                                                        f6
                                                          :: p1 (Either (Line v n) ()) (Either
                                                                                          (Line v n)
                                                                                          (f5 ()))
                                                             -> p1 (Line v n) (f5 (Line v n))
                                                        f6
                                                          = dimap
                                                              ($p1Choice $dChoice1)
                                                              (\ (s :: Line v n) ->
                                                                 case s of wild7 { Line s1 ds ->
                                                                 case s1 `cast` <Co:4> of {
                                                                   __DEFAULT -> Left wild7;
                                                                   EmptyT -> Right ()
                                                                 }
                                                                 })
                                                              (let {
                                                                 f7 :: Line v n -> f5 (Line v n)
                                                                 f7 = pure $dApplicative1 } in
                                                               let {
                                                                 ds :: f5 () -> f5 (Line v n)
                                                                 ds
                                                                   = fmap
                                                                       ($p1Applicative
                                                                          $dApplicative1)
                                                                       (\ (ds1 :: ()) ->
                                                                          case ds1 of { () ->
                                                                          dk
                                                                          }) } in
                                                               \ (ds1
                                                                    :: Either (Line v n) (f5 ())) ->
                                                                 case ds1 of {
                                                                   Left x1 -> f7 x1;
                                                                   Right y1 -> ds y1
                                                                 }) } in
                                                      let {
                                                        g1
                                                          :: p1 () (f5 ())
                                                             -> p1 (Either (Line v n) ()) (Either
                                                                                             (Line
                                                                                                v n)
                                                                                             (f5 ()))
                                                        g1 = right' $dChoice1 } in
                                                      \ (x1 :: p1 () (f5 ())) -> f6 (g1 x1) } in
                                              let {
                                                dk :: Trail v n
                                                dk
                                                  = case ($dAsEmpty1
                                                            $fChoiceTagged
                                                            $fApplicativeIdentity
                                                            (() `cast` <Co:65>))
                                                         `cast` <Co:62>
                                                    of dt7
                                                    { Line ipv ipv1 ->
                                                    OpenTrail dt7
                                                    } } in
                                              let {
                                                f5
                                                  :: p (Either (Trail v n) ()) (Either
                                                                                  (Trail v n)
                                                                                  (f4 ()))
                                                     -> p (Trail v n) (f4 (Trail v n))
                                                f5
                                                  = dimap
                                                      ($p1Choice $dChoice)
                                                      (\ (s :: Trail v n) ->
                                                         case s of wild7 {
                                                           OpenTrail ds ->
                                                             case ($dAsEmpty1
                                                                     $fChoice(->)
                                                                     $mEmpty_$s$fApplicativeConst
                                                                     ($mEmpty1 `cast` <Co:13>)
                                                                     ds)
                                                                  `cast` <Co:18>
                                                             of {
                                                               False -> Left wild7;
                                                               True -> Right ()
                                                             };
                                                           ClosedTrail ipv -> Left wild7
                                                         })
                                                      (let {
                                                         f6 :: Trail v n -> f4 (Trail v n)
                                                         f6 = pure $dApplicative } in
                                                       let {
                                                         ds :: f4 () -> f4 (Trail v n)
                                                         ds
                                                           = fmap
                                                               ($p1Applicative $dApplicative)
                                                               (\ (ds1 :: ()) ->
                                                                  case ds1 of { () -> dk }) } in
                                                       \ (ds1 :: Either (Trail v n) (f4 ())) ->
                                                         case ds1 of {
                                                           Left x1 -> f6 x1;
                                                           Right y1 -> ds y1
                                                         }) } in
                                              let {
                                                g1
                                                  :: p () (f4 ())
                                                     -> p (Either (Trail v n) ()) (Either
                                                                                     (Trail v n)
                                                                                     (f4 ()))
                                                g1 = right' $dChoice } in
                                              \ (x1 :: p () (f4 ())) -> f5 (g1 x1) } in
                                      let {
                                        t2 :: Line v n
                                        t2 = Line sc sc1 } in
                                      let {
                                        t1 :: Trail v n
                                        t1 = OpenTrail t2 } in
                                      case ($dAsEmpty
                                              $fChoice(->)
                                              $mEmpty_$s$fApplicativeConst
                                              ($mEmpty1 `cast` <Co:13>)
                                              sc3)
                                           `cast` <Co:18>
                                      of {
                                        False ->
                                          case ($dAsEmpty
                                                  $fChoice(->)
                                                  $mEmpty_$s$fApplicativeConst
                                                  ($mEmpty1 `cast` <Co:13>)
                                                  t1)
                                               `cast` <Co:18>
                                          of {
                                            False ->
                                              withLine
                                                $dAdditive
                                                $dNum
                                                (\ (l1 :: Line v n) ->
                                                   withLine
                                                     $dAdditive
                                                     $dNum
                                                     (\ (l2 :: Line v n) ->
                                                        case l1 of { Line s1 o1 ->
                                                        case l2 of { Line s2 o2 ->
                                                        case $fAlternativeSeq2 s1 s2 of nt
                                                        { __DEFAULT ->
                                                        case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                        { __DEFAULT ->
                                                        OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                        }
                                                        }
                                                        }
                                                        })
                                                     t1)
                                                sc3;
                                            True -> sc3
                                          };
                                        True -> t1
                                      }
                                  };
                                True ->
                                  join {
                                    $j :: Trail v n
                                    $j
                                      = jump $sg1
                                          sc
                                          sc1
                                          (quot $dIntegral sc2 lvl77)
                                          (withLine
                                             $dAdditive
                                             $dNum
                                             (\ (l1 :: Line v n) ->
                                                withLine
                                                  $dAdditive
                                                  $dNum
                                                  (\ (l2 :: Line v n) ->
                                                     case l1 of { Line s1 o1 ->
                                                     case l2 of { Line s2 o2 ->
                                                     case $fAlternativeSeq2 s1 s2 of nt
                                                     { __DEFAULT ->
                                                     case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                     { __DEFAULT ->
                                                     OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                     }
                                                     }
                                                     }
                                                     })
                                                  sc3)
                                             sc3) } in
                                  case sc3 of {
                                    OpenTrail ds ->
                                      case ds of { Line s ds1 ->
                                      case s `cast` <Co:4> of {
                                        __DEFAULT -> jump $j;
                                        EmptyT ->
                                          jump $sg2
                                            sc
                                            sc1
                                            (quot $dIntegral sc2 lvl77)
                                            (EmptyT `cast` <Co:5>)
                                            ds1
                                      }
                                      };
                                    ClosedTrail ipv -> jump $j
                                  }
                              };
                          $sg2
                            :: Seq (Segment v n)
                               -> v n -> b -> Seq (Segment v n) -> v n -> Trail v n
                          $sg2 (sc :: Seq (Segment v n))
                               (sc1 :: v n)
                               (sc2 :: b)
                               (sc3 :: Seq (Segment v n))
                               (sc4 :: v n)
                            = case even $dIntegral sc2 of {
                                False ->
                                  case == $dEq1 sc2 lvl78 of {
                                    False ->
                                      let {
                                        karg1 :: b
                                        karg1 = quot $dIntegral (pred $dEnum sc2) lvl77 } in
                                      let {
                                        karg2 :: Trail v n
                                        karg2
                                          = case sc3 `cast` <Co:4> of wild7 {
                                              __DEFAULT ->
                                                case sc `cast` <Co:4> of wild8 {
                                                  __DEFAULT ->
                                                    withLine
                                                      $dAdditive
                                                      $dNum
                                                      (\ (l1 :: Line v n) ->
                                                         withLine
                                                           $dAdditive
                                                           $dNum
                                                           (\ (l2 :: Line v n) ->
                                                              case l1 of { Line s1 o1 ->
                                                              case l2 of { Line s2 o2 ->
                                                              case $fAlternativeSeq2 s1 s2 of nt
                                                              { __DEFAULT ->
                                                              case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                              { __DEFAULT ->
                                                              OpenTrail
                                                                (Line (nt `cast` <Co:5>) dt7)
                                                              }
                                                              }
                                                              }
                                                              })
                                                           (OpenTrail
                                                              (Line (wild8 `cast` <Co:5>) sc1)))
                                                      (OpenTrail (Line (wild7 `cast` <Co:5>) sc4));
                                                  EmptyT ->
                                                    OpenTrail (Line (wild7 `cast` <Co:5>) sc4)
                                                };
                                              EmptyT -> OpenTrail (Line sc sc1)
                                            } } in
                                      case sc3 `cast` <Co:4> of wild7 {
                                        __DEFAULT ->
                                          jump g
                                            (withLine
                                               $dAdditive
                                               $dNum
                                               (\ (l1 :: Line v n) ->
                                                  withLine
                                                    $dAdditive
                                                    $dNum
                                                    (\ (l2 :: Line v n) ->
                                                       case l1 of { Line s1 o1 ->
                                                       case l2 of { Line s2 o2 ->
                                                       case $fAlternativeSeq2 s1 s2 of nt
                                                       { __DEFAULT ->
                                                       case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                       { __DEFAULT ->
                                                       OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                       }
                                                       }
                                                       }
                                                       })
                                                    (OpenTrail (Line (wild7 `cast` <Co:5>) sc4)))
                                               (OpenTrail (Line (wild7 `cast` <Co:5>) sc4)))
                                            karg1
                                            karg2;
                                        EmptyT -> jump $sg karg2 karg1 (EmptyT `cast` <Co:5>) sc4
                                      };
                                    True ->
                                      let {
                                        $dAsEmpty
                                          :: forall (p :: * -> * -> *) (f4 :: * -> *).
                                             (Choice p, Applicative f4) =>
                                             p () (f4 ()) -> p (Trail v n) (f4 (Trail v n))
                                        $dAsEmpty
                                          = \ (@ (p :: * -> * -> *))
                                              (@ (f4 :: * -> *))
                                              ($dChoice :: Choice p)
                                              ($dApplicative :: Applicative f4) ->
                                              let {
                                                $dAsEmpty1
                                                  :: forall (p1 :: * -> * -> *) (f5 :: * -> *).
                                                     (Choice p1, Applicative f5) =>
                                                     p1 () (f5 ()) -> p1 (Line v n) (f5 (Line v n))
                                                $dAsEmpty1
                                                  = \ (@ (p1 :: * -> * -> *))
                                                      (@ (f5 :: * -> *))
                                                      ($dChoice1 :: Choice p1)
                                                      ($dApplicative1 :: Applicative f5) ->
                                                      let {
                                                        dk :: Line v n
                                                        dk
                                                          = case zero $dAdditive $dNum of dt7
                                                            { __DEFAULT ->
                                                            Line (EmptyT `cast` <Co:5>) dt7
                                                            } } in
                                                      let {
                                                        f6
                                                          :: p1 (Either (Line v n) ()) (Either
                                                                                          (Line v n)
                                                                                          (f5 ()))
                                                             -> p1 (Line v n) (f5 (Line v n))
                                                        f6
                                                          = dimap
                                                              ($p1Choice $dChoice1)
                                                              (\ (s :: Line v n) ->
                                                                 case s of wild7 { Line s1 ds ->
                                                                 case s1 `cast` <Co:4> of {
                                                                   __DEFAULT -> Left wild7;
                                                                   EmptyT -> Right ()
                                                                 }
                                                                 })
                                                              (let {
                                                                 f7 :: Line v n -> f5 (Line v n)
                                                                 f7 = pure $dApplicative1 } in
                                                               let {
                                                                 ds :: f5 () -> f5 (Line v n)
                                                                 ds
                                                                   = fmap
                                                                       ($p1Applicative
                                                                          $dApplicative1)
                                                                       (\ (ds1 :: ()) ->
                                                                          case ds1 of { () ->
                                                                          dk
                                                                          }) } in
                                                               \ (ds1
                                                                    :: Either (Line v n) (f5 ())) ->
                                                                 case ds1 of {
                                                                   Left x1 -> f7 x1;
                                                                   Right y1 -> ds y1
                                                                 }) } in
                                                      let {
                                                        g1
                                                          :: p1 () (f5 ())
                                                             -> p1 (Either (Line v n) ()) (Either
                                                                                             (Line
                                                                                                v n)
                                                                                             (f5 ()))
                                                        g1 = right' $dChoice1 } in
                                                      \ (x1 :: p1 () (f5 ())) -> f6 (g1 x1) } in
                                              let {
                                                dk :: Trail v n
                                                dk
                                                  = case ($dAsEmpty1
                                                            $fChoiceTagged
                                                            $fApplicativeIdentity
                                                            (() `cast` <Co:65>))
                                                         `cast` <Co:62>
                                                    of dt7
                                                    { Line ipv ipv1 ->
                                                    OpenTrail dt7
                                                    } } in
                                              let {
                                                f5
                                                  :: p (Either (Trail v n) ()) (Either
                                                                                  (Trail v n)
                                                                                  (f4 ()))
                                                     -> p (Trail v n) (f4 (Trail v n))
                                                f5
                                                  = dimap
                                                      ($p1Choice $dChoice)
                                                      (\ (s :: Trail v n) ->
                                                         case s of wild7 {
                                                           OpenTrail ds ->
                                                             case ($dAsEmpty1
                                                                     $fChoice(->)
                                                                     $mEmpty_$s$fApplicativeConst
                                                                     ($mEmpty1 `cast` <Co:13>)
                                                                     ds)
                                                                  `cast` <Co:18>
                                                             of {
                                                               False -> Left wild7;
                                                               True -> Right ()
                                                             };
                                                           ClosedTrail ipv -> Left wild7
                                                         })
                                                      (let {
                                                         f6 :: Trail v n -> f4 (Trail v n)
                                                         f6 = pure $dApplicative } in
                                                       let {
                                                         ds :: f4 () -> f4 (Trail v n)
                                                         ds
                                                           = fmap
                                                               ($p1Applicative $dApplicative)
                                                               (\ (ds1 :: ()) ->
                                                                  case ds1 of { () -> dk }) } in
                                                       \ (ds1 :: Either (Trail v n) (f4 ())) ->
                                                         case ds1 of {
                                                           Left x1 -> f6 x1;
                                                           Right y1 -> ds y1
                                                         }) } in
                                              let {
                                                g1
                                                  :: p () (f4 ())
                                                     -> p (Either (Trail v n) ()) (Either
                                                                                     (Trail v n)
                                                                                     (f4 ()))
                                                g1 = right' $dChoice } in
                                              \ (x1 :: p () (f4 ())) -> f5 (g1 x1) } in
                                      let {
                                        ds :: Line v n
                                        ds = Line sc3 sc4 } in
                                      let {
                                        ds1 :: Trail v n
                                        ds1 = OpenTrail ds } in
                                      let {
                                        t2 :: Line v n
                                        t2 = Line sc sc1 } in
                                      let {
                                        t1 :: Trail v n
                                        t1 = OpenTrail t2 } in
                                      case ($dAsEmpty
                                              $fChoice(->)
                                              $mEmpty_$s$fApplicativeConst
                                              ($mEmpty1 `cast` <Co:13>)
                                              ds1)
                                           `cast` <Co:18>
                                      of {
                                        False ->
                                          case ($dAsEmpty
                                                  $fChoice(->)
                                                  $mEmpty_$s$fApplicativeConst
                                                  ($mEmpty1 `cast` <Co:13>)
                                                  t1)
                                               `cast` <Co:18>
                                          of {
                                            False ->
                                              withLine
                                                $dAdditive
                                                $dNum
                                                (\ (l1 :: Line v n) ->
                                                   withLine
                                                     $dAdditive
                                                     $dNum
                                                     (\ (l2 :: Line v n) ->
                                                        case l1 of { Line s1 o1 ->
                                                        case l2 of { Line s2 o2 ->
                                                        case $fAlternativeSeq2 s1 s2 of nt
                                                        { __DEFAULT ->
                                                        case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                        { __DEFAULT ->
                                                        OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                        }
                                                        }
                                                        }
                                                        })
                                                     t1)
                                                ds1;
                                            True -> ds1
                                          };
                                        True -> t1
                                      }
                                  };
                                True ->
                                  case sc3 `cast` <Co:4> of wild4 {
                                    __DEFAULT ->
                                      jump $sg1
                                        sc
                                        sc1
                                        (quot $dIntegral sc2 lvl77)
                                        (withLine
                                           $dAdditive
                                           $dNum
                                           (\ (l1 :: Line v n) ->
                                              withLine
                                                $dAdditive
                                                $dNum
                                                (\ (l2 :: Line v n) ->
                                                   case l1 of { Line s1 o1 ->
                                                   case l2 of { Line s2 o2 ->
                                                   case $fAlternativeSeq2 s1 s2 of nt { __DEFAULT ->
                                                   case ^+^ $dAdditive $dNum o1 o2 of dt7
                                                   { __DEFAULT ->
                                                   OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                                   }
                                                   }
                                                   }
                                                   })
                                                (OpenTrail (Line (wild4 `cast` <Co:5>) sc4)))
                                           (OpenTrail (Line (wild4 `cast` <Co:5>) sc4)));
                                    EmptyT ->
                                      jump $sg2
                                        sc
                                        sc1
                                        (quot $dIntegral sc2 lvl77)
                                        (EmptyT `cast` <Co:5>)
                                        sc4
                                  }
                              }; } in
                        join {
                          $j :: Trail v n
                          $j
                            = jump g
                                (withLine
                                   $dAdditive
                                   $dNum
                                   (\ (l1 :: Line v n) ->
                                      withLine
                                        $dAdditive
                                        $dNum
                                        (\ (l2 :: Line v n) ->
                                           case l1 of { Line s1 o1 ->
                                           case l2 of { Line s2 o2 ->
                                           case $fAlternativeSeq2 s1 s2 of nt { __DEFAULT ->
                                           case ^+^ $dAdditive $dNum o1 o2 of dt7 { __DEFAULT ->
                                           OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                           }
                                           }
                                           }
                                           })
                                        x)
                                   x)
                                karg
                                x } in
                        case x of {
                          OpenTrail ds ->
                            case ds of { Line s ds1 ->
                            case s `cast` <Co:4> of {
                              __DEFAULT -> jump $j;
                              EmptyT ->
                                jump $sg2
                                  (EmptyT `cast` <Co:5>) ds1 karg (EmptyT `cast` <Co:5>) ds1
                            }
                            };
                          ClosedTrail ipv -> jump $j
                        };
                      True -> x
                    };
                  True ->
                    join {
                      $j :: Trail v n
                      $j
                        = jump f3
                            (withLine
                               $dAdditive
                               $dNum
                               (\ (l1 :: Line v n) ->
                                  withLine
                                    $dAdditive
                                    $dNum
                                    (\ (l2 :: Line v n) ->
                                       case l1 of { Line s1 o1 ->
                                       case l2 of { Line s2 o2 ->
                                       case $fAlternativeSeq2 s1 s2 of nt { __DEFAULT ->
                                       case ^+^ $dAdditive $dNum o1 o2 of dt7 { __DEFAULT ->
                                       OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                       }
                                       }
                                       }
                                       })
                                    x)
                               x)
                            (quot $dIntegral y lvl77) } in
                    case x of {
                      OpenTrail ds ->
                        case ds of { Line s ds1 ->
                        case s `cast` <Co:4> of {
                          __DEFAULT -> jump $j;
                          EmptyT ->
                            jump $sf (quot $dIntegral y lvl77) (EmptyT `cast` <Co:5>) ds1
                        }
                        };
                      ClosedTrail ipv -> jump $j
                    }
                }; } in
          jump f3 eta1 eta;
        True -> lvl42
      }

-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
$fSemigroupTrail
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Semigroup (Trail v n)
$fSemigroupTrail
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      C:Semigroup
        ($fMonoidTrail_$c<> $dAdditive $dNum)
        ($fSemigroupTrail_$csconcat $dAdditive $dNum)
        ($fSemigroupTrail_$cstimes $dAdditive $dNum)

-- RHS size: {terms: 87, types: 152, coercions: 18, joins: 2/5}
$fMonoidTrail_$cmconcat
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     [Trail v n] -> Trail v n
$fMonoidTrail_$cmconcat
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      let {
        z :: Trail v n
        z = case zero $dAdditive $dNum of dt7 { __DEFAULT ->
            OpenTrail (Line (EmptyT `cast` <Co:5>) dt7)
            } } in
      letrec {
        go1 :: [Trail v n] -> Trail v n
        go1
          = \ (ds :: [Trail v n]) ->
              case ds of {
                [] -> z;
                : y ys ->
                  let {
                    t2 :: Trail v n
                    t2 = go1 ys } in
                  join {
                    $j :: Trail v n
                    $j
                      = join {
                          $j1 :: Trail v n
                          $j1
                            = withLine
                                $dAdditive
                                $dNum
                                (\ (l1 :: Line v n) ->
                                   withLine
                                     $dAdditive
                                     $dNum
                                     (\ (l2 :: Line v n) ->
                                        case l1 of { Line s1 o1 ->
                                        case l2 of { Line s2 o2 ->
                                        case $fAlternativeSeq2 s1 s2 of nt { __DEFAULT ->
                                        case ^+^ $dAdditive $dNum o1 o2 of dt7 { __DEFAULT ->
                                        OpenTrail (Line (nt `cast` <Co:5>) dt7)
                                        }
                                        }
                                        }
                                        })
                                     t2)
                                y } in
                        case t2 of {
                          OpenTrail ds1 ->
                            case ds1 of { Line s ds2 ->
                            case s `cast` <Co:4> of {
                              __DEFAULT -> jump $j1;
                              EmptyT -> y
                            }
                            };
                          ClosedTrail ipv -> jump $j1
                        } } in
                  case y of {
                    OpenTrail ds1 ->
                      case ds1 of { Line s ds2 ->
                      case s `cast` <Co:4> of {
                        __DEFAULT -> jump $j;
                        EmptyT -> t2
                      }
                      };
                    ClosedTrail ipv -> jump $j
                  }
              }; } in
      go1

-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
$fMonoidTrail
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Monoid (Trail v n)
$fMonoidTrail
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      C:Monoid
        ($fMonoidTrail_$cmempty $dAdditive $dNum)
        ($fMonoidTrail_$c<> $dAdditive $dNum)
        ($fMonoidTrail_$cmconcat $dAdditive $dNum)

-- RHS size: {terms: 156, types: 278, coercions: 1,177, joins: 1/6}
$fFromTrailLine_$cfromLocTrail
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Located (Trail (V (Line v n)) (N (Line v n))) -> Line v n
$fFromTrailLine_$cfromLocTrail
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n)
      (eta :: Located (Trail (V (Line v n)) (N (Line v n)))) ->
      case eta `cast` <Co:8> of { Loc ds1 ds2 ->
      case ds2 of {
        OpenTrail line -> line;
        ClosedTrail loop ->
          case loop of { Loop ds ds4 ->
          case ds of { Line ds5 o ->
          let {
            loopR :: Additive v
            loopR = $p1Metric $dMetric } in
          let {
            loopR1 :: Floating n
            loopR1 = $p1(%,%) $d(%,%) } in
          let {
            loopR2 :: Fractional n
            loopR2 = $p1Floating loopR1 } in
          let {
            loopR3 :: Num n
            loopR3 = $p1Fractional loopR2 } in
          case ds5 `cast` <Co:4> of wild4 {
            __DEFAULT ->
              let {
                y :: Segment v n
                y = case ds4 of {
                      LinearClosing ->
                        case fmap ($p1Additive loopR) (negate loopR3) o of dt7
                        { __DEFAULT ->
                        Linear dt7
                        };
                      CubicClosing c1 c2 ->
                        case fmap ($p1Additive loopR) (negate loopR3) o of dt7
                        { __DEFAULT ->
                        Cubic c1 c2 dt7
                        }
                    } } in
              join {
                $j :: Seq (Segment v n) -> Line v n
                $j (dt7 :: Seq (Segment v n))
                  = case ^+^
                           loopR
                           loopR3
                           o
                           (case y of {
                              Linear v1 -> v1;
                              Cubic ds6 ds7 v1 -> v1
                            })
                    of dt8
                    { __DEFAULT ->
                    Line dt7 dt8
                    } } in
              case wild4 of {
                Single a2 ->
                  jump $j
                    ((Deep 2# (One a2) EmptyT (One (y `cast` <Co:32>)))
                     `cast` <Co:200>);
                Deep dt7 pr m ds6 ->
                  case ds6 of {
                    One a2 ->
                      jump $j
                        ((Deep (+# dt7 1#) pr m (Two a2 (y `cast` <Co:32>)))
                         `cast` <Co:200>);
                    Two a2 b ->
                      jump $j
                        ((Deep (+# dt7 1#) pr m (Three a2 b (y `cast` <Co:32>)))
                         `cast` <Co:200>);
                    Three a2 b c ->
                      jump $j
                        ((Deep (+# dt7 1#) pr m (Four a2 b c (y `cast` <Co:32>)))
                         `cast` <Co:200>);
                    Four a2 b c d ->
                      case m of m1 { __DEFAULT ->
                      jump $j
                        ((Deep
                            (+# dt7 1#)
                            pr
                            ($b:|>_$s$ssnocTree 3# a2 b c m1)
                            (Two d (y `cast` <Co:32>)))
                         `cast` <Co:200>)
                      }
                  }
              };
            EmptyT ->
              case zero loopR loopR3 of dt7 { __DEFAULT ->
              Line (EmptyT `cast` <Co:5>) dt7
              }
          }
          }
          }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
$fFromTrailLine
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     FromTrail (Line v n)
$fFromTrailLine = $fFromTrailLine_$cfromLocTrail `cast` <Co:19>

-- RHS size: {terms: 178, types: 533, coercions: 1,657, joins: 1/6}
$wfromLocOffsets
  :: forall (v :: * -> *) n t.
     (InSpace v n t, InSpace v n (v n), FromTrail t) =>
     Located [v n] -> t
$wfromLocOffsets
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      (w :: InSpace v n t)
      (w1 :: InSpace v n (v n))
      (w2 :: FromTrail t)
      (w3 :: Located [v n]) ->
      case HEq_sc (($p2(%,,,%) w1) `cast` <Co:6>) of cobox { __DEFAULT ->
      case HEq_sc (($p1(%,,,%) w1) `cast` <Co:7>) of cobox1
      { __DEFAULT ->
      case HEq_sc (($p2(%,,,%) w) `cast` <Co:5>) of cobox2 { __DEFAULT ->
      case HEq_sc (($p1(%,,,%) w) `cast` <Co:6>) of cobox3 { __DEFAULT ->
      (w2 `cast` <Co:9>)
        (case w3 of { Loc p a1 ->
         case HEq_sc (($p2(%,,,%) (w `cast` <Co:27>)) `cast` <Co:7>)
         of cobox4
         { __DEFAULT ->
         case HEq_sc (($p1(%,,,%) (w `cast` <Co:27>)) `cast` <Co:8>)
         of cobox5
         { __DEFAULT ->
         case zero
                ($p3(%,,,%) (w `cast` <Co:27>)) ($p4(%,,,%) (w `cast` <Co:27>))
         of
         { __DEFAULT ->
         let {
           $dNum :: Num n
           $dNum = $p4(%,,,%) (w `cast` <Co:27>) } in
         let {
           $dAdditive :: Additive v
           $dAdditive = $p3(%,,,%) (w `cast` <Co:27>) } in
         case zero $dAdditive $dNum of dt7 { __DEFAULT ->
         let {
           z :: Line v n
           z = Line (EmptyT `cast` <Co:5>) dt7 } in
         letrec {
           go1 :: [v n] -> Line v n
           go1
             = \ (ds :: [v n]) ->
                 case ds of {
                   [] -> z;
                   : y ys ->
                     case go1 ys of { Line ss o ->
                     let {
                       x :: Segment v n
                       x = case y of dt8 { __DEFAULT -> Linear dt8 } } in
                     join {
                       $j :: Seq (Segment v n) -> Line v n
                       $j (dt8 :: Seq (Segment v n))
                         = case ^+^
                                  $dAdditive
                                  $dNum
                                  o
                                  (case x of {
                                     Linear v1 -> v1;
                                     Cubic ds1 ds2 v1 -> v1
                                   })
                           of dt9
                           { __DEFAULT ->
                           Line dt8 dt9
                           } } in
                     case ss `cast` <Co:32> of {
                       EmptyT -> jump $j ((Single (x `cast` <Co:31>)) `cast` <Co:200>);
                       Single b ->
                         jump $j
                           ((Deep 2# (One (x `cast` <Co:31>)) EmptyT (One b))
                            `cast` <Co:200>);
                       Deep dt8 ds1 m sf ->
                         case ds1 of {
                           One b ->
                             jump $j
                               ((Deep (+# 1# dt8) (Two (x `cast` <Co:31>) b) m sf)
                                `cast` <Co:200>);
                           Two b c ->
                             jump $j
                               ((Deep (+# 1# dt8) (Three (x `cast` <Co:31>) b c) m sf)
                                `cast` <Co:200>);
                           Three b c d ->
                             jump $j
                               ((Deep (+# 1# dt8) (Four (x `cast` <Co:31>) b c d) m sf)
                                `cast` <Co:200>);
                           Four b c d e ->
                             case m of m1 { __DEFAULT ->
                             jump $j
                               ((Deep
                                   (+# 1# dt8)
                                   (Two (x `cast` <Co:31>) b)
                                   ($b:<|_$s$sconsTree m1 3# c d e)
                                   sf)
                                `cast` <Co:200>)
                             }
                         }
                     }
                     }
                 }; } in
         case go1 a1 of dt8 { Line ipv ipv1 ->
         Loc (p `cast` <Co:24>) (OpenTrail dt8)
         }
         }
         }
         }
         }
         })
      }
      }
      }
      }

-- RHS size: {terms: 14, types: 27, coercions: 0, joins: 0/0}
fromLocOffsets
  :: forall (v :: * -> *) n t.
     (InSpace v n t, InSpace v n (v n), Metric v, OrderedField n,
      FromTrail t) =>
     Located [v n] -> t
fromLocOffsets
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      (w :: InSpace v n t)
      (w1 :: InSpace v n (v n))
      _
      _
      (w4 :: FromTrail t)
      (w5 :: Located [v n]) ->
      $wfromLocOffsets w w1 w4 w5

-- RHS size: {terms: 314,
              types: 781,
              coercions: 3,159,
              joins: 2/10}
$wfromVertices
  :: forall (v :: * -> *) n t.
     (InSpace v n t, FromTrail t) =>
     [Point v n] -> t
$wfromVertices
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      (w :: InSpace v n t)
      (w1 :: FromTrail t)
      (w2 :: [Point v n]) ->
      case HEq_sc (($p2(%,,,%) w) `cast` <Co:5>) of cobox { __DEFAULT ->
      case HEq_sc (($p1(%,,,%) w) `cast` <Co:6>) of cobox1 { __DEFAULT ->
      case w2 of {
        [] ->
          (w1 `cast` <Co:2>)
            (case zero ($p3(%,,,%) w) ($p4(%,,,%) w) of nt { __DEFAULT ->
             (Loc
                (nt `cast` <Co:10>) (OpenTrail (Line (EmptyT `cast` <Co:5>) nt)))
             `cast` <Co:6>
             });
        : p ps ->
          (w1 `cast` <Co:2>)
            (case p `cast` <Co:3> of nt { __DEFAULT ->
             case HEq_sc (($p2(%,,,%) (w `cast` <Co:27>)) `cast` <Co:7>)
             of cobox2
             { __DEFAULT ->
             case HEq_sc (($p1(%,,,%) (w `cast` <Co:27>)) `cast` <Co:8>)
             of cobox3
             { __DEFAULT ->
             case zero
                    ($p3(%,,,%) (w `cast` <Co:27>)) ($p4(%,,,%) (w `cast` <Co:27>))
             of
             { __DEFAULT ->
             let {
               $dNum :: Num n
               $dNum = $p4(%,,,%) (w `cast` <Co:27>) } in
             let {
               $dAdditive :: Additive v
               $dAdditive = $p3(%,,,%) (w `cast` <Co:27>) } in
             case zero $dAdditive $dNum of dt7 { __DEFAULT ->
             let {
               f3 :: v n -> v n -> v n
               f3 = ^-^ ($p3(%,,,%) w) ($p4(%,,,%) w) } in
             let {
               z :: Line v n
               z = Line (EmptyT `cast` <Co:5>) dt7 } in
             letrec {
               $sgo2 :: [Point v n] -> Point v n -> [Point v n] -> Line v n
               $sgo2
                 = \ (sc :: [Point v n]) (sc1 :: Point v n) (sc2 :: [Point v n]) ->
                     case sc of {
                       [] -> z;
                       : ipv2 ipv3 ->
                         case go2 sc2 ipv3 of { Line ss o ->
                         let {
                           x :: Segment v n
                           x = case f3 (ipv2 `cast` <Co:20>) (sc1 `cast` <Co:21>) of dt8
                               { __DEFAULT ->
                               Linear dt8
                               } } in
                         join {
                           $j :: Seq (Segment v n) -> Line v n
                           $j (dt8 :: Seq (Segment v n))
                             = case ^+^
                                      $dAdditive
                                      $dNum
                                      o
                                      (case x of {
                                         Linear v1 -> v1;
                                         Cubic ds1 ds2 v1 -> v1
                                       })
                               of dt9
                               { __DEFAULT ->
                               Line dt8 dt9
                               } } in
                         case ss `cast` <Co:32> of {
                           EmptyT -> jump $j ((Single (x `cast` <Co:31>)) `cast` <Co:200>);
                           Single b ->
                             jump $j
                               ((Deep 2# (One (x `cast` <Co:31>)) EmptyT (One b))
                                `cast` <Co:200>);
                           Deep dt8 ds1 m sf ->
                             case ds1 of {
                               One b ->
                                 jump $j
                                   ((Deep (+# 1# dt8) (Two (x `cast` <Co:31>) b) m sf)
                                    `cast` <Co:200>);
                               Two b c ->
                                 jump $j
                                   ((Deep (+# 1# dt8) (Three (x `cast` <Co:31>) b c) m sf)
                                    `cast` <Co:200>);
                               Three b c d ->
                                 jump $j
                                   ((Deep (+# 1# dt8) (Four (x `cast` <Co:31>) b c d) m sf)
                                    `cast` <Co:200>);
                               Four b c d e ->
                                 case m of m1 { __DEFAULT ->
                                 jump $j
                                   ((Deep
                                       (+# 1# dt8)
                                       (Two (x `cast` <Co:31>) b)
                                       ($b:<|_$s$sconsTree m1 3# c d e)
                                       sf)
                                    `cast` <Co:200>)
                                 }
                             }
                         }
                         }
                     };
               go2 :: [Point v n] -> [Point v n] -> Line v n
               go2
                 = \ (ds :: [Point v n]) (_ys :: [Point v n]) ->
                     case ds of {
                       [] -> z;
                       : ipv ipv1 ->
                         case _ys of {
                           [] -> z;
                           : ipv2 ipv3 ->
                             case go2 ipv1 ipv3 of { Line ss o ->
                             let {
                               x :: Segment v n
                               x = case f3 (ipv2 `cast` <Co:20>) (ipv `cast` <Co:21>) of dt8
                                   { __DEFAULT ->
                                   Linear dt8
                                   } } in
                             join {
                               $j :: Seq (Segment v n) -> Line v n
                               $j (dt8 :: Seq (Segment v n))
                                 = case ^+^
                                          $dAdditive
                                          $dNum
                                          o
                                          (case x of {
                                             Linear v1 -> v1;
                                             Cubic ds1 ds2 v1 -> v1
                                           })
                                   of dt9
                                   { __DEFAULT ->
                                   Line dt8 dt9
                                   } } in
                             case ss `cast` <Co:32> of {
                               EmptyT -> jump $j ((Single (x `cast` <Co:31>)) `cast` <Co:200>);
                               Single b ->
                                 jump $j
                                   ((Deep 2# (One (x `cast` <Co:31>)) EmptyT (One b))
                                    `cast` <Co:200>);
                               Deep dt8 ds1 m sf ->
                                 case ds1 of {
                                   One b ->
                                     jump $j
                                       ((Deep (+# 1# dt8) (Two (x `cast` <Co:31>) b) m sf)
                                        `cast` <Co:200>);
                                   Two b c ->
                                     jump $j
                                       ((Deep (+# 1# dt8) (Three (x `cast` <Co:31>) b c) m sf)
                                        `cast` <Co:200>);
                                   Three b c d ->
                                     jump $j
                                       ((Deep (+# 1# dt8) (Four (x `cast` <Co:31>) b c d) m sf)
                                        `cast` <Co:200>);
                                   Four b c d e ->
                                     case m of m1 { __DEFAULT ->
                                     jump $j
                                       ((Deep
                                           (+# 1# dt8)
                                           (Two (x `cast` <Co:31>) b)
                                           ($b:<|_$s$sconsTree m1 3# c d e)
                                           sf)
                                        `cast` <Co:200>)
                                     }
                                 }
                             }
                             }
                         }
                     }; } in
             case $sgo2 ps (nt `cast` <Co:4>) ps of dt8 { Line ipv ipv1 ->
             (Loc (nt `cast` <Co:10>) (OpenTrail dt8)) `cast` <Co:6>
             }
             }
             }
             }
             }
             })
      }
      }
      }

-- RHS size: {terms: 12, types: 22, coercions: 0, joins: 0/0}
fromVertices
  :: forall (v :: * -> *) n t.
     (InSpace v n t, Metric v, OrderedField n, FromTrail t) =>
     [Point v n] -> t
fromVertices
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      (w :: InSpace v n t)
      _
      _
      (w3 :: FromTrail t)
      (w4 :: [Point v n]) ->
      $wfromVertices w w3 w4

-- RHS size: {terms: 25, types: 85, coercions: 11, joins: 0/0}
$w~~
  :: forall (v :: * -> *) n t.
     (InSpace v n t, FromTrail t) =>
     Point v n -> Point v n -> t
$w~~
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      (w :: InSpace v n t)
      (w1 :: FromTrail t)
      (w2 :: Point v n)
      (w3 :: Point v n) ->
      case HEq_sc (($p2(%,,,%) w) `cast` <Co:5>) of cobox { __DEFAULT ->
      case HEq_sc (($p1(%,,,%) w) `cast` <Co:6>) of cobox1 { __DEFAULT ->
      $wfromVertices w w1 (: w2 (: w3 []))
      }
      }

-- RHS size: {terms: 14, types: 24, coercions: 0, joins: 0/0}
~~
  :: forall (v :: * -> *) n t.
     (InSpace v n t, Metric v, OrderedField n, FromTrail t) =>
     Point v n -> Point v n -> t
~~
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      (w :: InSpace v n t)
      _
      _
      (w3 :: FromTrail t)
      (w4 :: Point v n)
      (w5 :: Point v n) ->
      $w~~ w w3 w4 w5

-- RHS size: {terms: 233, types: 389, coercions: 1,196, joins: 1/2}
$w$creversing1
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Seq (Segment v n)
     -> v n -> ClosingSegment v n -> (# Line v n, ClosingSegment v n #)
$w$creversing1
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (ww
         :: Seq (Segment v n)
         Unf=OtherCon [])
      (ww1
         :: v n
         Unf=OtherCon [])
      (ww2
         :: ClosingSegment v n
         Unf=OtherCon []) ->
      join {
        $j
          :: Seq (Segment v n) -> v n -> (# Line v n, ClosingSegment v n #)
        $j (ww3
              :: Seq (Segment v n)
              Unf=OtherCon [])
           (ww4
              :: v n
              Unf=OtherCon [])
          = case $w$creversing w w1 ww3 ww4 of { (# ww6, ww7 #) ->
            case $m:|>_$sviewRTree (ww6 `cast` <Co:4>) of {
              SnocRTree xs' ds1 ->
                case ^-^
                       w
                       w1
                       ww7
                       (case ds1 `cast` <Co:4> of {
                          Linear v1 -> v1;
                          Cubic ds2 ds3 v1 -> v1
                        })
                of dt7
                { __DEFAULT ->
                case ds1 `cast` <Co:4> of {
                  Linear ds -> (# Line (xs' `cast` <Co:5>) dt7, LinearClosing #);
                  Cubic c1 c2 ds ->
                    (# Line (xs' `cast` <Co:5>) dt7, CubicClosing c1 c2 #)
                }
                };
              EmptyRTree ->
                case zero w w1 of dt7 { __DEFAULT ->
                (# Line (EmptyT `cast` <Co:5>) dt7, LinearClosing #)
                }
            }
            } } in
      case ww `cast` <Co:4> of wild {
        __DEFAULT ->
          let {
            y :: Segment v n
            y = case ww2 of {
                  LinearClosing ->
                    case fmap ($p1Additive w) (negate w1) ww1 of dt7 { __DEFAULT ->
                    Linear dt7
                    };
                  CubicClosing c1 c2 ->
                    case fmap ($p1Additive w) (negate w1) ww1 of dt7 { __DEFAULT ->
                    Cubic c1 c2 dt7
                    }
                } } in
          case wild of {
            Single a2 ->
              case ^+^
                     w
                     w1
                     ww1
                     (case y of {
                        Linear v1 -> v1;
                        Cubic ds1 ds2 v1 -> v1
                      })
              of dt7
              { __DEFAULT ->
              jump $j
                ((Deep 2# (One a2) EmptyT (One (y `cast` <Co:32>)))
                 `cast` <Co:200>)
                dt7
              };
            Deep dt7 pr m ds1 ->
              case ds1 of {
                One a2 ->
                  case ^+^
                         w
                         w1
                         ww1
                         (case y of {
                            Linear v1 -> v1;
                            Cubic ds2 ds3 v1 -> v1
                          })
                  of dt8
                  { __DEFAULT ->
                  jump $j
                    ((Deep (+# dt7 1#) pr m (Two a2 (y `cast` <Co:32>)))
                     `cast` <Co:200>)
                    dt8
                  };
                Two a2 b ->
                  case ^+^
                         w
                         w1
                         ww1
                         (case y of {
                            Linear v1 -> v1;
                            Cubic ds2 ds3 v1 -> v1
                          })
                  of dt8
                  { __DEFAULT ->
                  jump $j
                    ((Deep (+# dt7 1#) pr m (Three a2 b (y `cast` <Co:32>)))
                     `cast` <Co:200>)
                    dt8
                  };
                Three a2 b c ->
                  case ^+^
                         w
                         w1
                         ww1
                         (case y of {
                            Linear v1 -> v1;
                            Cubic ds2 ds3 v1 -> v1
                          })
                  of dt8
                  { __DEFAULT ->
                  jump $j
                    ((Deep (+# dt7 1#) pr m (Four a2 b c (y `cast` <Co:32>)))
                     `cast` <Co:200>)
                    dt8
                  };
                Four a2 b c d ->
                  case m of m1 { __DEFAULT ->
                  case ^+^
                         w
                         w1
                         ww1
                         (case y of {
                            Linear v1 -> v1;
                            Cubic ds2 ds3 v1 -> v1
                          })
                  of dt8
                  { __DEFAULT ->
                  jump $j
                    ((Deep
                        (+# dt7 1#)
                        pr
                        ($b:|>_$s$ssnocTree 3# a2 b c m1)
                        (Two d (y `cast` <Co:32>)))
                     `cast` <Co:200>)
                    dt8
                  }
                  }
              }
          };
        EmptyT ->
          case zero w w1 of dt7 { __DEFAULT ->
          jump $j (EmptyT `cast` <Co:5>) dt7
          }
      }

-- RHS size: {terms: 22, types: 50, coercions: 0, joins: 0/0}
$fReversingLoop_$creversing
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Loop v n -> Loop v n
$fReversingLoop_$creversing
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (w2 :: Loop v n) ->
      case w2 of { Loop ww1 ww2 ->
      case ww1 of { Line ww4 ww5 ->
      case $w$creversing1 w w1 ww4 ww5 ww2 of { (# ww7, ww8 #) ->
      Loop ww7 ww8
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
$fReversingLoop
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Reversing (Loop v n)
$fReversingLoop = $fReversingLoop_$creversing `cast` <Co:19>

-- RHS size: {terms: 41, types: 91, coercions: 0, joins: 0/0}
$fReversingTrail_$creversing
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Trail v n -> Trail v n
$fReversingTrail_$creversing
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (ds :: Trail v n) ->
      case ds of {
        OpenTrail line ->
          case line of { Line ww1 ww2 ->
          case $w$creversing $dAdditive $dNum ww1 ww2 of { (# ww4, ww5 #) ->
          OpenTrail (Line ww4 ww5)
          }
          };
        ClosedTrail loop ->
          case loop of { Loop ww1 ww2 ->
          case ww1 of { Line ww4 ww5 ->
          case $w$creversing1 $dAdditive $dNum ww4 ww5 ww2 of
          { (# ww7, ww8 #) ->
          ClosedTrail (Loop ww7 ww8)
          }
          }
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
$fReversingTrail
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Reversing (Trail v n)
$fReversingTrail = $fReversingTrail_$creversing `cast` <Co:19>

Rec {
-- RHS size: {terms: 18, types: 13, coercions: 0, joins: 0/0}
$wunsafeDrop2 :: forall a1. Int# -> [a1] -> [a1]
$wunsafeDrop2
  = \ (@ a1) (ww :: Int#) (w :: [a1]) ->
      case w of {
        [] -> [];
        : ipv1 ipv2 ->
          case ww of ds3 {
            __DEFAULT -> $wunsafeDrop2 (-# ds3 1#) ipv2;
            1# -> ipv2
          }
      }
end Rec }

-- RHS size: {terms: 7, types: 34, coercions: 100, joins: 0/0}
lvl43 :: forall (v :: * -> *) n. [Segment v n]
lvl43
  = \ (@ (v :: * -> *)) (@ n) ->
      (($fEq1Seq_$cfoldr
          (trailPoints1 `cast` <Co:64>) (id `cast` <Co:19>) EmptyT)
       `cast` <Co:17>)
        []

-- RHS size: {terms: 260,
              types: 409,
              coercions: 1,292,
              joins: 2/10}
$wloopVertices'
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     n
     -> Point (V (Loop v n)) (N (Loop v n))
     -> Seq (Segment v n)
     -> v n
     -> ClosingSegment v n
     -> [Point v n]
$wloopVertices'
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Metric v)
      (w1 :: OrderedField n)
      (w2 :: n)
      (ww
         :: Point (V (Loop v n)) (N (Loop v n))
         Unf=OtherCon [])
      (ww1
         :: Seq (Segment v n)
         Unf=OtherCon [])
      (ww2
         :: v n
         Unf=OtherCon [])
      (ww3
         :: ClosingSegment v n
         Unf=OtherCon []) ->
      let {
        $dFloating :: Floating n
        $dFloating = $p1(%,%) w1 } in
      let {
        $dFractional :: Fractional n
        $dFractional = $p1Floating $dFloating } in
      let {
        $dNum :: Num n
        $dNum = $p1Fractional $dFractional } in
      let {
        $dAdditive :: Additive v
        $dAdditive = $p1Metric w } in
      let {
        lvl77 :: Functor v
        lvl77 = $p1Additive $dAdditive } in
      let {
        segs :: [Segment v n]
        segs
          = case ww1 `cast` <Co:4> of wild {
              __DEFAULT ->
                let {
                  y :: Segment v n
                  y = case ww3 of {
                        LinearClosing ->
                          case fmap lvl77 (negate $dNum) ww2 of dt7 { __DEFAULT ->
                          Linear dt7
                          };
                        CubicClosing c1 c2 ->
                          case fmap lvl77 (negate $dNum) ww2 of dt7 { __DEFAULT ->
                          Cubic c1 c2 dt7
                          }
                      } } in
                join {
                  $j :: Seq (Segment v n) -> [Segment v n]
                  $j (dt7 :: Seq (Segment v n))
                    = case ^+^
                             $dAdditive
                             $dNum
                             ww2
                             (case y of {
                                Linear v1 -> v1;
                                Cubic ds1 ds2 v1 -> v1
                              })
                      of
                      { __DEFAULT ->
                      (($fEq1Seq_$cfoldr
                          (trailPoints1 `cast` <Co:64>)
                          (id `cast` <Co:19>)
                          (dt7 `cast` <Co:4>))
                       `cast` <Co:17>)
                        []
                      } } in
                case wild of {
                  Single a2 ->
                    jump $j
                      ((Deep 2# (One a2) EmptyT (One (y `cast` <Co:32>)))
                       `cast` <Co:200>);
                  Deep dt7 pr m ds1 ->
                    case ds1 of {
                      One a2 ->
                        jump $j
                          ((Deep (+# dt7 1#) pr m (Two a2 (y `cast` <Co:32>)))
                           `cast` <Co:200>);
                      Two a2 b ->
                        jump $j
                          ((Deep (+# dt7 1#) pr m (Three a2 b (y `cast` <Co:32>)))
                           `cast` <Co:200>);
                      Three a2 b c ->
                        jump $j
                          ((Deep (+# dt7 1#) pr m (Four a2 b c (y `cast` <Co:32>)))
                           `cast` <Co:200>);
                      Four a2 b c d ->
                        case m of m1 { __DEFAULT ->
                        jump $j
                          ((Deep
                              (+# dt7 1#)
                              pr
                              ($b:|>_$s$ssnocTree 3# a2 b c m1)
                              (Two d (y `cast` <Co:32>)))
                           `cast` <Co:200>)
                        }
                    }
                };
              EmptyT -> case zero $dAdditive $dNum of { __DEFAULT -> lvl43 }
            } } in
      case $wlenAcc segs 0# of ww4 { __DEFAULT ->
      case tagToEnum# (># ww4 1#) of {
        False -> segmentVertices' w w1 w2 (ww `cast` <Co:8>) segs;
        True ->
          case > ($p2(%,%) w1)
                 (quadrance
                    w
                    $dNum
                    (let {
                       lvl78 :: n -> n
                       lvl78 = * $dNum (fromInteger $dNum lvl20) } in
                     ^-^
                       $dAdditive
                       $dNum
                       (signorm
                          w
                          $dFloating
                          (case segs of {
                             [] -> case badHead of wild2 { };
                             : x ds1 ->
                               case x of {
                                 Linear v1 -> v1;
                                 Cubic c1 ds2 ds3 -> fmap lvl77 lvl78 c1
                               }
                           }))
                       (signorm
                          w
                          $dFloating
                          (joinrec {
                             go1 :: [Segment v n] -> Segment v n -> v n
                             go1 (ds :: [Segment v n]) (eta :: Segment v n)
                               = case ds of {
                                   [] ->
                                     case eta of {
                                       Linear v1 -> v1;
                                       Cubic ds1 c2 c3 ->
                                         fmap lvl77 lvl78 (^-^ $dAdditive $dNum c3 c2)
                                     };
                                   : y ys -> jump go1 ys y
                                 }; } in
                           jump go1 segs lastError))))
                 w2
          of {
            False ->
              case $wunsafeDrop2
                     1# (segmentVertices' w w1 w2 (ww `cast` <Co:8>) segs)
              of {
                [] -> init2;
                : x xs -> init1 x xs
              };
            True ->
              case segmentVertices' w w1 w2 (ww `cast` <Co:8>) segs of {
                [] -> init2;
                : x xs -> init1 x xs
              }
          }
      }
      }

-- RHS size: {terms: 23, types: 51, coercions: 0, joins: 0/0}
loopVertices'
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     n -> Located (Loop v n) -> [Point v n]
loopVertices'
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Metric v)
      (w1 :: OrderedField n)
      (w2 :: n)
      (w3 :: Located (Loop v n)) ->
      case w3 of { Loc ww1 ww2 ->
      case ww2 of { Loop ww4 ww5 ->
      case ww4 of { Line ww7 ww8 ->
      $wloopVertices' w w1 w2 ww1 ww7 ww8 ww5
      }
      }
      }

-- RHS size: {terms: 28, types: 57, coercions: 0, joins: 0/1}
loopVertices
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Located (Loop v n) -> [Point v n]
loopVertices
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n) ->
      let {
        w :: n
        w = fromRational
              ($p1Floating ($p1(%,%) $d(%,%))) lineVertices1 } in
      \ (w1 :: Located (Loop v n)) ->
        case w1 of { Loc ww1 ww2 ->
        case ww2 of { Loop ww4 ww5 ->
        case ww4 of { Line ww7 ww8 ->
        $wloopVertices' $dMetric $d(%,%) w ww1 ww7 ww8 ww5
        }
        }
        }

-- RHS size: {terms: 40, types: 95, coercions: 131, joins: 0/0}
trailVertices'
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     n -> Located (Trail v n) -> [Point v n]
trailVertices'
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Metric v)
      (w1 :: OrderedField n)
      (w2 :: n)
      (w3 :: Located (Trail v n)) ->
      case w3 of { Loc ww1 ww2 ->
      case ww2 of {
        OpenTrail line ->
          case line of { Line s o ->
          segmentVertices'
            w
            w1
            w2
            (ww1 `cast` <Co:8>)
            ((($fEq1Seq_$cfoldr
                 (trailPoints1 `cast` <Co:64>)
                 (id `cast` <Co:19>)
                 (s `cast` <Co:4>))
              `cast` <Co:17>)
               [])
          };
        ClosedTrail loop ->
          case loop of { Loop ww4 ww5 ->
          case ww4 of { Line ww7 ww8 ->
          $wloopVertices' w w1 w2 (ww1 `cast` <Co:19>) ww7 ww8 ww5
          }
          }
      }
      }

-- RHS size: {terms: 45, types: 101, coercions: 131, joins: 0/1}
trailVertices
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Located (Trail v n) -> [Point v n]
trailVertices
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n) ->
      let {
        w :: n
        w = fromRational
              ($p1Floating ($p1(%,%) $d(%,%))) lineVertices1 } in
      \ (w1 :: Located (Trail v n)) ->
        case w1 of { Loc ww1 ww2 ->
        case ww2 of {
          OpenTrail line ->
            case line of { Line s o ->
            segmentVertices'
              $dMetric
              $d(%,%)
              w
              (ww1 `cast` <Co:8>)
              ((($fEq1Seq_$cfoldr
                   (trailPoints1 `cast` <Co:64>)
                   (id `cast` <Co:19>)
                   (s `cast` <Co:4>))
                `cast` <Co:17>)
                 [])
            };
          ClosedTrail loop ->
            case loop of { Loop ww4 ww5 ->
            case ww4 of { Line ww7 ww8 ->
            $wloopVertices' $dMetric $d(%,%) w (ww1 `cast` <Co:19>) ww7 ww8 ww5
            }
            }
        }
        }

-- RHS size: {terms: 35, types: 54, coercions: 0, joins: 0/0}
loopClosingSegment
  :: forall (v :: * -> *) n.
     (Functor v, Num n) =>
     Loop v n -> Segment v n
loopClosingSegment
  = \ (@ (v :: * -> *))
      (@ n)
      ($dFunctor :: Functor v)
      ($dNum :: Num n)
      (eta :: Loop v n) ->
      case eta of { Loop t c ->
      case t of { Line ds o ->
      case c of {
        LinearClosing ->
          case fmap $dFunctor (negate $dNum) o of dt7 { __DEFAULT ->
          Linear dt7
          };
        CubicClosing c1 c2 ->
          case fmap $dFunctor (negate $dNum) o of dt7 { __DEFAULT ->
          Cubic c1 c2 dt7
          }
      }
      }
      }

-- RHS size: {terms: 42, types: 58, coercions: 18, joins: 0/0}
$fTangentEndValuesLoop_$ctangentAtEnd
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Loop v n -> Vn (Loop v n)
$fTangentEndValuesLoop_$ctangentAtEnd
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (eta :: Loop v n) ->
      case eta of { Loop line c ->
      case line of { Line ds o ->
      case c of {
        LinearClosing ->
          (fmap ($p1Additive $dAdditive) (negate $dNum) o) `cast` <Co:9>;
        CubicClosing c1 c2 ->
          case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
          { __DEFAULT ->
          (fmap
             ($p1Additive $dAdditive)
             (* $dNum (fromInteger $dNum lvl20))
             (^-^ $dAdditive $dNum dt7 c2))
          `cast` <Co:9>
          }
      }
      }
      }

-- RHS size: {terms: 11, types: 17, coercions: 0, joins: 0/0}
$fTangentEndValuesLoop
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     TangentEndValues (Loop v n)
$fTangentEndValuesLoop
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      C:TangentEndValues
        ($fTangentEndValuesLoop_$ctangentAtStart $dAdditive $dNum)
        ($fTangentEndValuesLoop_$ctangentAtEnd $dAdditive $dNum)

-- RHS size: {terms: 87, types: 166, coercions: 173, joins: 0/0}
$fHasSegmentsLoop_$csegments
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Fold (Loop v n) (Segment (V (Loop v n)) (N (Loop v n)))
$fHasSegmentsLoop_$csegments
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (@ (f3 :: * -> *))
      (eta :: Contravariant f3)
      (eta1 :: Applicative f3)
      (eta2
         :: Segment (V (Loop v n)) (N (Loop v n))
            -> f3 (Segment (V (Loop v n)) (N (Loop v n))))
      (eta3 :: Loop v n) ->
      case eta3 of { Loop t c ->
      case t of { Line s o ->
      *>
        eta1
        (fmap
           ($p1Applicative eta1)
           (\ (s' :: Seq (Segment v n)) ->
              case s' `cast` <Co:4> of nt { __DEFAULT ->
              Line (nt `cast` <Co:5>) o
              })
           (>$
              eta
              ()
              (<$
                 ($p1Applicative eta1)
                 ()
                 ($fEq1Seq_$cfoldr
                    ((\ (a1 :: Segment v n) (fa :: f3 (Segment v n)) ->
                        *> eta1 ((eta2 (a1 `cast` <Co:61>)) `cast` <Co:57>) fa)
                     `cast` <Co:14>)
                    (>$ eta () (<$ ($p1Applicative eta1) () (pure eta1 ())))
                    (s `cast` <Co:4>)))))
        (>$
           eta
           ()
           (<$
              ($p1Applicative eta1)
              ()
              ((eta2
                  (case c of {
                     LinearClosing ->
                       case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
                       { __DEFAULT ->
                       (Linear dt7) `cast` <Co:10>
                       };
                     CubicClosing c1 c2 ->
                       case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
                       { __DEFAULT ->
                       (Cubic c1 c2 dt7) `cast` <Co:10>
                       }
                   }))
               `cast` <Co:8>)))
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl44 :: Int
lvl44 = I# 2#

-- RHS size: {terms: 22, types: 57, coercions: 4, joins: 0/0}
$fHasSegmentsLoop_$cnumSegments
  :: forall (v :: * -> *) n. (Additive v, Num n) => Loop v n -> Int
$fHasSegmentsLoop_$cnumSegments
  = \ (@ (v :: * -> *)) (@ n) _ _ (eta :: Loop v n) ->
      case eta of { Loop l ds ->
      case l of { Line ss ds1 ->
      case ss `cast` <Co:4> of {
        EmptyT -> lvl9;
        Single x -> lvl44;
        Deep dt7 ds2 ds3 ds4 -> I# (+# dt7 1#)
      }
      }
      }

-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
$fHasSegmentsLoop
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     HasSegments (Loop v n)
$fHasSegmentsLoop
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      C:HasSegments
        ($fHasSegmentsLoop_$csegments $dAdditive $dNum)
        ($fHasSegmentsLoop_$coffset $dAdditive $dNum)
        ($fHasSegmentsLoop_$cnumSegments $dAdditive $dNum)

-- RHS size: {terms: 144, types: 271, coercions: 286, joins: 0/0}
$fHasSegmentsTrail_$csegments
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Fold (Trail v n) (Segment (V (Trail v n)) (N (Trail v n)))
$fHasSegmentsTrail_$csegments
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (@ (f3 :: * -> *))
      (eta :: Contravariant f3)
      (eta1 :: Applicative f3)
      (eta2
         :: Segment (V (Trail v n)) (N (Trail v n))
            -> f3 (Segment (V (Trail v n)) (N (Trail v n))))
      (eta3 :: Trail v n) ->
      case eta3 of {
        OpenTrail t ->
          case t of { Line s o ->
          >$
            eta
            ()
            (<$
               ($p1Applicative eta1)
               ()
               (fmap
                  ($p1Applicative eta1)
                  (\ (s' :: Seq (Segment v n)) ->
                     case s' `cast` <Co:4> of nt { __DEFAULT ->
                     Line (nt `cast` <Co:5>) o
                     })
                  (>$
                     eta
                     ()
                     (<$
                        ($p1Applicative eta1)
                        ()
                        ($fEq1Seq_$cfoldr
                           ((\ (a1 :: Segment v n) (fa :: f3 (Segment v n)) ->
                               *> eta1 ((eta2 (a1 `cast` <Co:61>)) `cast` <Co:57>) fa)
                            `cast` <Co:14>)
                           (>$ eta () (<$ ($p1Applicative eta1) () (pure eta1 ())))
                           (s `cast` <Co:4>))))))
          };
        ClosedTrail t ->
          case t of { Loop t1 c ->
          case t1 of { Line s o ->
          >$
            eta
            ()
            (<$
               ($p1Applicative eta1)
               ()
               (*>
                  eta1
                  (fmap
                     ($p1Applicative eta1)
                     (\ (s' :: Seq (Segment v n)) ->
                        case s' `cast` <Co:4> of nt { __DEFAULT ->
                        Line (nt `cast` <Co:5>) o
                        })
                     (>$
                        eta
                        ()
                        (<$
                           ($p1Applicative eta1)
                           ()
                           ($fEq1Seq_$cfoldr
                              ((\ (a1 :: Segment v n) (fa :: f3 (Segment v n)) ->
                                  *> eta1 ((eta2 (a1 `cast` <Co:10>)) `cast` <Co:76>) fa)
                               `cast` <Co:14>)
                              (>$ eta () (<$ ($p1Applicative eta1) () (pure eta1 ())))
                              (s `cast` <Co:4>)))))
                  (>$
                     eta
                     ()
                     (<$
                        ($p1Applicative eta1)
                        ()
                        ((eta2
                            (case c of {
                               LinearClosing ->
                                 case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
                                 { __DEFAULT ->
                                 (Linear dt7) `cast` <Co:10>
                                 };
                               CubicClosing c1 c2 ->
                                 case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
                                 { __DEFAULT ->
                                 (Cubic c1 c2 dt7) `cast` <Co:10>
                                 }
                             }))
                         `cast` <Co:8>)))))
          }
          }
      }

-- RHS size: {terms: 16, types: 33, coercions: 18, joins: 0/0}
$fHasSegmentsTrail_$coffset
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     Trail v n -> Vn (Trail v n)
$fHasSegmentsTrail_$coffset
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n)
      (eta :: Trail v n) ->
      case eta of {
        OpenTrail t -> case t of { Line ds o -> o `cast` <Co:9> };
        ClosedTrail t -> (zero $dAdditive $dNum) `cast` <Co:9>
      }

-- RHS size: {terms: 38, types: 101, coercions: 8, joins: 0/0}
$fHasSegmentsTrail_$cnumSegments
  :: forall (v :: * -> *) n. (Additive v, Num n) => Trail v n -> Int
$fHasSegmentsTrail_$cnumSegments
  = \ (@ (v :: * -> *)) (@ n) _ _ (eta :: Trail v n) ->
      case eta of {
        OpenTrail t ->
          case t of { Line ss ds ->
          case ss `cast` <Co:4> of {
            EmptyT -> $fApplicativeSeq2;
            Single x -> $fApplicativeSeq1;
            Deep dt7 ds1 ds2 ds3 -> I# dt7
          }
          };
        ClosedTrail t ->
          case t of { Loop l ds ->
          case l of { Line ss ds1 ->
          case ss `cast` <Co:4> of {
            EmptyT -> lvl9;
            Single x -> lvl44;
            Deep dt7 ds2 ds3 ds4 -> I# (+# dt7 1#)
          }
          }
          }
      }

-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
$fHasSegmentsTrail
  :: forall (v :: * -> *) n.
     (Additive v, Num n) =>
     HasSegments (Trail v n)
$fHasSegmentsTrail
  = \ (@ (v :: * -> *))
      (@ n)
      ($dAdditive :: Additive v)
      ($dNum :: Num n) ->
      C:HasSegments
        ($fHasSegmentsTrail_$csegments $dAdditive $dNum)
        ($fHasSegmentsTrail_$coffset $dAdditive $dNum)
        ($fHasSegmentsTrail_$cnumSegments $dAdditive $dNum)

-- RHS size: {terms: 254, types: 637, coercions: 1,555, joins: 1/9}
$wfixTrail
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Point (V (Trail v n)) (N (Trail v n))
     -> Trail v n -> [FixedSegment v n]
$wfixTrail
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Metric v)
      (w1 :: OrderedField n)
      (ww
         :: Point (V (Trail v n)) (N (Trail v n))
         Unf=OtherCon [])
      (ww1
         :: Trail v n
         Unf=OtherCon []) ->
      let {
        $dFloating :: Floating n
        $dFloating = $p1(%,%) w1 } in
      let {
        $dFractional :: Fractional n
        $dFractional = $p1Floating $dFloating } in
      let {
        $dNum :: Num n
        $dNum = $p1Fractional $dFractional } in
      let {
        $dAdditive :: Additive v
        $dAdditive = $p1Metric w } in
      join {
        $w$j :: [Located (Segment v n)] -> [FixedSegment v n]
        $w$j (w2 :: [Located (Segment v n)])
          = map
              (($fProfunctorTagged_$cdimap
                  (\ (ds :: FixedSegment v n) ->
                     case ds of {
                       FLinear p1 p2 ->
                         case ^-^ $dAdditive $dNum (p2 `cast` <Co:33>) (p1 `cast` <Co:34>)
                         of dt7
                         { __DEFAULT ->
                         Loc (p1 `cast` <Co:10>) (Linear dt7)
                         };
                       FCubic x1 c1 c2 x2 ->
                         case ^-^ $dAdditive $dNum (c1 `cast` <Co:33>) (x1 `cast` <Co:34>)
                         of dt7
                         { __DEFAULT ->
                         case ^-^ $dAdditive $dNum (c2 `cast` <Co:33>) (x1 `cast` <Co:34>)
                         of dt8
                         { __DEFAULT ->
                         case ^-^ $dAdditive $dNum (x2 `cast` <Co:33>) (x1 `cast` <Co:34>)
                         of dt9
                         { __DEFAULT ->
                         Loc (x1 `cast` <Co:10>) (Cubic dt7 dt8 dt9)
                         }
                         }
                         }
                     })
                  ((\ (ds :: Located (Segment v n)) ->
                      case ds of { Loc p1 ds1 ->
                      case ds1 of {
                        Linear v1 ->
                          case ^+^ $dAdditive $dNum (p1 `cast` <Co:42>) v1 of nt
                          { __DEFAULT ->
                          FLinear (p1 `cast` <Co:8>) (nt `cast` <Co:4>)
                          };
                        Cubic c1 c2 x2 ->
                          case ^+^ $dAdditive $dNum (p1 `cast` <Co:42>) c1 of nt
                          { __DEFAULT ->
                          case ^+^ $dAdditive $dNum (p1 `cast` <Co:42>) c2 of nt1
                          { __DEFAULT ->
                          case ^+^ $dAdditive $dNum (p1 `cast` <Co:42>) x2 of nt2
                          { __DEFAULT ->
                          FCubic
                            (p1 `cast` <Co:8>)
                            (nt `cast` <Co:4>)
                            (nt1 `cast` <Co:4>)
                            (nt2 `cast` <Co:4>)
                          }
                          }
                          }
                      }
                      })
                   `cast` <Co:12>))
               `cast` <Co:85>)
              w2 } in
      case ww1 of {
        OpenTrail t ->
          case t of { Line s o ->
          letrec {
            $wgo
              :: [Segment v n]
                 -> Point v n -> (# Point v n, [Located (Segment v n)] #)
            $wgo
              = \ (w2 :: [Segment v n]) (w3 :: Point v n) ->
                  case w2 of {
                    [] -> (# w3, [] #);
                    : y ys ->
                      let {
                        ds1 :: (Point v n, [Located (Segment v n)])
                        ds1
                          = case $wgo
                                   ys
                                   ((^+^
                                       ($dAdditive `cast` <Co:5>)
                                       ($dNum `cast` <Co:5>)
                                       (w3 `cast` <Co:147>)
                                       (case y of {
                                          Linear v1 -> v1 `cast` <Co:9>;
                                          Cubic ds2 ds3 v1 -> v1 `cast` <Co:9>
                                        }))
                                    `cast` <Co:139>)
                            of
                            { (# ww3, ww4 #) ->
                            (ww3, ww4)
                            } } in
                      (# case ds1 of { (s'', y1) -> s'' },
                         : ($WLoc (w3 `cast` <Co:59>) y)
                           (case ds1 of { (s'', y1) -> y1 }) #)
                  }; } in
          case $wgo
                 ((($fEq1Seq_$cfoldr
                      (trailPoints1 `cast` <Co:64>)
                      (id `cast` <Co:19>)
                      (s `cast` <Co:4>))
                   `cast` <Co:17>)
                    [])
                 (ww `cast` <Co:8>)
          of
          { (# ww3, ww4 #) ->
          jump $w$j ww4
          }
          };
        ClosedTrail t ->
          case t of { Loop t1 c ->
          case t1 of { Line s o ->
          letrec {
            $wgo
              :: [Segment v n]
                 -> Point v n -> (# Point v n, [Located (Segment v n)] #)
            $wgo
              = \ (w2 :: [Segment v n]) (w3 :: Point v n) ->
                  case w2 of {
                    [] -> (# w3, [] #);
                    : y ys ->
                      let {
                        ds1 :: (Point v n, [Located (Segment v n)])
                        ds1
                          = case $wgo
                                   ys
                                   ((^+^
                                       ($dAdditive `cast` <Co:5>)
                                       ($dNum `cast` <Co:5>)
                                       (w3 `cast` <Co:147>)
                                       (case y of {
                                          Linear v1 -> v1 `cast` <Co:9>;
                                          Cubic ds2 ds3 v1 -> v1 `cast` <Co:9>
                                        }))
                                    `cast` <Co:139>)
                            of
                            { (# ww3, ww4 #) ->
                            (ww3, ww4)
                            } } in
                      (# case ds1 of { (s'', y1) -> s'' },
                         : ($WLoc (w3 `cast` <Co:59>) y)
                           (case ds1 of { (s'', y1) -> y1 }) #)
                  }; } in
          case $wgo
                 ((($fEq1Seq_$cfoldr
                      (trailPoints1 `cast` <Co:64>)
                      (id `cast` <Co:19>)
                      (s `cast` <Co:4>))
                   `cast` <Co:17>)
                    (: (case c of {
                          LinearClosing ->
                            case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
                            { __DEFAULT ->
                            Linear dt7
                            };
                          CubicClosing c1 c2 ->
                            case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
                            { __DEFAULT ->
                            Cubic c1 c2 dt7
                            }
                        })
                       []))
                 (ww `cast` <Co:8>)
          of
          { (# ww3, ww4 #) ->
          jump $w$j ww4
          }
          }
          }
      }

-- RHS size: {terms: 13, types: 32, coercions: 0, joins: 0/0}
fixTrail
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Located (Trail v n) -> [FixedSegment v n]
fixTrail
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Metric v)
      (w1 :: OrderedField n)
      (w2 :: Located (Trail v n)) ->
      case w2 of { Loc ww1 ww2 -> $wfixTrail w w1 ww1 ww2 }

-- RHS size: {terms: 290, types: 724, coercions: 9,100, joins: 2/6}
$wexplodeTrail
  :: forall (v :: * -> *) n t.
     (InSpace v n t, Metric v, OrderedField n, FromTrail t) =>
     Point (V (Trail v n)) (N (Trail v n)) -> Trail v n -> [t]
$wexplodeTrail
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      (w :: InSpace v n t)
      (w1 :: Metric v)
      (w2 :: OrderedField n)
      (w3 :: FromTrail t)
      (ww
         :: Point (V (Trail v n)) (N (Trail v n))
         Unf=OtherCon [])
      (ww1
         :: Trail v n
         Unf=OtherCon []) ->
      case HEq_sc (($p2(%,,,%) w) `cast` <Co:5>) of cobox { __DEFAULT ->
      case HEq_sc (($p1(%,,,%) w) `cast` <Co:6>) of cobox1 { __DEFAULT ->
      let {
        $dNum :: Num n
        $dNum = $p4(%,,,%) w } in
      let {
        $dAdditive :: Additive v
        $dAdditive = $p3(%,,,%) w } in
      let {
        lvl77 :: V t (N t)
        lvl77 = zero ($dAdditive `cast` <Co:3>) ($dNum `cast` <Co:3>) } in
      let {
        lvl78 :: Line (V t) (N t)
        lvl78
          = case zero ($dAdditive `cast` <Co:3>) ($dNum `cast` <Co:3>) of dt7
            { __DEFAULT ->
            Line (EmptyT `cast` <Co:7>) dt7
            } } in
      map
        (\ (x :: FixedSegment v n) ->
           (w3 `cast` <Co:2>)
             (case x of {
                FLinear p1 p2 ->
                  case ^-^ $dAdditive $dNum (p2 `cast` <Co:33>) (p1 `cast` <Co:34>)
                  of dt7
                  { __DEFAULT ->
                  case lvl77 of { __DEFAULT ->
                  case lvl78 of { Line ss o ->
                  join {
                    $j :: Seq (Segment (V t) (N t)) -> Located (Trail (V t) (N t))
                    $j (dt8 :: Seq (Segment (V t) (N t)))
                      = case ^+^
                               ($dAdditive `cast` <Co:3>)
                               ($dNum `cast` <Co:3>)
                               o
                               (dt7 `cast` <Co:5>)
                        of dt9
                        { __DEFAULT ->
                        Loc (p1 `cast` <Co:37>) (OpenTrail (Line dt8 dt9))
                        } } in
                  case ss `cast` <Co:44> of {
                    EmptyT ->
                      jump $j ((Single ((Linear dt7) `cast` <Co:448>)) `cast` <Co:270>);
                    Single b ->
                      jump $j
                        ((Deep 2# (One ((Linear dt7) `cast` <Co:448>)) EmptyT (One b))
                         `cast` <Co:270>);
                    Deep dt8 ds1 m sf ->
                      case ds1 of {
                        One b ->
                          jump $j
                            ((Deep (+# 1# dt8) (Two ((Linear dt7) `cast` <Co:448>) b) m sf)
                             `cast` <Co:270>);
                        Two b c ->
                          jump $j
                            ((Deep (+# 1# dt8) (Three ((Linear dt7) `cast` <Co:448>) b c) m sf)
                             `cast` <Co:270>);
                        Three b c d ->
                          jump $j
                            ((Deep
                                (+# 1# dt8) (Four ((Linear dt7) `cast` <Co:448>) b c d) m sf)
                             `cast` <Co:270>);
                        Four b c d e ->
                          case m of m1 { __DEFAULT ->
                          jump $j
                            ((Deep
                                (+# 1# dt8)
                                (Two ((Linear dt7) `cast` <Co:448>) b)
                                ($b:<|_$s$sconsTree m1 3# c d e)
                                sf)
                             `cast` <Co:270>)
                          }
                      }
                  }
                  }
                  }
                  };
                FCubic x1 c1 c2 x2 ->
                  case ^-^ $dAdditive $dNum (c1 `cast` <Co:33>) (x1 `cast` <Co:34>)
                  of dt7
                  { __DEFAULT ->
                  case ^-^ $dAdditive $dNum (c2 `cast` <Co:33>) (x1 `cast` <Co:34>)
                  of dt8
                  { __DEFAULT ->
                  case ^-^ $dAdditive $dNum (x2 `cast` <Co:33>) (x1 `cast` <Co:34>)
                  of dt9
                  { __DEFAULT ->
                  case lvl77 of { __DEFAULT ->
                  case lvl78 of { Line ss o ->
                  join {
                    $j :: Seq (Segment (V t) (N t)) -> Located (Trail (V t) (N t))
                    $j (dt10 :: Seq (Segment (V t) (N t)))
                      = case ^+^
                               ($dAdditive `cast` <Co:3>)
                               ($dNum `cast` <Co:3>)
                               o
                               (dt9 `cast` <Co:5>)
                        of dt11
                        { __DEFAULT ->
                        Loc (x1 `cast` <Co:37>) (OpenTrail (Line dt10 dt11))
                        } } in
                  case ss `cast` <Co:44> of {
                    EmptyT ->
                      jump $j
                        ((Single ((Cubic dt7 dt8 dt9) `cast` <Co:448>)) `cast` <Co:270>);
                    Single b ->
                      jump $j
                        ((Deep
                            2# (One ((Cubic dt7 dt8 dt9) `cast` <Co:448>)) EmptyT (One b))
                         `cast` <Co:270>);
                    Deep dt10 ds1 m sf ->
                      case ds1 of {
                        One b ->
                          jump $j
                            ((Deep
                                (+# 1# dt10) (Two ((Cubic dt7 dt8 dt9) `cast` <Co:448>) b) m sf)
                             `cast` <Co:270>);
                        Two b c ->
                          jump $j
                            ((Deep
                                (+# 1# dt10)
                                (Three ((Cubic dt7 dt8 dt9) `cast` <Co:448>) b c)
                                m
                                sf)
                             `cast` <Co:270>);
                        Three b c d ->
                          jump $j
                            ((Deep
                                (+# 1# dt10)
                                (Four ((Cubic dt7 dt8 dt9) `cast` <Co:448>) b c d)
                                m
                                sf)
                             `cast` <Co:270>);
                        Four b c d e ->
                          case m of m1 { __DEFAULT ->
                          jump $j
                            ((Deep
                                (+# 1# dt10)
                                (Two ((Cubic dt7 dt8 dt9) `cast` <Co:448>) b)
                                ($b:<|_$s$sconsTree m1 3# c d e)
                                sf)
                             `cast` <Co:270>)
                          }
                      }
                  }
                  }
                  }
                  }
                  }
                  }
              }))
        ($wfixTrail w1 w2 ww ww1)
      }
      }

-- RHS size: {terms: 18, types: 38, coercions: 0, joins: 0/0}
explodeTrail
  :: forall (v :: * -> *) n t.
     (InSpace v n t, Metric v, OrderedField n, FromTrail t) =>
     Located (Trail v n) -> [t]
explodeTrail
  = \ (@ (v :: * -> *))
      (@ n)
      (@ t)
      (w :: InSpace v n t)
      (w1 :: Metric v)
      (w2 :: OrderedField n)
      (w3 :: FromTrail t)
      (w4 :: Located (Trail v n)) ->
      case w4 of { Loc ww1 ww2 -> $wexplodeTrail w w1 w2 w3 ww1 ww2 }

-- RHS size: {terms: 134, types: 323, coercions: 628, joins: 0/10}
$wtrailLocSegments
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Point (V (Trail v n)) (N (Trail v n))
     -> Trail v n -> [Located (Segment v n)]
$wtrailLocSegments
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Metric v)
      (w1 :: OrderedField n)
      (ww
         :: Point (V (Trail v n)) (N (Trail v n))
         Unf=OtherCon [])
      (ww1
         :: Trail v n
         Unf=OtherCon []) ->
      let {
        $dAdditive :: Additive v
        $dAdditive = $p1Metric w } in
      let {
        $dFloating :: Floating n
        $dFloating = $p1(%,%) w1 } in
      let {
        $dFractional :: Fractional n
        $dFractional = $p1Floating $dFloating } in
      let {
        $dNum :: Num n
        $dNum = $p1Fractional $dFractional } in
      case ww1 of {
        OpenTrail t ->
          case t of { Line s o ->
          zipWith
            (at `cast` <Co:17>)
            ((($fEq1Seq_$cfoldr
                 (trailPoints1 `cast` <Co:64>)
                 (id `cast` <Co:19>)
                 (s `cast` <Co:4>))
              `cast` <Co:17>)
               [])
            (: (ww `cast` <Co:8>)
               (let {
                  f3 :: v n -> v n -> v n
                  f3 = ^+^ $dAdditive $dNum } in
                letrec {
                  go1 :: [Segment v n] -> Point v n -> [Point v n]
                  go1
                    = \ (ds :: [Segment v n]) (eta :: Point v n) ->
                        case ds of {
                          [] -> [];
                          : y ys ->
                            let {
                              b' :: v n
                              b'
                                = f3
                                    (eta `cast` <Co:20>)
                                    (($fHasSegmentsSegment_$coffset y) `cast` <Co:7>) } in
                            : (b' `cast` <Co:23>) (go1 ys (b' `cast` <Co:23>))
                        }; } in
                go1
                  ((($fEq1Seq_$cfoldr
                       (trailPoints1 `cast` <Co:64>)
                       (id `cast` <Co:19>)
                       (s `cast` <Co:4>))
                    `cast` <Co:17>)
                     [])
                  (ww `cast` <Co:8>)))
          };
        ClosedTrail t ->
          case t of { Loop t1 c ->
          case t1 of { Line s o ->
          zipWith
            (at `cast` <Co:17>)
            ((($fEq1Seq_$cfoldr
                 (trailPoints1 `cast` <Co:64>)
                 (id `cast` <Co:19>)
                 (s `cast` <Co:4>))
              `cast` <Co:17>)
               (: (case c of {
                     LinearClosing ->
                       case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
                       { __DEFAULT ->
                       Linear dt7
                       };
                     CubicClosing c1 c2 ->
                       case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
                       { __DEFAULT ->
                       Cubic c1 c2 dt7
                       }
                   })
                  []))
            (: (ww `cast` <Co:8>)
               (let {
                  f3 :: v n -> v n -> v n
                  f3 = ^+^ $dAdditive $dNum } in
                letrec {
                  go1 :: [Segment v n] -> Point v n -> [Point v n]
                  go1
                    = \ (ds :: [Segment v n]) (eta :: Point v n) ->
                        case ds of {
                          [] -> [];
                          : y ys ->
                            let {
                              b' :: v n
                              b'
                                = f3
                                    (eta `cast` <Co:20>)
                                    (($fHasSegmentsSegment_$coffset y) `cast` <Co:7>) } in
                            : (b' `cast` <Co:23>) (go1 ys (b' `cast` <Co:23>))
                        }; } in
                go1
                  ((($fEq1Seq_$cfoldr
                       (trailPoints1 `cast` <Co:64>)
                       (id `cast` <Co:19>)
                       (s `cast` <Co:4>))
                    `cast` <Co:17>)
                     [])
                  (ww `cast` <Co:8>)))
          }
          }
      }

-- RHS size: {terms: 13, types: 32, coercions: 0, joins: 0/0}
trailLocSegments
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Located (Trail v n) -> [Located (Segment v n)]
trailLocSegments
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Metric v)
      (w1 :: OrderedField n)
      (w2 :: Located (Trail v n)) ->
      case w2 of { Loc ww1 ww2 -> $wtrailLocSegments w w1 ww1 ww2 }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
f :: Addr#
f = "loopFromSegments "#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
f1 :: [Char]
f1 = unpackCString# f

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
f2 :: Char
f2 = C# ' '#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lvl45 :: Int
lvl45 = I# 11#

-- RHS size: {terms: 128, types: 148, coercions: 104, joins: 0/10}
$w$cliftShowsPrec1
  :: forall (v :: * -> *).
     Show1 v =>
     forall a.
     (Int -> a -> ShowS)
     -> ([a] -> ShowS)
     -> Int#
     -> Seq (Segment v a)
     -> ClosingSegment v a
     -> ShowS
$w$cliftShowsPrec1
  = \ (@ (v :: * -> *))
      (w :: Show1 v)
      (@ a)
      (w1 :: Int -> a -> ShowS)
      (w2 :: [a] -> ShowS)
      (ww :: Int#)
      (ww1
         :: Seq (Segment v a)
         Unf=OtherCon [])
      (ww2
         :: ClosingSegment v a
         Unf=OtherCon []) ->
      let {
        eta :: [Segment v a]
        eta
          = (($fEq1Seq_$cfoldr
                (trailPoints1 `cast` <Co:64>)
                (id `cast` <Co:19>)
                (ww1 `cast` <Co:4>))
             `cast` <Co:17>)
              [] } in
      let {
        g :: String -> String
        g = $fShow1ClosingSegment_$cliftShowsPrec w w1 w2 lvl45 ww2 } in
      case tagToEnum# (># ww 10#) of {
        False ->
          \ (x :: String) ->
            ++
              f1
              (let {
                 s :: String
                 s = g x } in
               let {
                 s1 :: String
                 s1 = : f2 s } in
               case eta of {
                 [] -> unpackAppendCString# showList__4 s1;
                 : x1 xs ->
                   : showList__3
                     ($w$cliftShowsPrec
                        w
                        w1
                        w2
                        0#
                        x1
                        (let {
                           lvl77 :: [Char]
                           lvl77 = : showList__2 s1 } in
                         letrec {
                           showl :: [Segment v a] -> String
                           showl
                             = \ (ds2 :: [Segment v a]) ->
                                 case ds2 of {
                                   [] -> lvl77;
                                   : y ys ->
                                     : showList__1 ($w$cliftShowsPrec w w1 w2 0# y (showl ys))
                                 }; } in
                         showl xs))
               });
        True ->
          \ (x :: String) ->
            : $fShow(,)4
              (++
                 f1
                 (let {
                    s :: String
                    s = g (: $fShow(,)2 x) } in
                  let {
                    s1 :: String
                    s1 = : f2 s } in
                  case eta of {
                    [] -> unpackAppendCString# showList__4 s1;
                    : x1 xs ->
                      : showList__3
                        ($w$cliftShowsPrec
                           w
                           w1
                           w2
                           0#
                           x1
                           (let {
                              lvl77 :: [Char]
                              lvl77 = : showList__2 s1 } in
                            letrec {
                              showl :: [Segment v a] -> String
                              showl
                                = \ (ds2 :: [Segment v a]) ->
                                    case ds2 of {
                                      [] -> lvl77;
                                      : y ys ->
                                        : showList__1 ($w$cliftShowsPrec w w1 w2 0# y (showl ys))
                                    }; } in
                            showl xs))
                  }))
      }

-- RHS size: {terms: 23, types: 40, coercions: 0, joins: 0/0}
$fShow1Loop_$cliftShowsPrec
  :: forall (v :: * -> *).
     Show1 v =>
     forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> Loop v a -> ShowS
$fShow1Loop_$cliftShowsPrec
  = \ (@ (v :: * -> *))
      (w :: Show1 v)
      (@ a)
      (w1 :: Int -> a -> ShowS)
      (w2 :: [a] -> ShowS)
      (w3 :: Int)
      (w4 :: Loop v a) ->
      case w3 of { I# ww1 ->
      case w4 of { Loop ww3 ww4 ->
      case ww3 of { Line ww6 ww7 ->
      $w$cliftShowsPrec1 w w1 w2 ww1 ww6 ww4
      }
      }
      }

-- RHS size: {terms: 24, types: 45, coercions: 0, joins: 0/0}
$fShow1Loop_$cliftShowList
  :: forall (v :: * -> *).
     Show1 v =>
     forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> [Loop v a] -> ShowS
$fShow1Loop_$cliftShowList
  = \ (@ (v :: * -> *))
      ($dShow1 :: Show1 v)
      (@ a)
      (sp :: Int -> a -> ShowS)
      (sl :: [a] -> ShowS)
      (eta :: [Loop v a])
      (eta1 :: String) ->
      showList__
        (\ (w :: Loop v a) ->
           case w of { Loop ww1 ww2 ->
           case ww1 of { Line ww4 ww5 ->
           $w$cliftShowsPrec1 $dShow1 sp sl 0# ww4 ww2
           }
           })
        eta
        eta1

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
$fShow1Loop :: forall (v :: * -> *). Show1 v => Show1 (Loop v)
$fShow1Loop
  = \ (@ (v :: * -> *)) ($dShow1 :: Show1 v) ->
      C:Show1
        ($fShow1Loop_$cliftShowsPrec $dShow1)
        ($fShow1Loop_$cliftShowList $dShow1)

-- RHS size: {terms: 24, types: 38, coercions: 0, joins: 0/0}
$fShowLoop_$cshowsPrec
  :: forall (v :: * -> *) n.
     (Show1 v, Show n) =>
     Int -> Loop v n -> ShowS
$fShowLoop_$cshowsPrec
  = \ (@ (v :: * -> *))
      (@ n)
      ($dShow1 :: Show1 v)
      ($dShow :: Show n)
      (eta :: Int)
      (eta1 :: Loop v n) ->
      case eta of { I# ww1 ->
      case eta1 of { Loop ww3 ww4 ->
      case ww3 of { Line ww6 ww7 ->
      $w$cliftShowsPrec1
        $dShow1 (showsPrec $dShow) (showList $dShow) ww1 ww6 ww4
      }
      }
      }

-- RHS size: {terms: 16, types: 22, coercions: 0, joins: 0/0}
$w$cshow
  :: forall (v :: * -> *) n.
     (Show1 v, Show n) =>
     Seq (Segment v n) -> ClosingSegment v n -> String
$w$cshow
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Show1 v)
      (w1 :: Show n)
      (ww
         :: Seq (Segment v n)
         Unf=OtherCon [])
      (ww1
         :: ClosingSegment v n
         Unf=OtherCon []) ->
      $w$cliftShowsPrec1 w (showsPrec w1) (showList w1) 0# ww ww1 []

-- RHS size: {terms: 16, types: 33, coercions: 0, joins: 0/0}
$fShowLoop_$cshow
  :: forall (v :: * -> *) n. (Show1 v, Show n) => Loop v n -> String
$fShowLoop_$cshow
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Show1 v)
      (w1 :: Show n)
      (w2 :: Loop v n) ->
      case w2 of { Loop ww1 ww2 ->
      case ww1 of { Line ww4 ww5 -> $w$cshow w w1 ww4 ww2 }
      }

-- RHS size: {terms: 29, types: 49, coercions: 0, joins: 0/2}
$fShowLoop_$cshowList
  :: forall (v :: * -> *) n. (Show1 v, Show n) => [Loop v n] -> ShowS
$fShowLoop_$cshowList
  = \ (@ (v :: * -> *))
      (@ n)
      ($dShow1 :: Show1 v)
      ($dShow :: Show n)
      (ls :: [Loop v n])
      (s :: String) ->
      showList__
        (let {
           w :: [n] -> ShowS
           w = showList $dShow } in
         let {
           w1 :: Int -> n -> ShowS
           w1 = showsPrec $dShow } in
         \ (w2 :: Loop v n) ->
           case w2 of { Loop ww1 ww2 ->
           case ww1 of { Line ww4 ww5 ->
           $w$cliftShowsPrec1 $dShow1 w1 w 0# ww4 ww2
           }
           })
        ls
        s

-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
$fShowLoop
  :: forall (v :: * -> *) n. (Show1 v, Show n) => Show (Loop v n)
$fShowLoop
  = \ (@ (v :: * -> *))
      (@ n)
      ($dShow1 :: Show1 v)
      ($dShow :: Show n) ->
      C:Show
        ($fShowLoop_$cshowsPrec $dShow1 $dShow)
        ($fShowLoop_$cshow $dShow1 $dShow)
        ($fShowLoop_$cshowList $dShow1 $dShow)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
$fShow1Line3 :: Addr#
$fShow1Line3 = "fromSegments "#

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
$fShow1Line2 :: [Char]
$fShow1Line2 = unpackCString# $fShow1Line3

-- RHS size: {terms: 111, types: 144, coercions: 104, joins: 0/6}
$w$cliftShowsPrec
  :: forall (v :: * -> *).
     Show1 v =>
     forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int# -> Line v a -> ShowS
$w$cliftShowsPrec
  = \ (@ (v :: * -> *))
      (w :: Show1 v)
      (@ a)
      (w1 :: Int -> a -> ShowS)
      (w2 :: [a] -> ShowS)
      (ww :: Int#)
      (w3 :: Line v a) ->
      let {
        eta :: [Segment v a]
        eta
          = case w3 of { Line s o ->
            (($fEq1Seq_$cfoldr
                (trailPoints1 `cast` <Co:64>)
                (id `cast` <Co:19>)
                (s `cast` <Co:4>))
             `cast` <Co:17>)
              []
            } } in
      case tagToEnum# (># ww 10#) of {
        False ->
          \ (x :: String) ->
            ++
              $fShow1Line2
              (case eta of {
                 [] -> unpackAppendCString# showList__4 x;
                 : x1 xs ->
                   : showList__3
                     ($w$cliftShowsPrec
                        w
                        w1
                        w2
                        0#
                        x1
                        (let {
                           lvl77 :: [Char]
                           lvl77 = : showList__2 x } in
                         letrec {
                           showl :: [Segment v a] -> String
                           showl
                             = \ (ds2 :: [Segment v a]) ->
                                 case ds2 of {
                                   [] -> lvl77;
                                   : y ys ->
                                     : showList__1 ($w$cliftShowsPrec w w1 w2 0# y (showl ys))
                                 }; } in
                         showl xs))
               });
        True ->
          \ (x :: String) ->
            : $fShow(,)4
              (++
                 $fShow1Line2
                 (let {
                    eta1 :: String
                    eta1 = : $fShow(,)2 x } in
                  case eta of {
                    [] -> unpackAppendCString# showList__4 eta1;
                    : x1 xs ->
                      : showList__3
                        ($w$cliftShowsPrec
                           w
                           w1
                           w2
                           0#
                           x1
                           (let {
                              lvl77 :: [Char]
                              lvl77 = : showList__2 eta1 } in
                            letrec {
                              showl :: [Segment v a] -> String
                              showl
                                = \ (ds2 :: [Segment v a]) ->
                                    case ds2 of {
                                      [] -> lvl77;
                                      : y ys ->
                                        : showList__1 ($w$cliftShowsPrec w w1 w2 0# y (showl ys))
                                    }; } in
                            showl xs))
                  }))
      }

-- RHS size: {terms: 16, types: 22, coercions: 0, joins: 0/0}
$fShow1Line_$cliftShowsPrec
  :: forall (v :: * -> *).
     Show1 v =>
     forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> Line v a -> ShowS
$fShow1Line_$cliftShowsPrec
  = \ (@ (v :: * -> *))
      (w :: Show1 v)
      (@ a)
      (w1 :: Int -> a -> ShowS)
      (w2 :: [a] -> ShowS)
      (w3 :: Int)
      (w4 :: Line v a) ->
      case w3 of { I# ww1 -> $w$cliftShowsPrec w w1 w2 ww1 w4 }

-- RHS size: {terms: 17, types: 27, coercions: 0, joins: 0/0}
$fShow1Line_$cliftShowList
  :: forall (v :: * -> *).
     Show1 v =>
     forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> [Line v a] -> ShowS
$fShow1Line_$cliftShowList
  = \ (@ (v :: * -> *))
      ($dShow1 :: Show1 v)
      (@ a)
      (sp :: Int -> a -> ShowS)
      (sl :: [a] -> ShowS)
      (eta :: [Line v a])
      (eta1 :: String) ->
      showList__
        (\ (w :: Line v a) -> $w$cliftShowsPrec $dShow1 sp sl 0# w)
        eta
        eta1

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
$fShow1Line :: forall (v :: * -> *). Show1 v => Show1 (Line v)
$fShow1Line
  = \ (@ (v :: * -> *)) ($dShow1 :: Show1 v) ->
      C:Show1
        ($fShow1Line_$cliftShowsPrec $dShow1)
        ($fShow1Line_$cliftShowList $dShow1)

-- RHS size: {terms: 30, types: 49, coercions: 0, joins: 0/0}
$w$cliftShowsPrec2
  :: forall (v :: * -> *).
     Show1 v =>
     forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int# -> Trail v a -> ShowS
$w$cliftShowsPrec2
  = \ (@ (v :: * -> *))
      (w :: Show1 v)
      (@ a)
      (w1 :: Int -> a -> ShowS)
      (w2 :: [a] -> ShowS)
      (ww :: Int#)
      (w3 :: Trail v a) ->
      case w3 of {
        OpenTrail l -> $w$cliftShowsPrec w w1 w2 ww l;
        ClosedTrail l ->
          case l of { Loop ww2 ww3 ->
          case ww2 of { Line ww5 ww6 ->
          $w$cliftShowsPrec1 w w1 w2 ww ww5 ww3
          }
          }
      }

-- RHS size: {terms: 16, types: 22, coercions: 0, joins: 0/0}
$fShow1Trail_$cliftShowsPrec
  :: forall (v :: * -> *).
     Show1 v =>
     forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> Int -> Trail v a -> ShowS
$fShow1Trail_$cliftShowsPrec
  = \ (@ (v :: * -> *))
      (w :: Show1 v)
      (@ a)
      (w1 :: Int -> a -> ShowS)
      (w2 :: [a] -> ShowS)
      (w3 :: Int)
      (w4 :: Trail v a) ->
      case w3 of { I# ww1 -> $w$cliftShowsPrec2 w w1 w2 ww1 w4 }

-- RHS size: {terms: 17, types: 27, coercions: 0, joins: 0/0}
$fShow1Trail_$cliftShowList
  :: forall (v :: * -> *).
     Show1 v =>
     forall a.
     (Int -> a -> ShowS) -> ([a] -> ShowS) -> [Trail v a] -> ShowS
$fShow1Trail_$cliftShowList
  = \ (@ (v :: * -> *))
      ($dShow1 :: Show1 v)
      (@ a)
      (sp :: Int -> a -> ShowS)
      (sl :: [a] -> ShowS)
      (eta :: [Trail v a])
      (eta1 :: String) ->
      showList__
        (\ (w :: Trail v a) -> $w$cliftShowsPrec2 $dShow1 sp sl 0# w)
        eta
        eta1

-- RHS size: {terms: 7, types: 10, coercions: 0, joins: 0/0}
$fShow1Trail :: forall (v :: * -> *). Show1 v => Show1 (Trail v)
$fShow1Trail
  = \ (@ (v :: * -> *)) ($dShow1 :: Show1 v) ->
      C:Show1
        ($fShow1Trail_$cliftShowsPrec $dShow1)
        ($fShow1Trail_$cliftShowList $dShow1)

-- RHS size: {terms: 33, types: 49, coercions: 0, joins: 0/0}
$w$cshowsPrec
  :: forall (v :: * -> *) n.
     (Show1 v, Show n) =>
     Int# -> Trail v n -> ShowS
$w$cshowsPrec
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Show1 v)
      (w1 :: Show n)
      (ww :: Int#)
      (w2 :: Trail v n) ->
      case w2 of {
        OpenTrail l ->
          $w$cliftShowsPrec w (showsPrec w1) (showList w1) ww l;
        ClosedTrail l ->
          case l of { Loop ww2 ww3 ->
          case ww2 of { Line ww5 ww6 ->
          $w$cliftShowsPrec1 w (showsPrec w1) (showList w1) ww ww5 ww3
          }
          }
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fShowTrail_$cshowsPrec
  :: forall (v :: * -> *) n.
     (Show1 v, Show n) =>
     Int -> Trail v n -> ShowS
$fShowTrail_$cshowsPrec
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Show1 v)
      (w1 :: Show n)
      (w2 :: Int)
      (w3 :: Trail v n) ->
      case w2 of { I# ww1 -> $w$cshowsPrec w w1 ww1 w3 }

-- RHS size: {terms: 34, types: 50, coercions: 0, joins: 0/0}
$fShowTrail_$cshow
  :: forall (v :: * -> *) n. (Show1 v, Show n) => Trail v n -> String
$fShowTrail_$cshow
  = \ (@ (v :: * -> *))
      (@ n)
      ($dShow1 :: Show1 v)
      ($dShow :: Show n)
      (x :: Trail v n) ->
      case x of {
        OpenTrail l ->
          $w$cliftShowsPrec
            $dShow1 (showsPrec $dShow) (showList $dShow) 0# l [];
        ClosedTrail l ->
          case l of { Loop ww1 ww2 ->
          case ww1 of { Line ww4 ww5 ->
          $w$cliftShowsPrec1
            $dShow1 (showsPrec $dShow) (showList $dShow) 0# ww4 ww2 []
          }
          }
      }

-- RHS size: {terms: 39, types: 60, coercions: 0, joins: 0/2}
$fShowTrail_$cshowList
  :: forall (v :: * -> *) n.
     (Show1 v, Show n) =>
     [Trail v n] -> ShowS
$fShowTrail_$cshowList
  = \ (@ (v :: * -> *))
      (@ n)
      ($dShow1 :: Show1 v)
      ($dShow :: Show n)
      (ls :: [Trail v n])
      (s :: String) ->
      showList__
        (let {
           x :: Int -> n -> ShowS
           x = showsPrec $dShow } in
         let {
           y :: [n] -> ShowS
           y = showList $dShow } in
         \ (ds :: Trail v n) ->
           case ds of {
             OpenTrail l -> $w$cliftShowsPrec $dShow1 x y 0# l;
             ClosedTrail l ->
               case l of { Loop ww1 ww2 ->
               case ww1 of { Line ww4 ww5 ->
               $w$cliftShowsPrec1 $dShow1 x y 0# ww4 ww2
               }
               }
           })
        ls
        s

-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
$fShowTrail
  :: forall (v :: * -> *) n. (Show1 v, Show n) => Show (Trail v n)
$fShowTrail
  = \ (@ (v :: * -> *))
      (@ n)
      ($dShow1 :: Show1 v)
      ($dShow :: Show n) ->
      C:Show
        ($fShowTrail_$cshowsPrec $dShow1 $dShow)
        ($fShowTrail_$cshow $dShow1 $dShow)
        ($fShowTrail_$cshowList $dShow1 $dShow)

-- RHS size: {terms: 17, types: 20, coercions: 0, joins: 0/0}
$fShowLine_$cshowsPrec
  :: forall (v :: * -> *) n.
     (Show1 v, Show n) =>
     Int -> Line v n -> ShowS
$fShowLine_$cshowsPrec
  = \ (@ (v :: * -> *))
      (@ n)
      ($dShow1 :: Show1 v)
      ($dShow :: Show n)
      (eta :: Int)
      (eta1 :: Line v n) ->
      case eta of { I# ww1 ->
      $w$cliftShowsPrec
        $dShow1 (showsPrec $dShow) (showList $dShow) ww1 eta1
      }

-- RHS size: {terms: 14, types: 18, coercions: 0, joins: 0/0}
$fShowLine_$cshow
  :: forall (v :: * -> *) n. (Show1 v, Show n) => Line v n -> String
$fShowLine_$cshow
  = \ (@ (v :: * -> *))
      (@ n)
      ($dShow1 :: Show1 v)
      ($dShow :: Show n)
      (x :: Line v n) ->
      $w$cliftShowsPrec
        $dShow1 (showsPrec $dShow) (showList $dShow) 0# x []

-- RHS size: {terms: 22, types: 31, coercions: 0, joins: 0/2}
$fShowLine_$cshowList
  :: forall (v :: * -> *) n. (Show1 v, Show n) => [Line v n] -> ShowS
$fShowLine_$cshowList
  = \ (@ (v :: * -> *))
      (@ n)
      ($dShow1 :: Show1 v)
      ($dShow :: Show n)
      (ls :: [Line v n])
      (s :: String) ->
      showList__
        (let {
           w :: [n] -> ShowS
           w = showList $dShow } in
         let {
           w1 :: Int -> n -> ShowS
           w1 = showsPrec $dShow } in
         \ (w2 :: Line v n) -> $w$cliftShowsPrec $dShow1 w1 w 0# w2)
        ls
        s

-- RHS size: {terms: 14, types: 19, coercions: 0, joins: 0/0}
$fShowLine
  :: forall (v :: * -> *) n. (Show1 v, Show n) => Show (Line v n)
$fShowLine
  = \ (@ (v :: * -> *))
      (@ n)
      ($dShow1 :: Show1 v)
      ($dShow :: Show n) ->
      C:Show
        ($fShowLine_$cshowsPrec $dShow1 $dShow)
        ($fShowLine_$cshow $dShow1 $dShow)
        ($fShowLine_$cshowList $dShow1 $dShow)

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl46 :: Addr#
lvl46
  = "ww V (Line V2 Double) (V (Line V2 Double) (N (Line V2 Double)))"#

-- RHS size: {terms: 2, types: 13, coercions: 0, joins: 0/0}
$fTransformableLine2
  :: V (Line V2 Double) (V (Line V2 Double) (N (Line V2 Double)))
$fTransformableLine2 = absentError lvl46

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl47 :: Addr#
lvl47 = "ww V (Line V2 Double) (N (Line V2 Double))"#

-- RHS size: {terms: 2, types: 9, coercions: 0, joins: 0/0}
$fTransformableLine1 :: V (Line V2 Double) (N (Line V2 Double))
$fTransformableLine1 = absentError lvl47

-- RHS size: {terms: 76, types: 121, coercions: 60, joins: 0/0}
$fTransformableLine_$s$ctransform1
  :: Transformation (V (Line V2 Double)) (N (Line V2 Double))
     -> Line V2 Double -> Line V2 Double
$fTransformableLine_$s$ctransform1
  = \ (w :: Transformation (V (Line V2 Double)) (N (Line V2 Double)))
      (w1 :: Line V2 Double) ->
      case w of { T ww1 ww2 ww3 ->
      case ww1 `cast` <Co:10> of { V2 ww5 ww6 ->
      case ww5 of { V2 ww8 ww9 ->
      case ww8 of { D# ww11 ->
      case ww9 of { D# ww13 ->
      case ww6 of { V2 ww15 ww16 ->
      case ww15 of { D# ww18 ->
      case ww16 of { D# ww20 ->
      case w1 of { Line ww22 ww23 ->
      case ww23 of { V2 ww25 ww26 ->
      case ww25 of { D# ww28 ->
      case ww26 of { D# ww30 ->
      case $fFunctorSeq_$cfmap
             (($fTransformableLine_$s$fTransformableSegment_$ctransform1
                 ((T ((V2 (V2 (D# ww11) (D# ww13)) (V2 (D# ww18) (D# ww20)))
                      `cast` <Co:13>)
                     $fTransformableLine2
                     $fTransformableLine1)
                  `cast` <Co:17>))
              `cast` <Co:11>)
             (ww22 `cast` <Co:4>)
      of nt
      { __DEFAULT ->
      Line
        (nt `cast` <Co:5>)
        (V2
           (D# (+## (*## ww11 ww28) (*## ww13 ww30)))
           (D# (+## (*## ww18 ww28) (*## ww20 ww30))))
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 104, types: 101, coercions: 44, joins: 0/0}
$fTransformableLine_$s$ctransform
  :: Transformation (V (Line V3 Double)) (N (Line V3 Double))
     -> Line V3 Double -> Line V3 Double
$fTransformableLine_$s$ctransform
  = \ (t :: Transformation (V (Line V3 Double)) (N (Line V3 Double)))
      (ds :: Line V3 Double) ->
      case ds of { Line ss o ->
      case o of { V3 d e f3 ->
      case d of { D# y ->
      case e of { D# y1 ->
      case f3 of { D# y2 ->
      case $fFunctorSeq_$cfmap
             (($fTransformableLine_$s$fTransformableSegment_$ctransform
                 (t `cast` <Co:17>))
              `cast` <Co:11>)
             (ss `cast` <Co:4>)
      of nt
      { __DEFAULT ->
      case t `cast` <Co:7> of { T m ds1 ds2 ->
      case m of { V3 a1 b1 c ->
      case a1 of { V3 a2 b2 c1 ->
      case a2 of { D# x ->
      case b2 of { D# x1 ->
      case c1 of { D# x2 ->
      case b1 of { V3 a3 b3 c2 ->
      case a3 of { D# x3 ->
      case b3 of { D# x4 ->
      case c2 of { D# x5 ->
      case c of { V3 a4 b4 c3 ->
      case a4 of { D# x6 ->
      case b4 of { D# x7 ->
      case c3 of { D# x8 ->
      Line
        (nt `cast` <Co:5>)
        (V3
           (D# (+## (+## (*## x y) (*## x1 y1)) (*## x2 y2)))
           (D# (+## (+## (*## x3 y) (*## x4 y1)) (*## x5 y2)))
           (D# (+## (+## (*## x6 y) (*## x7 y1)) (*## x8 y2))))
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl48 :: Addr#
lvl48 = "ww V (Line v n) (V (Line v n) (N (Line v n)))"#

-- RHS size: {terms: 4, types: 19, coercions: 0, joins: 0/0}
$fTransformableLine4
  :: forall (v :: * -> *) n.
     V (Line v n) (V (Line v n) (N (Line v n)))
$fTransformableLine4
  = \ (@ (v :: * -> *)) (@ n) -> absentError lvl48

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl49 :: Addr#
lvl49 = "ww V (Line v n) (N (Line v n))"#

-- RHS size: {terms: 4, types: 15, coercions: 0, joins: 0/0}
$fTransformableLine3
  :: forall (v :: * -> *) n. V (Line v n) (N (Line v n))
$fTransformableLine3
  = \ (@ (v :: * -> *)) (@ n) -> absentError lvl49

-- RHS size: {terms: 33, types: 71, coercions: 47, joins: 0/0}
$w$ctransform
  :: forall (v :: * -> *) n.
     (Additive v, Num n, Foldable v) =>
     V (Line v n) (V (Line v n) (N (Line v n)))
     -> Seq (Segment v n) -> v n -> (# Seq (Segment v n), v n #)
$w$ctransform
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (w2 :: Foldable v)
      (ww
         :: V (Line v n) (V (Line v n) (N (Line v n)))
         Unf=OtherCon [])
      (ww1
         :: Seq (Segment v n)
         Unf=OtherCon [])
      (ww2
         :: v n
         Unf=OtherCon []) ->
      case $fFunctorSeq_$cfmap
             (($fTransformableSegment_$ctransform
                 w
                 w2
                 w1
                 ((T ww $fTransformableLine4 $fTransformableLine3) `cast` <Co:17>))
              `cast` <Co:11>)
             (ww1 `cast` <Co:4>)
      of nt
      { __DEFAULT ->
      case !* ($p1Additive w) w2 w w1 (ww `cast` <Co:10>) ww2 of dt7
      { __DEFAULT ->
      (# nt `cast` <Co:5>, dt7 #)
      }
      }

-- RHS size: {terms: 25, types: 93, coercions: 0, joins: 0/0}
$fTransformableLine_$ctransform
  :: forall (v :: * -> *) n.
     (Additive v, Num n, Foldable v) =>
     Transformation (V (Line v n)) (N (Line v n))
     -> Line v n -> Line v n
$fTransformableLine_$ctransform
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Additive v)
      (w1 :: Num n)
      (w2 :: Foldable v)
      (w3 :: Transformation (V (Line v n)) (N (Line v n)))
      (w4 :: Line v n) ->
      case w3 of { T ww1 ww2 ww3 ->
      case w4 of { Line ww5 ww6 ->
      case $w$ctransform w w1 w2 ww1 ww5 ww6 of { (# ww8, ww9 #) ->
      Line ww8 ww9
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 22, joins: 0/0}
$fTransformableLine
  :: forall (v :: * -> *) n.
     (Additive v, Num n, Foldable v) =>
     Transformable (Line v n)
$fTransformableLine
  = $fTransformableLine_$ctransform `cast` <Co:22>

-- RHS size: {terms: 5, types: 0, coercions: 0, joins: 0/0}
lineEnv4 :: LE2D
lineEnv4 = LE2D 0.0## 0.0## 0.0## 0.0##

-- RHS size: {terms: 223, types: 100, coercions: 13, joins: 0/5}
$wlineEnv2Double
  :: Seq (Segment V2 Double)
     -> Double# -> Double# -> (# Double, Double #)
$wlineEnv2Double
  = \ (ww
         :: Seq (Segment V2 Double)
         Unf=OtherCon [])
      (ww1 :: Double#)
      (ww2 :: Double#) ->
      case $fFoldableFingerTree_$cfoldl'
             ((\ (ds :: LE2D) (eta :: Segment V2 Double) ->
                 case ds of { LE2D dt7 dt8 dt9 dt10 ->
                 case eta of {
                   Linear v ->
                     case v of { V2 dx dy ->
                     case dx of { D# x ->
                     case dy of { D# x1 ->
                     let {
                       ipv :: Double#
                       ipv = +## (*## x ww1) (*## x1 ww2) } in
                     let {
                       d' :: Double#
                       d' = +## ipv (+## (*## dt7 ww1) (*## dt8 ww2)) } in
                     case tagToEnum# (<## ipv 0.0##) of {
                       False ->
                         case tagToEnum# (<=## dt10 d') of {
                           False -> LE2D (+## dt7 x) (+## dt8 x1) dt9 dt10;
                           True -> LE2D (+## dt7 x) (+## dt8 x1) dt9 d'
                         };
                       True ->
                         case tagToEnum# (<=## dt9 d') of {
                           False -> LE2D (+## dt7 x) (+## dt8 x1) d' dt10;
                           True -> LE2D (+## dt7 x) (+## dt8 x1) dt9 dt10
                         }
                     }
                     }
                     }
                     };
                   Cubic c1 c2 c3 ->
                     case c3 of { V2 dx dy ->
                     case dx of { D# y ->
                     case dy of { D# y1 ->
                     case c1 of { V2 ww4 ww5 ->
                     case ww4 of { D# ww7 ->
                     case ww5 of { D# ww9 ->
                     case c2 of { V2 ww11 ww12 ->
                     case ww11 of { D# ww14 ->
                     case ww12 of { D# ww16 ->
                     case $w$scubicEnvelope ww7 ww9 ww14 ww16 y y1 ww1 ww2 of
                     { (# ww29, ww30 #) ->
                     case ww29 of { D# y2 ->
                     case ww30 of { D# y3 ->
                     let {
                       ipv :: Double#
                       ipv = +## (*## dt7 ww1) (*## dt8 ww2) } in
                     let {
                       y4 :: Double#
                       y4 = +## ipv y2 } in
                     let {
                       y5 :: Double#
                       y5 = +## ipv y3 } in
                     case tagToEnum# (<=## dt9 y4) of {
                       False ->
                         case tagToEnum# (<=## dt10 y5) of {
                           False -> LE2D (+## dt7 y) (+## dt8 y1) y4 dt10;
                           True -> LE2D (+## dt7 y) (+## dt8 y1) y4 y5
                         };
                       True ->
                         case tagToEnum# (<=## dt10 y5) of {
                           False -> LE2D (+## dt7 y) (+## dt8 y1) dt9 dt10;
                           True -> LE2D (+## dt7 y) (+## dt8 y1) dt9 y5
                         }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                 }
                 })
              `cast` <Co:9>)
             lineEnv4
             (ww `cast` <Co:4>)
      of
      { LE2D dt7 dt8 dt9 dt10 ->
      (# D# dt9, D# dt10 #)
      }

-- RHS size: {terms: 23, types: 30, coercions: 0, joins: 0/0}
lineEnv2Double :: Line V2 Double -> V2 Double -> Interval Double
lineEnv2Double
  = \ (w :: Line V2 Double) (w1 :: V2 Double) ->
      case w of { Line ww1 ww2 ->
      case w1 of { V2 ww4 ww5 ->
      case ww4 of { D# ww7 ->
      case ww5 of { D# ww9 ->
      case $wlineEnv2Double ww1 ww7 ww9 of { (# ww11, ww12 #) ->
      I ww11 ww12
      }
      }
      }
      }
      }

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
lineEnv_a1 :: Double
lineEnv_a1 = D# 0.0##

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
lvl50 :: V2 Double
lvl50 = V2 lineEnv_a1 lineEnv_a1

-- RHS size: {terms: 4, types: 8, coercions: 7, joins: 0/0}
lvl51 :: (Point V2 Double, Bool, Seq Double)
lvl51 = (lvl50 `cast` <Co:4>, False, EmptyT `cast` <Co:3>)

-- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
dt4 :: Double
dt4 = D# 1.0##

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
dt5 :: V2 Double
dt5 = V2 dt4 lineEnv_a1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
dt6 :: V2 Double
dt6 = V2 lineEnv_a1 dt4

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
lvl52 :: V2 (V2 Double)
lvl52 = V2 dt5 dt6

-- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
lvl53 :: [Double]
lvl53 = : lineEnv_a1 []

Rec {
-- RHS size: {terms: 19, types: 11, coercions: 0, joins: 0/0}
go :: [Double] -> Bool
go
  = \ (ds :: [Double]) ->
      case ds of {
        [] -> False;
        : y ys ->
          case y of { D# x ->
          case tagToEnum# (>## x 0.9999##) of {
            False -> go ys;
            True -> True
          }
          }
      }
end Rec }

-- RHS size: {terms: 2,321,
              types: 888,
              coercions: 749,
              joins: 11/81}
$w$sloopTrace
  :: Seq (Segment V2 Double)
     -> Double#
     -> Double#
     -> ClosingSegment V2 Double
     -> Double#
     -> Double#
     -> Double#
     -> Double#
     -> Seq Double
$w$sloopTrace
  = \ (ww
         :: Seq (Segment V2 Double)
         Unf=OtherCon [])
      (ww1 :: Double#)
      (ww2 :: Double#)
      (ww3
         :: ClosingSegment V2 Double
         Unf=OtherCon [])
      (ww4 :: Double#)
      (ww5 :: Double#)
      (ww6 :: Double#)
      (ww7 :: Double#) ->
      join {
        $w$j :: Double# -> Seq Double
        $w$j (ww8 :: Double#)
          = case /## 1.0## (sqrtDouble# (+## (*## ww6 ww6) (*## ww7 ww7)))
            of wild4
            { __DEFAULT ->
            case /## 0.0## wild4 of wild1 { __DEFAULT ->
            case /## 1.0## wild4 of wild2 { __DEFAULT ->
            let {
              x :: Double#
              x = negateDouble# ww8 } in
            let {
              ipv :: Double#
              ipv = cosDouble# x } in
            let {
              dt7 :: Double
              dt7 = D# ipv } in
            let {
              x1 :: Double#
              x1 = sinDouble# x } in
            let {
              wild3 :: Double
              wild3 = D# x1 } in
            let {
              dt8 :: Double#
              dt8 = negateDouble# x1 } in
            let {
              dt9 :: Double
              dt9 = D# dt8 } in
            case $fMonoidTransformation_$stappend1
                   (T (V2
                         (V2 (D# wild4) (D# (*## wild4 0.0##)))
                         (V2 (D# (*## wild4 0.0##)) (D# wild4)))
                      (V2 (V2 (D# wild2) (D# wild1)) (V2 (D# wild1) (D# wild2)))
                      lvl50)
                   ($fMonoidTransformation_$stappend1
                      (T (V2 (V2 dt7 dt9) (V2 wild3 dt7))
                         (V2 (V2 dt7 wild3) (V2 dt9 dt7))
                         lvl50)
                      (T lvl52
                         lvl52
                         (V2 (D# (negateDouble# ww4)) (D# (negateDouble# ww5)))))
            of
            { T ipv1 ipv2 ipv3 ->
            case ipv1 of { V2 a5 b3 ->
            case ipv3 of { V2 d e ->
            case a5 of { V2 a1 b1 ->
            case a1 of { D# x2 ->
            case b1 of { D# x3 ->
            case b3 of { V2 a2 b2 ->
            case a2 of { D# x4 ->
            case b2 of { D# x5 ->
            case d of { D# y ->
            case e of { D# y1 ->
            let {
              $wf
                :: Segment V2 Double
                   -> Endo (Point V2 Double, Bool, Seq Double)
                   -> Double#
                   -> Double#
                   -> Bool
                   -> Seq Double
                   -> (Point V2 Double, Bool, Seq Double)
              $wf
                = \ (w :: Segment V2 Double)
                    (w1 :: Endo (Point V2 Double, Bool, Seq Double))
                    (ww9 :: Double#)
                    (ww10 :: Double#)
                    (ww11 :: Bool)
                    (ww12 :: Seq Double) ->
                    case ww11 of _nearStart1 { __DEFAULT ->
                    case ww12 `cast` <Co:2> of nt2 { __DEFAULT ->
                    case w of {
                      Linear w2 ->
                        case w2 of { V2 x6 y2 ->
                        case y2 of { D# y3 ->
                        case x6 of { D# y4 ->
                        let {
                          x7 :: Double#
                          x7 = -## (*## ww6 y3) (*## ww7 y4) } in
                        let {
                          dt10 :: Double#
                          dt10 = +## ww9 (negateDouble# ww4) } in
                        let {
                          dt11 :: Double#
                          dt11 = +## ww10 (negateDouble# ww5) } in
                        let {
                          x8 :: Double#
                          x8 = -## (*## dt10 ww7) (*## dt11 ww6) } in
                        join {
                          $j1 :: (Point V2 Double, Bool, Seq Double)
                          $j1
                            = (w1 `cast` <Co:8>)
                                ((V2 (D# (+## ww9 y4)) (D# (+## ww10 y3))) `cast` <Co:37>, False,
                                 nt2 `cast` <Co:3>) } in
                        join {
                          $j2 :: (Point V2 Double, Bool, Seq Double)
                          $j2
                            = case /## x8 x7 of wild19 { __DEFAULT ->
                              case tagToEnum# (>=## wild19 0.0##) of {
                                False -> jump $j1;
                                True ->
                                  case tagToEnum# (<=## wild19 1.001##) of {
                                    False -> jump $j1;
                                    True ->
                                      (w1 `cast` <Co:8>)
                                        ((V2 (D# (+## ww9 y4)) (D# (+## ww10 y3))) `cast` <Co:37>,
                                         tagToEnum# (>## wild19 0.999##),
                                         ($b:|>_$ssnocTree
                                            nt2
                                            (case /## (-## (*## dt10 y3) (*## dt11 y4)) x7 of wild22
                                             { __DEFAULT ->
                                             (D# wild22) `cast` <Co:20>
                                             }))
                                         `cast` <Co:130>)
                                  }
                              }
                              } } in
                        case tagToEnum# (==## x7 0.0##) of {
                          False -> jump $j2;
                          True ->
                            case tagToEnum# (==## x8 0.0##) of {
                              False -> jump $j1;
                              True -> jump $j2
                            }
                        }
                        }
                        }
                        };
                      Cubic ipv5 ipv6 ipv7 ->
                        case ipv7 of { V2 d1 e1 ->
                        case ipv6 of { V2 d2 e2 ->
                        case ipv5 of { V2 d3 e3 ->
                        case d3 of { D# y2 ->
                        case e3 of { D# y3 ->
                        case d2 of { D# y4 ->
                        case e2 of { D# y5 ->
                        case d1 of { D# y6 ->
                        case e1 of { D# y7 ->
                        (w1 `cast` <Co:8>)
                          (let {
                             ds4 :: Double#
                             ds4 = +## (*## x2 y6) (*## x3 y7) } in
                           let {
                             ipv4 :: Double#
                             ipv4 = +## (*## x4 y4) (*## x5 y5) } in
                           let {
                             ds5 :: Double#
                             ds5 = +## (*## x2 y4) (*## x3 y5) } in
                           let {
                             ipv8 :: Double#
                             ipv8 = +## (*## x4 y2) (*## x5 y3) } in
                           let {
                             ds6 :: Double#
                             ds6 = +## (*## x2 y2) (*## x3 y3) } in
                           let {
                             ds7 :: Double#
                             ds7 = +## (+## (*## x2 ww9) (*## x3 ww10)) y } in
                           let {
                             ds1 :: Double#
                             ds1 = +## (+## (*## x4 ww9) (*## x5 ww10)) y1 } in
                           let {
                             tcs :: [Double]
                             tcs
                               = let {
                                   x6 :: Double#
                                   x6
                                     = +##
                                         (-## (*## 3.0## ipv8) (*## 3.0## ipv4))
                                         (+## (*## x4 y6) (*## x5 y7)) } in
                                 let {
                                   b :: Double#
                                   b = +## (negateDouble# (*## 6.0## ipv8)) (*## 3.0## ipv4) } in
                                 let {
                                   c1 :: Double#
                                   c1 = *## 3.0## ipv8 } in
                                 case tagToEnum# (<## (fabsDouble# x6) 1.0e-8##) of {
                                   False ->
                                     let {
                                       x7 :: Double#
                                       x7
                                         = -##
                                             (-##
                                                (+##
                                                   (-##
                                                      (*## (*## (*## (*## 18.0## x6) b) c1) ds1)
                                                      (*## (*## 4.0## (*## (*## b b) b)) ds1))
                                                   (*## (*## b b) (*## c1 c1)))
                                                (*## (*## 4.0## x6) (*## (*## c1 c1) c1)))
                                             (*## (*## 27.0## (*## x6 x6)) (*## ds1 ds1)) } in
                                     let {
                                       y8 :: Double#
                                       y8 = *## (*## b b) b } in
                                     let {
                                       xx :: Double#
                                       xx
                                         = +##
                                             (-## (+## y8 y8) (*## (*## (*## 9.0## x6) b) c1))
                                             (*## (*## 27.0## (*## x6 x6)) ds1) } in
                                     let {
                                       disc :: Double#
                                       disc = -## (*## (*## 3.0## x6) c1) (*## b b) } in
                                     case tagToEnum# (>## x7 0.0##) of {
                                       False ->
                                         join {
                                           $j1 :: [Double]
                                           $j1
                                             = join {
                                                 $j2 :: [Double]
                                                 $j2
                                                   = case /## b (*## 3.0## x6) of wild27
                                                     { __DEFAULT ->
                                                     case tagToEnum#
                                                            (<## (fabsDouble# disc) 1.0e-8##)
                                                     of {
                                                       False ->
                                                         let {
                                                           x8 :: Double#
                                                           x8
                                                             = *##
                                                                 0.5##
                                                                 (+##
                                                                    (sqrtDouble#
                                                                       (negateDouble#
                                                                          (*##
                                                                             (*##
                                                                                27.0## (*## x6 x6))
                                                                             x7)))
                                                                    xx) } in
                                                         case tagToEnum# (<## x8 0.0##) of {
                                                           False ->
                                                             let {
                                                               x9 :: Double#
                                                               x9
                                                                 = **## x8 0.3333333333333333## } in
                                                             case /## x9 (*## 3.0## x6) of wild30
                                                             { __DEFAULT ->
                                                             case /## disc (*## (*## 3.0## x6) x9)
                                                             of wild31
                                                             { __DEFAULT ->
                                                             let {
                                                               x10 :: Double#
                                                               x10
                                                                 = +##
                                                                     (-##
                                                                        (negateDouble# wild27)
                                                                        wild30)
                                                                     wild31 } in
                                                             case _nearStart1 of {
                                                               False ->
                                                                 case tagToEnum# (>=## x10 0.0##)
                                                                 of {
                                                                   False -> [];
                                                                   True ->
                                                                     case tagToEnum#
                                                                            (<=## x10 1.0001##)
                                                                     of {
                                                                       False -> [];
                                                                       True -> : (D# x10) []
                                                                     }
                                                                 };
                                                               True ->
                                                                 case tagToEnum# (>=## x10 1.0e-4##)
                                                                 of {
                                                                   False -> [];
                                                                   True ->
                                                                     case tagToEnum#
                                                                            (<=## x10 1.0001##)
                                                                     of {
                                                                       False -> [];
                                                                       True -> : (D# x10) []
                                                                     }
                                                                 }
                                                             }
                                                             }
                                                             };
                                                           True ->
                                                             let {
                                                               x9 :: Double#
                                                               x9
                                                                 = negateDouble#
                                                                     (**##
                                                                        (negateDouble# x8)
                                                                        0.3333333333333333##) } in
                                                             case /## x9 (*## 3.0## x6) of wild30
                                                             { __DEFAULT ->
                                                             case /## disc (*## (*## 3.0## x6) x9)
                                                             of wild31
                                                             { __DEFAULT ->
                                                             let {
                                                               x10 :: Double#
                                                               x10
                                                                 = +##
                                                                     (-##
                                                                        (negateDouble# wild27)
                                                                        wild30)
                                                                     wild31 } in
                                                             case _nearStart1 of {
                                                               False ->
                                                                 case tagToEnum# (>=## x10 0.0##)
                                                                 of {
                                                                   False -> [];
                                                                   True ->
                                                                     case tagToEnum#
                                                                            (<=## x10 1.0001##)
                                                                     of {
                                                                       False -> [];
                                                                       True -> : (D# x10) []
                                                                     }
                                                                 };
                                                               True ->
                                                                 case tagToEnum# (>=## x10 1.0e-4##)
                                                                 of {
                                                                   False -> [];
                                                                   True ->
                                                                     case tagToEnum#
                                                                            (<=## x10 1.0001##)
                                                                     of {
                                                                       False -> [];
                                                                       True -> : (D# x10) []
                                                                     }
                                                                 }
                                                             }
                                                             }
                                                             }
                                                         };
                                                       True ->
                                                         let {
                                                           x8 :: Double#
                                                           x8
                                                             = sqrtDouble#
                                                                 (negateDouble#
                                                                    (*##
                                                                       (*## 27.0## (*## x6 x6))
                                                                       x7)) } in
                                                         let {
                                                           x9 :: Double#
                                                           x9 = fabsDouble# (+## x8 xx) } in
                                                         let {
                                                           x10 :: Double#
                                                           x10 = negateDouble# x8 } in
                                                         let {
                                                           y9 :: Double#
                                                           y9 = fabsDouble# (+## x10 xx) } in
                                                         case tagToEnum# (<## x9 y9) of {
                                                           False ->
                                                             case tagToEnum# (==## x9 y9) of {
                                                               False ->
                                                                 let {
                                                                   x11 :: Double#
                                                                   x11 = *## 0.5## (+## x8 xx) } in
                                                                 case tagToEnum# (<## x11 0.0##)
                                                                 of {
                                                                   False ->
                                                                     let {
                                                                       x12 :: Double#
                                                                       x12
                                                                         = **##
                                                                             x11
                                                                             0.3333333333333333## } in
                                                                     case /## x12 (*## 3.0## x6)
                                                                     of wild32
                                                                     { __DEFAULT ->
                                                                     case /##
                                                                            disc
                                                                            (*## (*## 3.0## x6) x12)
                                                                     of wild33
                                                                     { __DEFAULT ->
                                                                     let {
                                                                       x13 :: Double#
                                                                       x13
                                                                         = +##
                                                                             (-##
                                                                                (negateDouble#
                                                                                   wild27)
                                                                                wild32)
                                                                             wild33 } in
                                                                     case _nearStart1 of {
                                                                       False ->
                                                                         case tagToEnum#
                                                                                (>=## x13 0.0##)
                                                                         of {
                                                                           False -> [];
                                                                           True ->
                                                                             case tagToEnum#
                                                                                    (<=##
                                                                                       x13 1.0001##)
                                                                             of {
                                                                               False -> [];
                                                                               True -> : (D# x13) []
                                                                             }
                                                                         };
                                                                       True ->
                                                                         case tagToEnum#
                                                                                (>=## x13 1.0e-4##)
                                                                         of {
                                                                           False -> [];
                                                                           True ->
                                                                             case tagToEnum#
                                                                                    (<=##
                                                                                       x13 1.0001##)
                                                                             of {
                                                                               False -> [];
                                                                               True -> : (D# x13) []
                                                                             }
                                                                         }
                                                                     }
                                                                     }
                                                                     };
                                                                   True ->
                                                                     let {
                                                                       x12 :: Double#
                                                                       x12
                                                                         = negateDouble#
                                                                             (**##
                                                                                (negateDouble# x11)
                                                                                0.3333333333333333##) } in
                                                                     case /## x12 (*## 3.0## x6)
                                                                     of wild32
                                                                     { __DEFAULT ->
                                                                     case /##
                                                                            disc
                                                                            (*## (*## 3.0## x6) x12)
                                                                     of wild33
                                                                     { __DEFAULT ->
                                                                     let {
                                                                       x13 :: Double#
                                                                       x13
                                                                         = +##
                                                                             (-##
                                                                                (negateDouble#
                                                                                   wild27)
                                                                                wild32)
                                                                             wild33 } in
                                                                     case _nearStart1 of {
                                                                       False ->
                                                                         case tagToEnum#
                                                                                (>=## x13 0.0##)
                                                                         of {
                                                                           False -> [];
                                                                           True ->
                                                                             case tagToEnum#
                                                                                    (<=##
                                                                                       x13 1.0001##)
                                                                             of {
                                                                               False -> [];
                                                                               True -> : (D# x13) []
                                                                             }
                                                                         };
                                                                       True ->
                                                                         case tagToEnum#
                                                                                (>=## x13 1.0e-4##)
                                                                         of {
                                                                           False -> [];
                                                                           True ->
                                                                             case tagToEnum#
                                                                                    (<=##
                                                                                       x13 1.0001##)
                                                                             of {
                                                                               False -> [];
                                                                               True -> : (D# x13) []
                                                                             }
                                                                         }
                                                                     }
                                                                     }
                                                                     }
                                                                 };
                                                               True ->
                                                                 let {
                                                                   x11 :: Double#
                                                                   x11 = *## 0.5## (+## x10 xx) } in
                                                                 case tagToEnum# (<## x11 0.0##)
                                                                 of {
                                                                   False ->
                                                                     let {
                                                                       x12 :: Double#
                                                                       x12
                                                                         = **##
                                                                             x11
                                                                             0.3333333333333333## } in
                                                                     case /## x12 (*## 3.0## x6)
                                                                     of wild32
                                                                     { __DEFAULT ->
                                                                     case /##
                                                                            disc
                                                                            (*## (*## 3.0## x6) x12)
                                                                     of wild33
                                                                     { __DEFAULT ->
                                                                     let {
                                                                       x13 :: Double#
                                                                       x13
                                                                         = +##
                                                                             (-##
                                                                                (negateDouble#
                                                                                   wild27)
                                                                                wild32)
                                                                             wild33 } in
                                                                     case _nearStart1 of {
                                                                       False ->
                                                                         case tagToEnum#
                                                                                (>=## x13 0.0##)
                                                                         of {
                                                                           False -> [];
                                                                           True ->
                                                                             case tagToEnum#
                                                                                    (<=##
                                                                                       x13 1.0001##)
                                                                             of {
                                                                               False -> [];
                                                                               True -> : (D# x13) []
                                                                             }
                                                                         };
                                                                       True ->
                                                                         case tagToEnum#
                                                                                (>=## x13 1.0e-4##)
                                                                         of {
                                                                           False -> [];
                                                                           True ->
                                                                             case tagToEnum#
                                                                                    (<=##
                                                                                       x13 1.0001##)
                                                                             of {
                                                                               False -> [];
                                                                               True -> : (D# x13) []
                                                                             }
                                                                         }
                                                                     }
                                                                     }
                                                                     };
                                                                   True ->
                                                                     let {
                                                                       x12 :: Double#
                                                                       x12
                                                                         = negateDouble#
                                                                             (**##
                                                                                (negateDouble# x11)
                                                                                0.3333333333333333##) } in
                                                                     case /## x12 (*## 3.0## x6)
                                                                     of wild32
                                                                     { __DEFAULT ->
                                                                     case /##
                                                                            disc
                                                                            (*## (*## 3.0## x6) x12)
                                                                     of wild33
                                                                     { __DEFAULT ->
                                                                     let {
                                                                       x13 :: Double#
                                                                       x13
                                                                         = +##
                                                                             (-##
                                                                                (negateDouble#
                                                                                   wild27)
                                                                                wild32)
                                                                             wild33 } in
                                                                     case _nearStart1 of {
                                                                       False ->
                                                                         case tagToEnum#
                                                                                (>=## x13 0.0##)
                                                                         of {
                                                                           False -> [];
                                                                           True ->
                                                                             case tagToEnum#
                                                                                    (<=##
                                                                                       x13 1.0001##)
                                                                             of {
                                                                               False -> [];
                                                                               True -> : (D# x13) []
                                                                             }
                                                                         };
                                                                       True ->
                                                                         case tagToEnum#
                                                                                (>=## x13 1.0e-4##)
                                                                         of {
                                                                           False -> [];
                                                                           True ->
                                                                             case tagToEnum#
                                                                                    (<=##
                                                                                       x13 1.0001##)
                                                                             of {
                                                                               False -> [];
                                                                               True -> : (D# x13) []
                                                                             }
                                                                         }
                                                                     }
                                                                     }
                                                                     }
                                                                 }
                                                             };
                                                           True ->
                                                             let {
                                                               x11 :: Double#
                                                               x11 = *## 0.5## (+## x10 xx) } in
                                                             case tagToEnum# (<## x11 0.0##) of {
                                                               False ->
                                                                 let {
                                                                   x12 :: Double#
                                                                   x12
                                                                     = **##
                                                                         x11
                                                                         0.3333333333333333## } in
                                                                 case /## x12 (*## 3.0## x6)
                                                                 of wild31
                                                                 { __DEFAULT ->
                                                                 case /##
                                                                        disc
                                                                        (*## (*## 3.0## x6) x12)
                                                                 of wild32
                                                                 { __DEFAULT ->
                                                                 let {
                                                                   x13 :: Double#
                                                                   x13
                                                                     = +##
                                                                         (-##
                                                                            (negateDouble# wild27)
                                                                            wild31)
                                                                         wild32 } in
                                                                 case _nearStart1 of {
                                                                   False ->
                                                                     case tagToEnum#
                                                                            (>=## x13 0.0##)
                                                                     of {
                                                                       False -> [];
                                                                       True ->
                                                                         case tagToEnum#
                                                                                (<=## x13 1.0001##)
                                                                         of {
                                                                           False -> [];
                                                                           True -> : (D# x13) []
                                                                         }
                                                                     };
                                                                   True ->
                                                                     case tagToEnum#
                                                                            (>=## x13 1.0e-4##)
                                                                     of {
                                                                       False -> [];
                                                                       True ->
                                                                         case tagToEnum#
                                                                                (<=## x13 1.0001##)
                                                                         of {
                                                                           False -> [];
                                                                           True -> : (D# x13) []
                                                                         }
                                                                     }
                                                                 }
                                                                 }
                                                                 };
                                                               True ->
                                                                 let {
                                                                   x12 :: Double#
                                                                   x12
                                                                     = negateDouble#
                                                                         (**##
                                                                            (negateDouble# x11)
                                                                            0.3333333333333333##) } in
                                                                 case /## x12 (*## 3.0## x6)
                                                                 of wild31
                                                                 { __DEFAULT ->
                                                                 case /##
                                                                        disc
                                                                        (*## (*## 3.0## x6) x12)
                                                                 of wild32
                                                                 { __DEFAULT ->
                                                                 let {
                                                                   x13 :: Double#
                                                                   x13
                                                                     = +##
                                                                         (-##
                                                                            (negateDouble# wild27)
                                                                            wild31)
                                                                         wild32 } in
                                                                 case _nearStart1 of {
                                                                   False ->
                                                                     case tagToEnum#
                                                                            (>=## x13 0.0##)
                                                                     of {
                                                                       False -> [];
                                                                       True ->
                                                                         case tagToEnum#
                                                                                (<=## x13 1.0001##)
                                                                         of {
                                                                           False -> [];
                                                                           True -> : (D# x13) []
                                                                         }
                                                                     };
                                                                   True ->
                                                                     case tagToEnum#
                                                                            (>=## x13 1.0e-4##)
                                                                     of {
                                                                       False -> [];
                                                                       True ->
                                                                         case tagToEnum#
                                                                                (<=## x13 1.0001##)
                                                                         of {
                                                                           False -> [];
                                                                           True -> : (D# x13) []
                                                                         }
                                                                     }
                                                                 }
                                                                 }
                                                                 }
                                                             }
                                                         }
                                                     }
                                                     } } in
                                               case tagToEnum# (==## x7 0.0##) of {
                                                 False -> jump $j2;
                                                 True ->
                                                   case tagToEnum# (==## disc 0.0##) of {
                                                     False ->
                                                       let {
                                                         r :: [Double]
                                                         r = case /##
                                                                    (+##
                                                                       (-##
                                                                          (*##
                                                                             (*## 9.0## (*## x6 x6))
                                                                             ds1)
                                                                          (*##
                                                                             (*## (*## 4.0## x6) b)
                                                                             c1))
                                                                       y8)
                                                                    (*## x6 disc)
                                                             of wild28
                                                             { __DEFAULT ->
                                                             case _nearStart1 of {
                                                               False ->
                                                                 case tagToEnum# (>=## wild28 0.0##)
                                                                 of {
                                                                   False -> [];
                                                                   True ->
                                                                     case tagToEnum#
                                                                            (<=## wild28 1.0001##)
                                                                     of {
                                                                       False -> [];
                                                                       True -> : (D# wild28) []
                                                                     }
                                                                 };
                                                               True ->
                                                                 case tagToEnum#
                                                                        (>=## wild28 1.0e-4##)
                                                                 of {
                                                                   False -> [];
                                                                   True ->
                                                                     case tagToEnum#
                                                                            (<=## wild28 1.0001##)
                                                                     of {
                                                                       False -> [];
                                                                       True -> : (D# wild28) []
                                                                     }
                                                                 }
                                                             }
                                                             } } in
                                                       case /##
                                                              (-##
                                                                 (*## b c1)
                                                                 (*## (*## 9.0## x6) ds1))
                                                              (+## disc disc)
                                                       of wild28
                                                       { __DEFAULT ->
                                                       case _nearStart1 of {
                                                         False ->
                                                           case tagToEnum# (>=## wild28 0.0##) of {
                                                             False -> r;
                                                             True ->
                                                               case tagToEnum#
                                                                      (<=## wild28 1.0001##)
                                                               of {
                                                                 False -> r;
                                                                 True -> : (D# wild28) r
                                                               }
                                                           };
                                                         True ->
                                                           case tagToEnum# (>=## wild28 1.0e-4##)
                                                           of {
                                                             False -> r;
                                                             True ->
                                                               case tagToEnum#
                                                                      (<=## wild28 1.0001##)
                                                               of {
                                                                 False -> r;
                                                                 True -> : (D# wild28) r
                                                               }
                                                           }
                                                       }
                                                       };
                                                     True -> jump $j2
                                                   }
                                               } } in
                                         case tagToEnum# (==## x7 0.0##) of {
                                           False -> jump $j1;
                                           True ->
                                             case tagToEnum# (==## disc 0.0##) of {
                                               False -> jump $j1;
                                               True ->
                                                 case /## b (*## 3.0## x6) of wild29 { __DEFAULT ->
                                                 let {
                                                   x8 :: Double#
                                                   x8 = negateDouble# wild29 } in
                                                 case _nearStart1 of {
                                                   False ->
                                                     case tagToEnum# (>=## x8 0.0##) of {
                                                       False -> [];
                                                       True ->
                                                         case tagToEnum# (<=## x8 1.0001##) of {
                                                           False -> [];
                                                           True -> : (D# x8) []
                                                         }
                                                     };
                                                   True ->
                                                     case tagToEnum# (>=## x8 1.0e-4##) of {
                                                       False -> [];
                                                       True ->
                                                         case tagToEnum# (<=## x8 1.0001##) of {
                                                           False -> [];
                                                           True -> : (D# x8) []
                                                         }
                                                     }
                                                 }
                                                 }
                                             }
                                         };
                                       True ->
                                         case /## disc (*## 3.0## (*## x6 x6)) of wild27
                                         { __DEFAULT ->
                                         let {
                                           y9 :: Double#
                                           y9 = sqrtDouble# (negateDouble# (/## wild27 3.0##)) } in
                                         case /## xx (*## 27.0## (*## (*## x6 x6) x6)) of wild28
                                         { __DEFAULT ->
                                         case /## (*## 3.0## wild28) (+## wild27 wild27) of wild29
                                         { __DEFAULT ->
                                         case /## 3.0## wild27 of wild30 { __DEFAULT ->
                                         case acosDouble#
                                                (*## wild29 (sqrtDouble# (negateDouble# wild30)))
                                         of wild31
                                         { __DEFAULT ->
                                         let {
                                           x8 :: Double#
                                           x8 = *## 0.3333333333333333## wild31 } in
                                         case /## b (*## 3.0## x6) of wild32 { __DEFAULT ->
                                         let {
                                           x9 :: Double#
                                           x9
                                             = -##
                                                 (*##
                                                    (+## y9 y9)
                                                    (cosDouble# (-## x8 4.1887902047863905##)))
                                                 wild32 } in
                                         let {
                                           r :: [Double]
                                           r = case _nearStart1 of {
                                                 False ->
                                                   case tagToEnum# (>=## x9 0.0##) of {
                                                     False -> [];
                                                     True ->
                                                       case tagToEnum# (<=## x9 1.0001##) of {
                                                         False -> [];
                                                         True -> : (D# x9) []
                                                       }
                                                   };
                                                 True ->
                                                   case tagToEnum# (>=## x9 1.0e-4##) of {
                                                     False -> [];
                                                     True ->
                                                       case tagToEnum# (<=## x9 1.0001##) of {
                                                         False -> [];
                                                         True -> : (D# x9) []
                                                       }
                                                   }
                                               } } in
                                         let {
                                           x10 :: Double#
                                           x10
                                             = -##
                                                 (*##
                                                    (+## y9 y9)
                                                    (cosDouble# (-## x8 2.0943951023931953##)))
                                                 wild32 } in
                                         let {
                                           r1 :: [Double]
                                           r1
                                             = case _nearStart1 of {
                                                 False ->
                                                   case tagToEnum# (>=## x10 0.0##) of {
                                                     False -> r;
                                                     True ->
                                                       case tagToEnum# (<=## x10 1.0001##) of {
                                                         False -> r;
                                                         True -> : (D# x10) r
                                                       }
                                                   };
                                                 True ->
                                                   case tagToEnum# (>=## x10 1.0e-4##) of {
                                                     False -> r;
                                                     True ->
                                                       case tagToEnum# (<=## x10 1.0001##) of {
                                                         False -> r;
                                                         True -> : (D# x10) r
                                                       }
                                                   }
                                               } } in
                                         let {
                                           x11 :: Double#
                                           x11 = -## (*## (+## y9 y9) (cosDouble# x8)) wild32 } in
                                         case _nearStart1 of {
                                           False ->
                                             case tagToEnum# (>=## x11 0.0##) of {
                                               False -> r1;
                                               True ->
                                                 case tagToEnum# (<=## x11 1.0001##) of {
                                                   False -> r1;
                                                   True -> : (D# x11) r1
                                                 }
                                             };
                                           True ->
                                             case tagToEnum# (>=## x11 1.0e-4##) of {
                                               False -> r1;
                                               True ->
                                                 case tagToEnum# (<=## x11 1.0001##) of {
                                                   False -> r1;
                                                   True -> : (D# x11) r1
                                                 }
                                             }
                                         }
                                         }
                                         }
                                         }
                                         }
                                         }
                                         }
                                     };
                                   True ->
                                     join {
                                       $j1 :: [Double]
                                       $j1
                                         = join {
                                             $j2 :: [Double]
                                             $j2
                                               = case tagToEnum# (==## b 0.0##) of {
                                                   False ->
                                                     let {
                                                       x7 :: Double#
                                                       x7
                                                         = -##
                                                             (*## c1 c1)
                                                             (*## (*## 4.0## b) ds1) } in
                                                     case tagToEnum# (<## x7 0.0##) of {
                                                       False ->
                                                         case tagToEnum# (==## c1 0.0##) of {
                                                           False ->
                                                             case tagToEnum# (==## x7 0.0##) of {
                                                               False ->
                                                                 join {
                                                                   $w$j1 :: Double# -> [Double]
                                                                   $w$j1 (w2 :: Double#)
                                                                     = let {
                                                                         r :: [Double]
                                                                         r = case /## ds1 w2
                                                                             of wild30
                                                                             { __DEFAULT ->
                                                                             case _nearStart1 of {
                                                                               False ->
                                                                                 case tagToEnum#
                                                                                        (>=##
                                                                                           wild30
                                                                                           0.0##)
                                                                                 of {
                                                                                   False -> [];
                                                                                   True ->
                                                                                     case tagToEnum#
                                                                                            (<=##
                                                                                               wild30
                                                                                               1.0001##)
                                                                                     of {
                                                                                       False -> [];
                                                                                       True ->
                                                                                         : (D#
                                                                                              wild30)
                                                                                           []
                                                                                     }
                                                                                 };
                                                                               True ->
                                                                                 case tagToEnum#
                                                                                        (>=##
                                                                                           wild30
                                                                                           1.0e-4##)
                                                                                 of {
                                                                                   False -> [];
                                                                                   True ->
                                                                                     case tagToEnum#
                                                                                            (<=##
                                                                                               wild30
                                                                                               1.0001##)
                                                                                     of {
                                                                                       False -> [];
                                                                                       True ->
                                                                                         : (D#
                                                                                              wild30)
                                                                                           []
                                                                                     }
                                                                                 }
                                                                             }
                                                                             } } in
                                                                       case /## w2 b of wild30
                                                                       { __DEFAULT ->
                                                                       case _nearStart1 of {
                                                                         False ->
                                                                           case tagToEnum#
                                                                                  (>=##
                                                                                     wild30 0.0##)
                                                                           of {
                                                                             False -> r;
                                                                             True ->
                                                                               case tagToEnum#
                                                                                      (<=##
                                                                                         wild30
                                                                                         1.0001##)
                                                                               of {
                                                                                 False -> r;
                                                                                 True ->
                                                                                   : (D# wild30) r
                                                                               }
                                                                           };
                                                                         True ->
                                                                           case tagToEnum#
                                                                                  (>=##
                                                                                     wild30
                                                                                     1.0e-4##)
                                                                           of {
                                                                             False -> r;
                                                                             True ->
                                                                               case tagToEnum#
                                                                                      (<=##
                                                                                         wild30
                                                                                         1.0001##)
                                                                               of {
                                                                                 False -> r;
                                                                                 True ->
                                                                                   : (D# wild30) r
                                                                               }
                                                                           }
                                                                       }
                                                                       } } in
                                                                 case tagToEnum# (>## c1 0.0##) of {
                                                                   False ->
                                                                     case tagToEnum# (<## c1 0.0##)
                                                                     of {
                                                                       False ->
                                                                         jump $w$j1
                                                                           (negateDouble#
                                                                              (*##
                                                                                 0.5##
                                                                                 (+##
                                                                                    c1
                                                                                    (*##
                                                                                       c1
                                                                                       (sqrtDouble#
                                                                                          x7)))));
                                                                       True ->
                                                                         jump $w$j1
                                                                           (negateDouble#
                                                                              (*##
                                                                                 0.5##
                                                                                 (+##
                                                                                    c1
                                                                                    (*##
                                                                                       -1.0##
                                                                                       (sqrtDouble#
                                                                                          x7)))))
                                                                     };
                                                                   True ->
                                                                     jump $w$j1
                                                                       (negateDouble#
                                                                          (*##
                                                                             0.5##
                                                                             (+##
                                                                                c1
                                                                                (sqrtDouble# x7))))
                                                                 };
                                                               True ->
                                                                 case /## c1 (+## b b) of wild30
                                                                 { __DEFAULT ->
                                                                 let {
                                                                   x8 :: Double#
                                                                   x8 = negateDouble# wild30 } in
                                                                 case _nearStart1 of {
                                                                   False ->
                                                                     case tagToEnum# (>=## x8 0.0##)
                                                                     of {
                                                                       False -> [];
                                                                       True ->
                                                                         case tagToEnum#
                                                                                (<=## x8 1.0001##)
                                                                         of {
                                                                           False -> [];
                                                                           True -> : (D# x8) []
                                                                         }
                                                                     };
                                                                   True ->
                                                                     case tagToEnum#
                                                                            (>=## x8 1.0e-4##)
                                                                     of {
                                                                       False -> [];
                                                                       True ->
                                                                         case tagToEnum#
                                                                                (<=## x8 1.0001##)
                                                                         of {
                                                                           False -> [];
                                                                           True -> : (D# x8) []
                                                                         }
                                                                     }
                                                                 }
                                                                 }
                                                             };
                                                           True ->
                                                             case /## ds1 b of wild29 { __DEFAULT ->
                                                             let {
                                                               x8 :: Double#
                                                               x8
                                                                 = sqrtDouble#
                                                                     (negateDouble# wild29) } in
                                                             let {
                                                               x9 :: Double#
                                                               x9 = negateDouble# x8 } in
                                                             let {
                                                               r :: [Double]
                                                               r = case _nearStart1 of {
                                                                     False ->
                                                                       case tagToEnum#
                                                                              (>=## x9 0.0##)
                                                                       of {
                                                                         False -> [];
                                                                         True ->
                                                                           case tagToEnum#
                                                                                  (<=## x9 1.0001##)
                                                                           of {
                                                                             False -> [];
                                                                             True -> : (D# x9) []
                                                                           }
                                                                       };
                                                                     True ->
                                                                       case tagToEnum#
                                                                              (>=## x9 1.0e-4##)
                                                                       of {
                                                                         False -> [];
                                                                         True ->
                                                                           case tagToEnum#
                                                                                  (<=## x9 1.0001##)
                                                                           of {
                                                                             False -> [];
                                                                             True -> : (D# x9) []
                                                                           }
                                                                       }
                                                                   } } in
                                                             case _nearStart1 of {
                                                               False ->
                                                                 case tagToEnum# (>=## x8 0.0##)
                                                                 of {
                                                                   False -> r;
                                                                   True ->
                                                                     case tagToEnum#
                                                                            (<=## x8 1.0001##)
                                                                     of {
                                                                       False -> r;
                                                                       True -> : (D# x8) r
                                                                     }
                                                                 };
                                                               True ->
                                                                 case tagToEnum# (>=## x8 1.0e-4##)
                                                                 of {
                                                                   False -> r;
                                                                   True ->
                                                                     case tagToEnum#
                                                                            (<=## x8 1.0001##)
                                                                     of {
                                                                       False -> r;
                                                                       True -> : (D# x8) r
                                                                     }
                                                                 }
                                                             }
                                                             }
                                                         };
                                                       True -> []
                                                     };
                                                   True ->
                                                     case /## ds1 c1 of wild27 { __DEFAULT ->
                                                     let {
                                                       x7 :: Double#
                                                       x7 = negateDouble# wild27 } in
                                                     case _nearStart1 of {
                                                       False ->
                                                         case tagToEnum# (>=## x7 0.0##) of {
                                                           False -> [];
                                                           True ->
                                                             case tagToEnum# (<=## x7 1.0001##) of {
                                                               False -> [];
                                                               True -> : (D# x7) []
                                                             }
                                                         };
                                                       True ->
                                                         case tagToEnum# (>=## x7 1.0e-4##) of {
                                                           False -> [];
                                                           True ->
                                                             case tagToEnum# (<=## x7 1.0001##) of {
                                                               False -> [];
                                                               True -> : (D# x7) []
                                                             }
                                                         }
                                                     }
                                                     }
                                                 } } in
                                           case tagToEnum# (==## b 0.0##) of {
                                             False -> jump $j2;
                                             True ->
                                               case tagToEnum# (==## c1 0.0##) of {
                                                 False -> jump $j2;
                                                 True -> []
                                               }
                                           } } in
                                     case tagToEnum# (==## b 0.0##) of {
                                       False -> jump $j1;
                                       True ->
                                         case tagToEnum# (==## c1 0.0##) of {
                                           False -> jump $j1;
                                           True ->
                                             case tagToEnum# (==## ds1 0.0##) of {
                                               False -> jump $j1;
                                               True ->
                                                 case _nearStart1 of {
                                                   False -> lvl53;
                                                   True -> []
                                                 }
                                             }
                                         }
                                     }
                                 } } in
                           ((V2 (D# (+## ww9 y6)) (D# (+## ww10 y7))) `cast` <Co:37>, go tcs,
                            ($fAlternativeSeq2
                               (nt2 `cast` <Co:3>)
                               (($fIsListSeq_mkTree
                                   ((map
                                       (\ (x6 :: Double) ->
                                          case x6 of { D# y8 ->
                                          let {
                                            y9 :: Double#
                                            y9 = -## 1.0## y8 } in
                                          D#
                                            (+##
                                               (+##
                                                  (+##
                                                     (*## (*## (*## (*## 3.0## y9) y9) y8) ds6)
                                                     (*## (*## (*## (*## 3.0## y9) y8) y8) ds5))
                                                  (*## (*## (*## y8 y8) y8) ds4))
                                               ds7)
                                          })
                                       tcs)
                                    `cast` <Co:15>))
                                `cast` <Co:15>))
                            `cast` <Co:3>))
                        }
                        }
                        }
                        }
                        }
                        }
                        }
                        }
                        }
                    }
                    }
                    } } in
            case (((($fEq1Seq_$cfoldr
                       ((\ (a3 :: Segment V2 Double)
                           (fa
                              :: Const
                                   (Endo (Endo (Point V2 Double, Bool, Seq Double)))
                                   (Segment V2 Double))
                           (eta :: Endo (Point V2 Double, Bool, Seq Double)) ->
                           let {
                             w :: Endo (Point V2 Double, Bool, Seq Double)
                             w = (fa `cast` <Co:25>) eta } in
                           \ (w1 :: (Point V2 Double, Bool, Seq Double)) ->
                             case w1 of { (ww10, ww11, ww12) ->
                             case ww10 `cast` <Co:3> of { V2 ww14 ww15 ->
                             case ww14 of { D# ww17 ->
                             case ww15 of { D# ww19 -> $wf a3 w ww17 ww19 ww11 ww12 }
                             }
                             }
                             })
                        `cast` <Co:180>)
                       (id `cast` <Co:27>)
                       (ww `cast` <Co:4>))
                    `cast` <Co:25>)
                     (let {
                        w :: Segment V2 Double
                        w = case ww3 of {
                              LinearClosing ->
                                Linear (V2 (D# (negateDouble# ww1)) (D# (negateDouble# ww2)));
                              CubicClosing c1 c2 ->
                                Cubic c1 c2 (V2 (D# (negateDouble# ww1)) (D# (negateDouble# ww2)))
                            } } in
                      (\ (w1 :: (Point V2 Double, Bool, Seq Double)) ->
                         case w1 of { (ww10, ww11, ww12) ->
                         case ww10 `cast` <Co:3> of { V2 ww14 ww15 ->
                         case ww14 of { D# ww17 ->
                         case ww15 of { D# ww19 ->
                         $wf w (id `cast` <Co:9>) ww17 ww19 ww11 ww12
                         }
                         }
                         }
                         })
                      `cast` <Co:139>))
                  `cast` <Co:8>)
                   lvl51
            of
            { (a3, b4, c1) ->
            c1
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            } } in
      case tagToEnum# (>## ww6 0.0##) of {
        False ->
          join {
            $j1 :: Seq Double
            $j1
              = join {
                  $j2 :: Seq Double
                  $j2
                    = join {
                        $j3 :: Seq Double
                        $j3
                          = case tagToEnum# (==## ww7 0.0##) of {
                              False -> jump $w$j (+## ww6 ww7);
                              True ->
                                case tagToEnum# (<## ww6 0.0##) of {
                                  False ->
                                    case tagToEnum# (==## ww6 0.0##) of {
                                      False -> jump $w$j (+## ww6 ww7);
                                      True -> jump $w$j ww7
                                    };
                                  True -> jump $w$j 3.141592653589793##
                                }
                            } } in
                      case tagToEnum# (<=## ww6 0.0##) of {
                        False -> jump $j3;
                        True ->
                          case tagToEnum# (<## ww7 0.0##) of {
                            False -> jump $j3;
                            True ->
                              case tagToEnum# (==## ww6 0.0##) of {
                                False ->
                                  case /## (negateDouble# ww7) ww6 of wild7 { __DEFAULT ->
                                  jump $w$j
                                    (negateDouble# (+## 3.141592653589793## (atanDouble# wild7)))
                                  };
                                True -> jump $w$j -1.5707963267948966##
                              }
                          }
                      } } in
                case tagToEnum# (<## ww6 0.0##) of {
                  False -> jump $j2;
                  True ->
                    case tagToEnum# (>## ww7 0.0##) of {
                      False -> jump $j2;
                      True ->
                        case /## ww7 ww6 of wild4 { __DEFAULT ->
                        jump $w$j (+## 3.141592653589793## (atanDouble# wild4))
                        }
                    }
                } } in
          case tagToEnum# (==## ww6 0.0##) of {
            False -> jump $j1;
            True ->
              case tagToEnum# (>## ww7 0.0##) of {
                False -> jump $j1;
                True -> jump $w$j 1.5707963267948966##
              }
          };
        True ->
          case /## ww7 ww6 of wild4 { __DEFAULT ->
          jump $w$j (atanDouble# wild4)
          }
      }

-- RHS size: {terms: 45, types: 50, coercions: 3, joins: 0/0}
loopTrace_$sloopTrace
  :: Loop V2 Double -> Point V2 Double -> V2 Double -> Seq Double
loopTrace_$sloopTrace
  = \ (w :: Loop V2 Double)
      (w1 :: Point V2 Double)
      (w2 :: V2 Double) ->
      case w of { Loop ww1 ww2 ->
      case ww1 of { Line ww4 ww5 ->
      case ww5 of { V2 ww7 ww8 ->
      case ww7 of { D# ww10 ->
      case ww8 of { D# ww12 ->
      case w1 `cast` <Co:3> of { V2 ww14 ww15 ->
      case ww14 of { D# ww17 ->
      case ww15 of { D# ww19 ->
      case w2 of { V2 ww21 ww22 ->
      case ww21 of { D# ww24 ->
      case ww22 of { D# ww26 ->
      $w$sloopTrace ww4 ww10 ww12 ww2 ww17 ww19 ww24 ww26
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl54 :: Integer
lvl54 = 999

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl55 :: Integer
lvl55 = 1000

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
lvl56 :: Ratio Integer
lvl56 = :% lvl54 lvl55

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl57 :: Integer
lvl57 = 1001

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
lvl58 :: Ratio Integer
lvl58 = :% lvl57 lvl55

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl59 :: Integer
lvl59 = 100000000

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
lvl60 :: Ratio Integer
lvl60 = :% lineVertices3 lvl59

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl61 :: Integer
lvl61 = 6

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl62 :: Integer
lvl62 = 9

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl63 :: Integer
lvl63 = 27

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl64 :: Integer
lvl64 = 18

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl65 :: Integer
lvl65 = 4

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl66 :: Integer
lvl66 = 10000

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
lvl67 :: Ratio Integer
lvl67 = :% lineVertices3 lvl66

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl68 :: Integer
lvl68 = 10001

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
lvl69 :: Ratio Integer
lvl69 = :% lvl68 lvl66

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl70 :: Integer
lvl70 = 9999

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
lvl71 :: Ratio Integer
lvl71 = :% lvl70 lvl66

-- RHS size: {terms: 1,892,
              types: 1,165,
              coercions: 784,
              joins: 12/102}
$wloopTrace
  :: forall n.
     OrderedField n =>
     Seq (Segment V2 n)
     -> n -> n -> ClosingSegment V2 n -> n -> n -> n -> n -> Seq n
$wloopTrace
  = \ (@ n)
      (w :: OrderedField n)
      (ww
         :: Seq (Segment V2 n)
         Unf=OtherCon [])
      (ww1
         :: n
         Unf=OtherCon [])
      (ww2
         :: n
         Unf=OtherCon [])
      (ww3
         :: ClosingSegment V2 n
         Unf=OtherCon [])
      (ww4
         :: n
         Unf=OtherCon [])
      (ww5
         :: n
         Unf=OtherCon [])
      (ww6
         :: n
         Unf=OtherCon [])
      (ww7
         :: n
         Unf=OtherCon []) ->
      let {
        $dOrd1 :: Ord n
        $dOrd1 = $p2(%,%) w } in
      let {
        $dFloating1 :: Floating n
        $dFloating1 = $p1(%,%) w } in
      let {
        $dFractional1 :: Fractional n
        $dFractional1 = $p1Floating $dFloating1 } in
      let {
        $dNum1 :: Num n
        $dNum1 = $p1Fractional $dFractional1 } in
      join {
        $j :: n -> Seq n
        $j (nt :: n)
          = let {
              theta :: n
              theta = negate $dNum1 nt } in
            case cos $dFloating1 theta of dt7 { __DEFAULT ->
            let {
              s1 :: n
              s1 = sin $dFloating1 theta } in
            case negate $dNum1 s1 of dt8 { __DEFAULT ->
            case s1 of dt9 { __DEFAULT ->
            case fromInteger $dNum1 lvl4 of dt10 { __DEFAULT ->
            case fromInteger $dNum1 lineVertices3 of dt11 { __DEFAULT ->
            let {
              s :: n
              s = / $dFractional1
                    dt11
                    (sqrt $dFloating1 ($w$cquadrance $dNum1 ww6 ww7)) } in
            let {
              f3 :: n -> n
              f3 = * $dNum1 s } in
            case f3 dt11 of dt12 { __DEFAULT ->
            case f3 dt10 of dt13 { __DEFAULT ->
            case / $dFractional1 dt11 s of dt14 { __DEFAULT ->
            case / $dFractional1 dt10 s of dt15 { __DEFAULT ->
            case negate $dNum1 ww4 of dt16 { __DEFAULT ->
            case negate $dNum1 ww5 of dt17 { __DEFAULT ->
            case $wtappend
                   $fAdditiveV2
                   $fFoldableV2
                   $dNum1
                   (V2 (V2 dt7 dt8) (V2 dt9 dt7))
                   (V2 (V2 dt7 dt9) (V2 dt8 dt7))
                   (V2 dt10 dt10)
                   (V2 (V2 dt11 dt10) (V2 dt10 dt11))
                   (V2 (V2 dt11 dt10) (V2 dt10 dt11))
                   (V2 dt16 dt17)
            of
            { (# ww9, ww10, ww11 #) ->
            case $wtappend
                   $fAdditiveV2
                   $fFoldableV2
                   $dNum1
                   (V2 (V2 dt12 dt13) (V2 dt13 dt12))
                   (V2 (V2 dt14 dt15) (V2 dt15 dt14))
                   (V2 dt10 dt10)
                   ww9
                   ww10
                   ww11
            of
            { (# ww15, ww16, ww17 #) ->
            case ww15 of { V2 a5 b3 ->
            case a5 of { V2 ww19 ww20 ->
            case b3 of { V2 ww22 ww23 ->
            case ww17 of { V2 d e ->
            let {
              $dEq :: Eq n
              $dEq = $p1Ord $dOrd1 } in
            let {
              lvl77 :: n
              lvl77 = fromInteger $dNum1 lvl20 } in
            let {
              lvl78 :: n
              lvl78 = fromInteger $dNum1 lvl } in
            let {
              lvl79 :: n
              lvl79 = fromInteger $dNum1 lvl65 } in
            let {
              lvl80 :: n
              lvl80 = fromInteger $dNum1 lvl62 } in
            let {
              lvl81 :: n
              lvl81 = / $dFractional1 dt11 lvl77 } in
            let {
              lvl82 :: n
              lvl82 = / $dFractional1 dt11 lvl78 } in
            let {
              lvl83 :: n
              lvl83 = fromInteger $dNum1 lvl63 } in
            let {
              lvl84 :: n
              lvl84 = fromInteger $dNum1 lvl64 } in
            let {
              lvl85 :: n
              lvl85 = tau $dFloating1 } in
            let {
              lvl86 :: [n]
              lvl86 = : dt10 [] } in
            let {
              lvl87 :: n
              lvl87 = fromInteger $dNum1 lvl61 } in
            let {
              lvl88 :: n
              lvl88 = fromRational $dFractional1 lvl56 } in
            let {
              lvl89 :: n
              lvl89 = fromRational $dFractional1 lvl58 } in
            let {
              toler :: n
              toler = fromRational $dFractional1 lvl60 } in
            let {
              lvl90 :: n
              lvl90 = fromRational $dFractional1 lvl67 } in
            let {
              ds9 :: n
              ds9 = fromRational $dFractional1 lvl69 } in
            let {
              ds8 :: n
              ds8 = fromRational $dFractional1 lvl71 } in
            let {
              $wf
                :: Segment V2 n
                   -> Endo (Point V2 n, Bool, Seq n)
                   -> n
                   -> n
                   -> Bool
                   -> Seq n
                   -> (Point V2 n, Bool, Seq n)
              $wf
                = \ (w1 :: Segment V2 n)
                    (w2 :: Endo (Point V2 n, Bool, Seq n))
                    (ww24
                       :: n
                       Unf=OtherCon [])
                    (ww25
                       :: n
                       Unf=OtherCon [])
                    (ww26 :: Bool)
                    (ww27 :: Seq n) ->
                    case ww26 of _nearStart1 { __DEFAULT ->
                    case ww27 `cast` <Co:2> of nt2 { __DEFAULT ->
                    case w1 of {
                      Linear w3 ->
                        case w3 of { V2 x5 y2 ->
                        let {
                          x4 :: n
                          x4 = - $dNum1 (* $dNum1 ww6 y2) (* $dNum1 ww7 x5) } in
                        let {
                          pq :: V2 n
                          pq
                            = case $w$c^-^ $dNum1 ww24 ww25 ww4 ww5 of { (# ww29, ww30 #) ->
                              V2 ww29 ww30
                              } } in
                        let {
                          x3 :: n
                          x3
                            = case pq of { V2 x1 y1 ->
                              - $dNum1 (* $dNum1 x1 ww7) (* $dNum1 y1 ww6)
                              } } in
                        join {
                          $j1 :: (Point V2 n, Bool, Seq n)
                          $j1
                            = (w2 `cast` <Co:8>)
                                (case + $dNum1 ww24 of dt18 { __DEFAULT ->
                                 case + $dNum1 ww25 of dt19 { __DEFAULT ->
                                 case dt18 x5 of dt20 { __DEFAULT ->
                                 case dt19 y2 of dt21 { __DEFAULT -> (V2 dt20 dt21) `cast` <Co:37> }
                                 }
                                 }
                                 },
                                 False, nt2 `cast` <Co:3>) } in
                        join {
                          $j2 :: (Point V2 n, Bool, Seq n)
                          $j2
                            = let {
                                tw :: n
                                tw = / $dFractional1 x3 x4 } in
                              case >= $dOrd1 tw dt10 of {
                                False -> jump $j1;
                                True ->
                                  case <= $dOrd1 tw lvl89 of {
                                    False -> jump $j1;
                                    True ->
                                      (w2 `cast` <Co:8>)
                                        (case + $dNum1 ww24 of dt18 { __DEFAULT ->
                                         case + $dNum1 ww25 of dt19 { __DEFAULT ->
                                         case dt18 x5 of dt20 { __DEFAULT ->
                                         case dt19 y2 of dt21 { __DEFAULT ->
                                         (V2 dt20 dt21) `cast` <Co:37>
                                         }
                                         }
                                         }
                                         },
                                         > $dOrd1 tw lvl88,
                                         ($b:|>_$ssnocTree
                                            nt2
                                            ((/ $dFractional1
                                                (case pq of { V2 x1 y1 ->
                                                 - $dNum1 (* $dNum1 x1 y2) (* $dNum1 y1 x5)
                                                 })
                                                x4)
                                             `cast` <Co:20>))
                                         `cast` <Co:130>)
                                  }
                              } } in
                        case == $dEq x4 dt10 of {
                          False -> jump $j2;
                          True ->
                            case /= $dEq x3 dt10 of {
                              False -> jump $j2;
                              True -> jump $j1
                            }
                        }
                        };
                      Cubic ipv5 ipv6 ipv7 ->
                        case ipv7 of { V2 d1 e1 ->
                        case ipv6 of { V2 d2 e2 ->
                        case ipv5 of { V2 d3 e3 ->
                        (w2 `cast` <Co:8>)
                          (let {
                             ds4 :: (V2 n, n)
                             ds4
                               = let {
                                   $wf3 :: n -> n -> Sum n
                                   $wf3
                                     = \ (ww28
                                            :: n
                                            Unf=OtherCon [])
                                         (ww29
                                            :: n
                                            Unf=OtherCon []) ->
                                         case * $dNum1 ww28 of dt18 { __DEFAULT ->
                                         case * $dNum1 ww29 of dt19 { __DEFAULT ->
                                         case dt18 d1 of dt20 { __DEFAULT ->
                                         case dt19 e1 of dt21 { __DEFAULT ->
                                         (+ $dNum1 dt20 dt21) `cast` <Co:3>
                                         }
                                         }
                                         }
                                         } } in
                                 case ($wf3 ww19 ww20) `cast` <Co:2> of dt18 { __DEFAULT ->
                                 case ($wf3 ww22 ww23) `cast` <Co:2> of dt19 { __DEFAULT ->
                                 (V2 dt18 dt19, dt19)
                                 }
                                 } } in
                           let {
                             ds5 :: (V2 n, n)
                             ds5
                               = let {
                                   $wf3 :: n -> n -> Sum n
                                   $wf3
                                     = \ (ww28
                                            :: n
                                            Unf=OtherCon [])
                                         (ww29
                                            :: n
                                            Unf=OtherCon []) ->
                                         case * $dNum1 ww28 of dt18 { __DEFAULT ->
                                         case * $dNum1 ww29 of dt19 { __DEFAULT ->
                                         case dt18 d2 of dt20 { __DEFAULT ->
                                         case dt19 e2 of dt21 { __DEFAULT ->
                                         (+ $dNum1 dt20 dt21) `cast` <Co:3>
                                         }
                                         }
                                         }
                                         } } in
                                 case ($wf3 ww19 ww20) `cast` <Co:2> of dt18 { __DEFAULT ->
                                 case ($wf3 ww22 ww23) `cast` <Co:2> of dt19 { __DEFAULT ->
                                 (V2 dt18 dt19, dt19)
                                 }
                                 } } in
                           let {
                             ds6 :: (V2 n, n)
                             ds6
                               = let {
                                   $wf3 :: n -> n -> Sum n
                                   $wf3
                                     = \ (ww28
                                            :: n
                                            Unf=OtherCon [])
                                         (ww29
                                            :: n
                                            Unf=OtherCon []) ->
                                         case * $dNum1 ww28 of dt18 { __DEFAULT ->
                                         case * $dNum1 ww29 of dt19 { __DEFAULT ->
                                         case dt18 d3 of dt20 { __DEFAULT ->
                                         case dt19 e3 of dt21 { __DEFAULT ->
                                         (+ $dNum1 dt20 dt21) `cast` <Co:3>
                                         }
                                         }
                                         }
                                         } } in
                                 case ($wf3 ww19 ww20) `cast` <Co:2> of dt18 { __DEFAULT ->
                                 case ($wf3 ww22 ww23) `cast` <Co:2> of dt19 { __DEFAULT ->
                                 (V2 dt18 dt19, dt19)
                                 }
                                 } } in
                           let {
                             ds7 :: (n, n)
                             ds7
                               = let {
                                   $wf4 :: n -> n -> Sum n
                                   $wf4
                                     = \ (ww28
                                            :: n
                                            Unf=OtherCon [])
                                         (ww29
                                            :: n
                                            Unf=OtherCon []) ->
                                         case * $dNum1 ww28 of dt18 { __DEFAULT ->
                                         case * $dNum1 ww29 of dt19 { __DEFAULT ->
                                         case dt18 ww24 of dt20 { __DEFAULT ->
                                         case dt19 ww25 of dt21 { __DEFAULT ->
                                         (+ $dNum1 dt20 dt21) `cast` <Co:3>
                                         }
                                         }
                                         }
                                         } } in
                                 case ($wf4 ww19 ww20) `cast` <Co:2> of dt18 { __DEFAULT ->
                                 case ($wf4 ww22 ww23) `cast` <Co:2> of dt19 { __DEFAULT ->
                                 case + $dNum1 dt18 of dt20 { __DEFAULT ->
                                 case + $dNum1 dt19 of dt21 { __DEFAULT ->
                                 case dt20 d of dt22 { __DEFAULT ->
                                 case dt21 e of dt23 { __DEFAULT -> (dt22, dt23) }
                                 }
                                 }
                                 }
                                 }
                                 } } in
                           let {
                             tcs :: [n]
                             tcs
                               = let {
                                   y1 :: n
                                   y1 = case ds6 of { (c1', y4) -> y4 } } in
                                 let {
                                   y2 :: n
                                   y2 = case ds5 of { (c2', y4) -> y4 } } in
                                 let {
                                   a :: n
                                   a = + $dNum1
                                         (- $dNum1 (* $dNum1 lvl77 y1) (* $dNum1 lvl77 y2))
                                         (case ds4 of { (c3', y3) -> y3 }) } in
                                 let {
                                   d4 :: n
                                   d4 = case ds7 of { (qx, qy) -> qy } } in
                                 let {
                                   b :: n
                                   b = + $dNum1
                                         (negate $dNum1 (* $dNum1 lvl87 y1))
                                         (* $dNum1 lvl77 y2) } in
                                 let {
                                   c1 :: n
                                   c1 = * $dNum1 lvl77 y1 } in
                                 let {
                                   ds1 :: n
                                   ds1
                                     = case _nearStart1 of {
                                         False -> dt10;
                                         True -> lvl90
                                       } } in
                                 let {
                                   arg :: n -> Bool
                                   arg
                                     = \ (x3 :: n) ->
                                         case >= $dOrd1 x3 ds1 of {
                                           False -> False;
                                           True -> <= $dOrd1 x3 ds9
                                         } } in
                                 case < $dOrd1 (abs $dNum1 a) toler of {
                                   False ->
                                     let {
                                       delta :: n
                                       delta
                                         = - $dNum1
                                             (- $dNum1
                                                (+ $dNum1
                                                   (- $dNum1
                                                      (* $dNum1
                                                         (* $dNum1
                                                            (* $dNum1 (* $dNum1 lvl84 a) b)
                                                            c1)
                                                         d4)
                                                      (* $dNum1
                                                         (* $dNum1
                                                            lvl79
                                                            (* $dNum1 (* $dNum1 b b) b))
                                                         d4))
                                                   (* $dNum1 (* $dNum1 b b) (* $dNum1 c1 c1)))
                                                (* $dNum1
                                                   (* $dNum1 lvl79 a)
                                                   (* $dNum1 (* $dNum1 c1 c1) c1)))
                                             (* $dNum1
                                                (* $dNum1 lvl83 (* $dNum1 a a))
                                                (* $dNum1 d4 d4)) } in
                                     let {
                                       xx :: n
                                       xx
                                         = + $dNum1
                                             (- $dNum1
                                                (* $dNum1 lvl78 (* $dNum1 (* $dNum1 b b) b))
                                                (* $dNum1 (* $dNum1 (* $dNum1 lvl80 a) b) c1))
                                             (* $dNum1 (* $dNum1 lvl83 (* $dNum1 a a)) d4) } in
                                     let {
                                       disc :: n
                                       disc
                                         = - $dNum1
                                             (* $dNum1 (* $dNum1 lvl77 a) c1)
                                             (* $dNum1 b b) } in
                                     case > $dOrd1 delta dt10 of {
                                       False ->
                                         join {
                                           $j1 :: [n]
                                           $j1
                                             = join {
                                                 $j2 :: [n]
                                                 $j2
                                                   = let {
                                                       x :: n
                                                       x = let {
                                                             cc :: n
                                                             cc
                                                               = let {
                                                                   x3 :: n
                                                                   x3
                                                                     = * $dNum1
                                                                         lvl82
                                                                         (+ $dNum1
                                                                            (let {
                                                                               qq :: n
                                                                               qq
                                                                                 = sqrt
                                                                                     $dFloating1
                                                                                     (negate
                                                                                        $dNum1
                                                                                        (* $dNum1
                                                                                           (* $dNum1
                                                                                              lvl83
                                                                                              (* $dNum1
                                                                                                 a
                                                                                                 a))
                                                                                           delta)) } in
                                                                             case < $dOrd1
                                                                                    (abs
                                                                                       $dNum1 disc)
                                                                                    toler
                                                                             of {
                                                                               False -> qq;
                                                                               True ->
                                                                                 let {
                                                                                   xs :: n
                                                                                   xs
                                                                                     = negate
                                                                                         $dNum1
                                                                                         qq } in
                                                                                 case compare
                                                                                        $dOrd1
                                                                                        (abs
                                                                                           $dNum1
                                                                                           (+ $dNum1
                                                                                              qq
                                                                                              xx))
                                                                                        (abs
                                                                                           $dNum1
                                                                                           (+ $dNum1
                                                                                              xs
                                                                                              xx))
                                                                                 of {
                                                                                   __DEFAULT -> xs;
                                                                                   GT -> qq
                                                                                 }
                                                                             })
                                                                            xx) } in
                                                                 case < $dOrd1 x3 dt10 of {
                                                                   False -> ** $dFloating1 x3 lvl81;
                                                                   True ->
                                                                     negate
                                                                       $dNum1
                                                                       (**
                                                                          $dFloating1
                                                                          (negate $dNum1 x3)
                                                                          lvl81)
                                                                 } } in
                                                           + $dNum1
                                                             (- $dNum1
                                                                (negate
                                                                   $dNum1
                                                                   (/ $dFractional1
                                                                      b
                                                                      (* $dNum1 lvl77 a)))
                                                                (/ $dFractional1
                                                                   cc
                                                                   (* $dNum1 lvl77 a)))
                                                             (/ $dFractional1
                                                                disc
                                                                (* $dNum1
                                                                   (* $dNum1 lvl77 a)
                                                                   cc)) } in
                                                     case arg x of {
                                                       False -> [];
                                                       True -> : x []
                                                     } } in
                                               case == $dEq delta dt10 of {
                                                 False -> jump $j2;
                                                 True ->
                                                   case /= $dEq disc dt10 of {
                                                     False -> jump $j2;
                                                     True ->
                                                       let {
                                                         x :: n
                                                         x = / $dFractional1
                                                               (- $dNum1
                                                                  (* $dNum1 b c1)
                                                                  (* $dNum1 (* $dNum1 lvl80 a) d4))
                                                               (* $dNum1 lvl78 disc) } in
                                                       let {
                                                         r :: [n]
                                                         r = let {
                                                               x1 :: n
                                                               x1
                                                                 = / $dFractional1
                                                                     (+ $dNum1
                                                                        (- $dNum1
                                                                           (* $dNum1
                                                                              (* $dNum1
                                                                                 lvl80
                                                                                 (* $dNum1 a a))
                                                                              d4)
                                                                           (* $dNum1
                                                                              (* $dNum1
                                                                                 (* $dNum1 lvl79 a)
                                                                                 b)
                                                                              c1))
                                                                        (* $dNum1 (* $dNum1 b b) b))
                                                                     (* $dNum1 a disc) } in
                                                             case arg x1 of {
                                                               False -> [];
                                                               True -> : x1 []
                                                             } } in
                                                       case arg x of {
                                                         False -> r;
                                                         True -> : x r
                                                       }
                                                   }
                                               } } in
                                         case == $dEq delta dt10 of {
                                           False -> jump $j1;
                                           True ->
                                             case == $dEq disc dt10 of {
                                               False -> jump $j1;
                                               True ->
                                                 let {
                                                   x :: n
                                                   x = negate
                                                         $dNum1
                                                         (/ $dFractional1 b (* $dNum1 lvl77 a)) } in
                                                 case arg x of {
                                                   False -> [];
                                                   True -> : x []
                                                 }
                                             }
                                         };
                                       True ->
                                         let {
                                           lvl91 :: n
                                           lvl91 = / $dFractional1 b (* $dNum1 lvl77 a) } in
                                         let {
                                           p1 :: n
                                           p1
                                             = / $dFractional1
                                                 disc
                                                 (* $dNum1 lvl77 (* $dNum1 a a)) } in
                                         let {
                                           lvl92 :: n
                                           lvl92
                                             = * $dNum1
                                                 lvl78
                                                 (sqrt
                                                    $dFloating1
                                                    (negate $dNum1 (/ $dFractional1 p1 lvl77))) } in
                                         let {
                                           phi :: n
                                           phi
                                             = * $dNum1
                                                 lvl81
                                                 (acos
                                                    $dFloating1
                                                    (* $dNum1
                                                       (/ $dFractional1
                                                          (* $dNum1
                                                             lvl77
                                                             (/ $dFractional1
                                                                xx
                                                                (* $dNum1
                                                                   lvl83
                                                                   (* $dNum1 (* $dNum1 a a) a))))
                                                          (* $dNum1 lvl78 p1))
                                                       (sqrt
                                                          $dFloating1
                                                          (negate
                                                             $dNum1
                                                             (/ $dFractional1 lvl77 p1))))) } in
                                         let {
                                           c3 :: n -> n
                                           c3
                                             = \ (k :: n) ->
                                                 - $dNum1
                                                   (* $dNum1
                                                      lvl92
                                                      (cos
                                                         $dFloating1
                                                         (- $dNum1
                                                            phi
                                                            (/ $dFractional1
                                                               (* $dNum1 k lvl85)
                                                               lvl77))))
                                                   lvl91 } in
                                         let {
                                           x :: n
                                           x = c3 dt10 } in
                                         let {
                                           r :: [n]
                                           r = let {
                                                 x1 :: n
                                                 x1 = c3 dt11 } in
                                               let {
                                                 r1 :: [n]
                                                 r1
                                                   = let {
                                                       x2 :: n
                                                       x2 = c3 lvl78 } in
                                                     case arg x2 of {
                                                       False -> [];
                                                       True -> : x2 []
                                                     } } in
                                               case arg x1 of {
                                                 False -> r1;
                                                 True -> : x1 r1
                                               } } in
                                         case arg x of {
                                           False -> r;
                                           True -> : x r
                                         }
                                     };
                                   True ->
                                     join {
                                       $j1 :: [n]
                                       $j1
                                         = join {
                                             $j2 :: [n]
                                             $j2
                                               = case == $dEq b dt10 of {
                                                   False ->
                                                     let {
                                                       d5 :: n
                                                       d5
                                                         = - $dNum1
                                                             (* $dNum1 c1 c1)
                                                             (* $dNum1 (* $dNum1 lvl79 b) d4) } in
                                                     case < $dOrd1 d5 dt10 of {
                                                       False ->
                                                         case == $dEq c1 dt10 of {
                                                           False ->
                                                             case == $dEq d5 dt10 of {
                                                               False ->
                                                                 let {
                                                                   q1 :: n
                                                                   q1
                                                                     = negate
                                                                         $dNum1
                                                                         (* $dNum1
                                                                            lvl82
                                                                            (+ $dNum1
                                                                               c1
                                                                               (* $dNum1
                                                                                  (signum $dNum1 c1)
                                                                                  (sqrt
                                                                                     $dFloating1
                                                                                     d5)))) } in
                                                                 let {
                                                                   x :: n
                                                                   x = / $dFractional1 q1 b } in
                                                                 let {
                                                                   r :: [n]
                                                                   r = let {
                                                                         x1 :: n
                                                                         x1
                                                                           = / $dFractional1
                                                                               d4
                                                                               q1 } in
                                                                       case arg x1 of {
                                                                         False -> [];
                                                                         True -> : x1 []
                                                                       } } in
                                                                 case arg x of {
                                                                   False -> r;
                                                                   True -> : x r
                                                                 };
                                                               True ->
                                                                 let {
                                                                   x :: n
                                                                   x = negate
                                                                         $dNum1
                                                                         (/ $dFractional1
                                                                            c1
                                                                            (* $dNum1 lvl78 b)) } in
                                                                 case arg x of {
                                                                   False -> [];
                                                                   True -> : x []
                                                                 }
                                                             };
                                                           True ->
                                                             let {
                                                               x :: n
                                                               x = sqrt
                                                                     $dFloating1
                                                                     (negate
                                                                        $dNum1
                                                                        (/ $dFractional1 d4 b)) } in
                                                             let {
                                                               r :: [n]
                                                               r = let {
                                                                     x1 :: n
                                                                     x1 = negate $dNum1 x } in
                                                                   case arg x1 of {
                                                                     False -> [];
                                                                     True -> : x1 []
                                                                   } } in
                                                             case arg x of {
                                                               False -> r;
                                                               True -> : x r
                                                             }
                                                         };
                                                       True -> []
                                                     };
                                                   True ->
                                                     let {
                                                       x :: n
                                                       x = negate
                                                             $dNum1 (/ $dFractional1 d4 c1) } in
                                                     case arg x of {
                                                       False -> [];
                                                       True -> : x []
                                                     }
                                                 } } in
                                           case == $dEq b dt10 of {
                                             False -> jump $j2;
                                             True ->
                                               case == $dEq c1 dt10 of {
                                                 False -> jump $j2;
                                                 True -> []
                                               }
                                           } } in
                                     case == $dEq b dt10 of {
                                       False -> jump $j1;
                                       True ->
                                         case == $dEq c1 dt10 of {
                                           False -> jump $j1;
                                           True ->
                                             case == $dEq d4 dt10 of {
                                               False -> jump $j1;
                                               True ->
                                                 case arg dt10 of {
                                                   False -> [];
                                                   True -> lvl86
                                                 }
                                             }
                                         }
                                     }
                                 } } in
                           (case + $dNum1 ww24 of dt18 { __DEFAULT ->
                            case + $dNum1 ww25 of dt19 { __DEFAULT ->
                            case dt18 d1 of dt20 { __DEFAULT ->
                            case dt19 e1 of dt21 { __DEFAULT -> (V2 dt20 dt21) `cast` <Co:37> }
                            }
                            }
                            },
                            joinrec {
                              go1 :: [n] -> Bool
                              go1 (ds :: [n])
                                = case ds of {
                                    [] -> False;
                                    : y ys ->
                                      case > $dOrd1 y ds8 of {
                                        False -> jump go1 ys;
                                        True -> True
                                      }
                                  }; } in
                            jump go1 tcs,
                            ($fAlternativeSeq2
                               (nt2 `cast` <Co:3>)
                               (($fIsListSeq_mkTree
                                   ((map
                                       (let {
                                          ds1 :: n
                                          ds1 = case ds7 of { (qx, qy) -> qx } } in
                                        let {
                                          g :: Segment V2 n
                                          g = case ds6 of { (c1', y4) ->
                                              case ds5 of { (c2', y5) ->
                                              case ds4 of { (c3', y3) ->
                                              case c1' of dt18 { V2 ipv ipv1 ->
                                              case c2' of dt19 { V2 ipv2 ipv3 ->
                                              case c3' of dt20 { V2 ipv4 ipv8 ->
                                              Cubic dt18 dt19 dt20
                                              }
                                              }
                                              }
                                              }
                                              }
                                              } } in
                                        \ (x3 :: n) ->
                                          + $dNum1
                                            (case g of {
                                               Linear x4 ->
                                                 case x4 of { V2 a1 b1 ->
                                                 let {
                                                   f4 :: n -> n
                                                   f4 = * $dNum1 x3 } in
                                                 case f4 a1 of dt18 { __DEFAULT ->
                                                 case f4 b1 of { __DEFAULT -> dt18 }
                                                 }
                                                 };
                                               Cubic c2 c3 x4 ->
                                                 case x4 of { V2 a1 b1 ->
                                                 case c3 of { V2 a2 b2 ->
                                                 case c2 of { V2 a3 b4 ->
                                                 let {
                                                   t' :: n
                                                   t' = - $dNum1 dt11 x3 } in
                                                 let {
                                                   f4 :: n -> n
                                                   f4
                                                     = * $dNum1
                                                         (* $dNum1
                                                            (* $dNum1 (* $dNum1 lvl77 t') t')
                                                            x3) } in
                                                 case f4 a3 of dt18 { __DEFAULT ->
                                                 case f4 b4 of dt19 { __DEFAULT ->
                                                 case + $dNum1 dt18 of dt20 { __DEFAULT ->
                                                 case + $dNum1 dt19 of dt21 { __DEFAULT ->
                                                 let {
                                                   f5 :: n -> n
                                                   f5
                                                     = * $dNum1
                                                         (* $dNum1
                                                            (* $dNum1 (* $dNum1 lvl77 t') x3)
                                                            x3) } in
                                                 case f5 a2 of dt22 { __DEFAULT ->
                                                 case f5 b2 of dt23 { __DEFAULT ->
                                                 case dt20 dt22 of dt24 { __DEFAULT ->
                                                 case dt21 dt23 of dt25 { __DEFAULT ->
                                                 case + $dNum1 dt24 of dt26 { __DEFAULT ->
                                                 case + $dNum1 dt25 of dt27 { __DEFAULT ->
                                                 let {
                                                   f6 :: n -> n
                                                   f6 = * $dNum1 (* $dNum1 (* $dNum1 x3 x3) x3) } in
                                                 case f6 a1 of dt28 { __DEFAULT ->
                                                 case f6 b1 of dt29 { __DEFAULT ->
                                                 case dt26 dt28 of dt30 { __DEFAULT ->
                                                 case dt27 dt29 of { __DEFAULT -> dt30 }
                                                 }
                                                 }
                                                 }
                                                 }
                                                 }
                                                 }
                                                 }
                                                 }
                                                 }
                                                 }
                                                 }
                                                 }
                                                 }
                                                 }
                                                 }
                                                 }
                                             })
                                            ds1)
                                       tcs)
                                    `cast` <Co:15>))
                                `cast` <Co:15>))
                            `cast` <Co:3>))
                        }
                        }
                        }
                    }
                    }
                    } } in
            case (((($fEq1Seq_$cfoldr
                       ((\ (a1 :: Segment V2 n)
                           (fa
                              :: Const (Endo (Endo (Point V2 n, Bool, Seq n))) (Segment V2 n))
                           (eta :: Endo (Point V2 n, Bool, Seq n)) ->
                           let {
                             w1 :: Endo (Point V2 n, Bool, Seq n)
                             w1 = (fa `cast` <Co:25>) eta } in
                           \ (w2 :: (Point V2 n, Bool, Seq n)) ->
                             case w2 of { (ww25, ww26, ww27) ->
                             case ww25 `cast` <Co:3> of { V2 ww29 ww30 ->
                             $wf a1 w1 ww29 ww30 ww26 ww27
                             }
                             })
                        `cast` <Co:180>)
                       (id `cast` <Co:27>)
                       (ww `cast` <Co:4>))
                    `cast` <Co:25>)
                     (let {
                        w1 :: Segment V2 n
                        w1
                          = case ww3 of {
                              LinearClosing ->
                                case negate $dNum1 ww1 of dt18 { __DEFAULT ->
                                case negate $dNum1 ww2 of dt19 { __DEFAULT ->
                                Linear (V2 dt18 dt19)
                                }
                                };
                              CubicClosing c1 c2 ->
                                case negate $dNum1 ww1 of dt18 { __DEFAULT ->
                                case negate $dNum1 ww2 of dt19 { __DEFAULT ->
                                Cubic c1 c2 (V2 dt18 dt19)
                                }
                                }
                            } } in
                      (\ (w2 :: (Point V2 n, Bool, Seq n)) ->
                         case w2 of { (ww25, ww26, ww27) ->
                         case ww25 `cast` <Co:3> of { V2 ww29 ww30 ->
                         $wf w1 (id `cast` <Co:9>) ww29 ww30 ww26 ww27
                         }
                         })
                      `cast` <Co:139>))
                  `cast` <Co:8>)
                   ((V2 dt10 dt10) `cast` <Co:4>, False, EmptyT `cast` <Co:3>)
            of
            { (a1, b1, c1) ->
            c1
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            } } in
      case > $dOrd1 ww6 (fromInteger $dNum1 lvl4) of {
        False ->
          let {
            $dEq1 :: Eq n
            $dEq1 = $p1Ord $dOrd1 } in
          join {
            $j1 :: Seq n
            $j1
              = join {
                  $j2 :: Seq n
                  $j2
                    = join {
                        $j3 :: Seq n
                        $j3
                          = join {
                              $j4 :: Seq n
                              $j4
                                = case == $dEq1 ww6 (fromInteger $dNum1 lvl4) of {
                                    False ->
                                      case + $dNum1 ww6 ww7 of nt { __DEFAULT -> jump $j nt };
                                    True ->
                                      case == $dEq1 ww7 (fromInteger $dNum1 lvl4) of {
                                        False ->
                                          case + $dNum1 ww6 ww7 of nt { __DEFAULT -> jump $j nt };
                                        True -> jump $j ww7
                                      }
                                  } } in
                            case == $dEq1 ww7 (fromInteger $dNum1 lvl4) of {
                              False -> jump $j4;
                              True ->
                                case < $dOrd1 ww6 (fromInteger $dNum1 lvl4) of {
                                  False -> jump $j4;
                                  True -> case pi $dFloating1 of nt { __DEFAULT -> jump $j nt }
                                }
                            } } in
                      case <= $dOrd1 ww6 (fromInteger $dNum1 lvl4) of {
                        False -> jump $j3;
                        True ->
                          case < $dOrd1 ww7 (fromInteger $dNum1 lvl4) of {
                            False -> jump $j3;
                            True ->
                              case negate
                                     $dNum1
                                     (case negate $dNum1 ww7 of y2 { __DEFAULT ->
                                      case == $dEq1 ww6 (fromInteger $dNum1 lvl4) of {
                                        False ->
                                          + $dNum1
                                            (pi $dFloating1)
                                            (atan $dFloating1 (/ $dFractional1 y2 ww6));
                                        True ->
                                          / $dFractional1 (pi $dFloating1) (fromInteger $dNum1 lvl)
                                      }
                                      })
                              of nt
                              { __DEFAULT ->
                              jump $j nt
                              }
                          }
                      } } in
                case < $dOrd1 ww6 (fromInteger $dNum1 lvl4) of {
                  False -> jump $j2;
                  True ->
                    case > $dOrd1 ww7 (fromInteger $dNum1 lvl4) of {
                      False -> jump $j2;
                      True ->
                        case + $dNum1
                               (pi $dFloating1)
                               (atan $dFloating1 (/ $dFractional1 ww7 ww6))
                        of nt
                        { __DEFAULT ->
                        jump $j nt
                        }
                    }
                } } in
          case == $dEq1 ww6 (fromInteger $dNum1 lvl4) of {
            False -> jump $j1;
            True ->
              case > $dOrd1 ww7 (fromInteger $dNum1 lvl4) of {
                False -> jump $j1;
                True ->
                  case / $dFractional1 (pi $dFloating1) (fromInteger $dNum1 lvl)
                  of nt
                  { __DEFAULT ->
                  jump $j nt
                  }
              }
          };
        True ->
          case atan $dFloating1 (/ $dFractional1 ww7 ww6) of nt
          { __DEFAULT ->
          jump $j nt
          }
      }

-- RHS size: {terms: 30, types: 43, coercions: 3, joins: 0/0}
loopTrace
  :: forall n.
     OrderedField n =>
     Loop V2 n -> Point V2 n -> V2 n -> Seq n
loopTrace
  = \ (@ n)
      (w :: OrderedField n)
      (w1 :: Loop V2 n)
      (w2 :: Point V2 n)
      (w3 :: V2 n) ->
      case w1 of { Loop ww1 ww2 ->
      case ww1 of { Line ww4 ww5 ->
      case ww5 of { V2 ww7 ww8 ->
      case w2 `cast` <Co:3> of { V2 ww10 ww11 ->
      case w3 of { V2 ww13 ww14 ->
      $wloopTrace w ww4 ww7 ww8 ww2 ww10 ww11 ww13 ww14
      }
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 19, joins: 0/0}
$fTracedLoop_$cgetTrace
  :: forall n.
     OrderedField n =>
     Loop V2 n -> Trace (V (Loop V2 n)) (N (Loop V2 n))
$fTracedLoop_$cgetTrace = loopTrace `cast` <Co:19>

-- RHS size: {terms: 8, types: 12, coercions: 10, joins: 0/0}
$fTracedLoop :: forall n. OrderedField n => Traced (Loop V2 n)
$fTracedLoop
  = \ (@ n) ($d(%,%) :: OrderedField n) ->
      C:Traced
        ($fAdditiveV2 `cast` <Co:5>)
        (($p2(%,%) $d(%,%)) `cast` <Co:5>)
        ($fTracedLoop_$cgetTrace $d(%,%))

-- RHS size: {terms: 2,262,
              types: 800,
              coercions: 597,
              joins: 11/79}
$w$slineTrace
  :: Seq (Segment V2 Double)
     -> Double# -> Double# -> Double# -> Double# -> Seq Double
$w$slineTrace
  = \ (ww
         :: Seq (Segment V2 Double)
         Unf=OtherCon [])
      (ww1 :: Double#)
      (ww2 :: Double#)
      (ww3 :: Double#)
      (ww4 :: Double#) ->
      join {
        $w$j :: Double# -> Seq Double
        $w$j (ww5 :: Double#)
          = case /## 1.0## (sqrtDouble# (+## (*## ww3 ww3) (*## ww4 ww4)))
            of wild4
            { __DEFAULT ->
            case /## 0.0## wild4 of wild1 { __DEFAULT ->
            case /## 1.0## wild4 of wild2 { __DEFAULT ->
            let {
              x :: Double#
              x = negateDouble# ww5 } in
            let {
              ipv :: Double#
              ipv = cosDouble# x } in
            let {
              dt7 :: Double
              dt7 = D# ipv } in
            let {
              x1 :: Double#
              x1 = sinDouble# x } in
            let {
              wild3 :: Double
              wild3 = D# x1 } in
            let {
              dt8 :: Double#
              dt8 = negateDouble# x1 } in
            let {
              dt9 :: Double
              dt9 = D# dt8 } in
            case $fMonoidTransformation_$stappend1
                   (T (V2
                         (V2 (D# wild4) (D# (*## wild4 0.0##)))
                         (V2 (D# (*## wild4 0.0##)) (D# wild4)))
                      (V2 (V2 (D# wild2) (D# wild1)) (V2 (D# wild1) (D# wild2)))
                      lvl50)
                   ($fMonoidTransformation_$stappend1
                      (T (V2 (V2 dt7 dt9) (V2 wild3 dt7))
                         (V2 (V2 dt7 wild3) (V2 dt9 dt7))
                         lvl50)
                      (T lvl52
                         lvl52
                         (V2 (D# (negateDouble# ww1)) (D# (negateDouble# ww2)))))
            of
            { T ipv1 ipv2 ipv3 ->
            case ipv1 of { V2 a5 b3 ->
            case ipv3 of { V2 d e ->
            case a5 of { V2 a1 b1 ->
            case a1 of { D# x2 ->
            case b1 of { D# x3 ->
            case b3 of { V2 a2 b2 ->
            case a2 of { D# x4 ->
            case b2 of { D# x5 ->
            case d of { D# y ->
            case e of { D# y1 ->
            case (((($fEq1Seq_$cfoldr
                       ((\ (a3 :: Segment V2 Double)
                           (fa
                              :: Const
                                   (Endo (Endo (Point V2 Double, Bool, Seq Double)))
                                   (Segment V2 Double))
                           (eta :: Endo (Point V2 Double, Bool, Seq Double)) ->
                           let {
                             ds :: Endo (Point V2 Double, Bool, Seq Double)
                             ds = (fa `cast` <Co:25>) eta } in
                           (\ (z :: (Point V2 Double, Bool, Seq Double)) ->
                              case z of { (q, _nearStart, ts) ->
                              case q `cast` <Co:3> of { V2 ipv4 ipv5 ->
                              case ipv4 of { D# x6 ->
                              case ipv5 of { D# x7 ->
                              case _nearStart of _nearStart1 { __DEFAULT ->
                              case ts `cast` <Co:2> of nt2 { __DEFAULT ->
                              case a3 of {
                                Linear w ->
                                  case w of { V2 x8 y2 ->
                                  case y2 of { D# y3 ->
                                  case x8 of { D# y4 ->
                                  let {
                                    x9 :: Double#
                                    x9 = -## (*## ww3 y3) (*## ww4 y4) } in
                                  let {
                                    dt10 :: Double#
                                    dt10 = +## x6 (negateDouble# ww1) } in
                                  let {
                                    dt11 :: Double#
                                    dt11 = +## x7 (negateDouble# ww2) } in
                                  let {
                                    x10 :: Double#
                                    x10 = -## (*## dt10 ww4) (*## dt11 ww3) } in
                                  join {
                                    $j1 :: (Point V2 Double, Bool, Seq Double)
                                    $j1
                                      = (ds `cast` <Co:8>)
                                          ((V2 (D# (+## x6 y4)) (D# (+## x7 y3))) `cast` <Co:37>,
                                           False, nt2 `cast` <Co:3>) } in
                                  join {
                                    $j2 :: (Point V2 Double, Bool, Seq Double)
                                    $j2
                                      = case /## x10 x9 of wild22 { __DEFAULT ->
                                        case tagToEnum# (>=## wild22 0.0##) of {
                                          False -> jump $j1;
                                          True ->
                                            case tagToEnum# (<=## wild22 1.001##) of {
                                              False -> jump $j1;
                                              True ->
                                                (ds `cast` <Co:8>)
                                                  ((V2 (D# (+## x6 y4)) (D# (+## x7 y3)))
                                                   `cast` <Co:37>,
                                                   tagToEnum# (>## wild22 0.999##),
                                                   ($b:|>_$ssnocTree
                                                      nt2
                                                      (case /## (-## (*## dt10 y3) (*## dt11 y4)) x9
                                                       of wild25
                                                       { __DEFAULT ->
                                                       (D# wild25) `cast` <Co:20>
                                                       }))
                                                   `cast` <Co:130>)
                                            }
                                        }
                                        } } in
                                  case tagToEnum# (==## x9 0.0##) of {
                                    False -> jump $j2;
                                    True ->
                                      case tagToEnum# (==## x10 0.0##) of {
                                        False -> jump $j1;
                                        True -> jump $j2
                                      }
                                  }
                                  }
                                  }
                                  };
                                Cubic ipv6 ipv7 ipv8 ->
                                  case ipv8 of { V2 d1 e1 ->
                                  case ipv7 of { V2 d2 e2 ->
                                  case ipv6 of { V2 d3 e3 ->
                                  case d3 of { D# y2 ->
                                  case e3 of { D# y3 ->
                                  case d2 of { D# y4 ->
                                  case e2 of { D# y5 ->
                                  case d1 of { D# y6 ->
                                  case e1 of { D# y7 ->
                                  (ds `cast` <Co:8>)
                                    (let {
                                       ds4 :: Double#
                                       ds4 = +## (*## x2 y6) (*## x3 y7) } in
                                     let {
                                       ipv9 :: Double#
                                       ipv9 = +## (*## x4 y4) (*## x5 y5) } in
                                     let {
                                       ds5 :: Double#
                                       ds5 = +## (*## x2 y4) (*## x3 y5) } in
                                     let {
                                       ipv10 :: Double#
                                       ipv10 = +## (*## x4 y2) (*## x5 y3) } in
                                     let {
                                       ds6 :: Double#
                                       ds6 = +## (*## x2 y2) (*## x3 y3) } in
                                     let {
                                       ds7 :: Double#
                                       ds7 = +## (+## (*## x2 x6) (*## x3 x7)) y } in
                                     let {
                                       ds1 :: Double#
                                       ds1 = +## (+## (*## x4 x6) (*## x5 x7)) y1 } in
                                     let {
                                       tcs :: [Double]
                                       tcs
                                         = let {
                                             x8 :: Double#
                                             x8
                                               = +##
                                                   (-## (*## 3.0## ipv10) (*## 3.0## ipv9))
                                                   (+## (*## x4 y6) (*## x5 y7)) } in
                                           let {
                                             b :: Double#
                                             b = +##
                                                   (negateDouble# (*## 6.0## ipv10))
                                                   (*## 3.0## ipv9) } in
                                           let {
                                             c1 :: Double#
                                             c1 = *## 3.0## ipv10 } in
                                           case tagToEnum# (<## (fabsDouble# x8) 1.0e-8##) of {
                                             False ->
                                               let {
                                                 x9 :: Double#
                                                 x9
                                                   = -##
                                                       (-##
                                                          (+##
                                                             (-##
                                                                (*##
                                                                   (*## (*## (*## 18.0## x8) b) c1)
                                                                   ds1)
                                                                (*##
                                                                   (*## 4.0## (*## (*## b b) b))
                                                                   ds1))
                                                             (*## (*## b b) (*## c1 c1)))
                                                          (*## (*## 4.0## x8) (*## (*## c1 c1) c1)))
                                                       (*##
                                                          (*## 27.0## (*## x8 x8))
                                                          (*## ds1 ds1)) } in
                                               let {
                                                 y8 :: Double#
                                                 y8 = *## (*## b b) b } in
                                               let {
                                                 xx :: Double#
                                                 xx
                                                   = +##
                                                       (-##
                                                          (+## y8 y8)
                                                          (*## (*## (*## 9.0## x8) b) c1))
                                                       (*## (*## 27.0## (*## x8 x8)) ds1) } in
                                               let {
                                                 disc :: Double#
                                                 disc = -## (*## (*## 3.0## x8) c1) (*## b b) } in
                                               case tagToEnum# (>## x9 0.0##) of {
                                                 False ->
                                                   join {
                                                     $j1 :: [Double]
                                                     $j1
                                                       = join {
                                                           $j2 :: [Double]
                                                           $j2
                                                             = case /## b (*## 3.0## x8) of wild30
                                                               { __DEFAULT ->
                                                               case tagToEnum#
                                                                      (<##
                                                                         (fabsDouble# disc)
                                                                         1.0e-8##)
                                                               of {
                                                                 False ->
                                                                   let {
                                                                     x10 :: Double#
                                                                     x10
                                                                       = *##
                                                                           0.5##
                                                                           (+##
                                                                              (sqrtDouble#
                                                                                 (negateDouble#
                                                                                    (*##
                                                                                       (*##
                                                                                          27.0##
                                                                                          (*##
                                                                                             x8 x8))
                                                                                       x9)))
                                                                              xx) } in
                                                                   case tagToEnum# (<## x10 0.0##)
                                                                   of {
                                                                     False ->
                                                                       let {
                                                                         x11 :: Double#
                                                                         x11
                                                                           = **##
                                                                               x10
                                                                               0.3333333333333333## } in
                                                                       case /## x11 (*## 3.0## x8)
                                                                       of wild33
                                                                       { __DEFAULT ->
                                                                       case /##
                                                                              disc
                                                                              (*##
                                                                                 (*## 3.0## x8) x11)
                                                                       of wild34
                                                                       { __DEFAULT ->
                                                                       let {
                                                                         x12 :: Double#
                                                                         x12
                                                                           = +##
                                                                               (-##
                                                                                  (negateDouble#
                                                                                     wild30)
                                                                                  wild33)
                                                                               wild34 } in
                                                                       case _nearStart1 of {
                                                                         False ->
                                                                           case tagToEnum#
                                                                                  (>=## x12 0.0##)
                                                                           of {
                                                                             False -> [];
                                                                             True ->
                                                                               case tagToEnum#
                                                                                      (<=##
                                                                                         x12
                                                                                         1.0001##)
                                                                               of {
                                                                                 False -> [];
                                                                                 True ->
                                                                                   : (D# x12) []
                                                                               }
                                                                           };
                                                                         True ->
                                                                           case tagToEnum#
                                                                                  (>=##
                                                                                     x12 1.0e-4##)
                                                                           of {
                                                                             False -> [];
                                                                             True ->
                                                                               case tagToEnum#
                                                                                      (<=##
                                                                                         x12
                                                                                         1.0001##)
                                                                               of {
                                                                                 False -> [];
                                                                                 True ->
                                                                                   : (D# x12) []
                                                                               }
                                                                           }
                                                                       }
                                                                       }
                                                                       };
                                                                     True ->
                                                                       let {
                                                                         x11 :: Double#
                                                                         x11
                                                                           = negateDouble#
                                                                               (**##
                                                                                  (negateDouble#
                                                                                     x10)
                                                                                  0.3333333333333333##) } in
                                                                       case /## x11 (*## 3.0## x8)
                                                                       of wild33
                                                                       { __DEFAULT ->
                                                                       case /##
                                                                              disc
                                                                              (*##
                                                                                 (*## 3.0## x8) x11)
                                                                       of wild34
                                                                       { __DEFAULT ->
                                                                       let {
                                                                         x12 :: Double#
                                                                         x12
                                                                           = +##
                                                                               (-##
                                                                                  (negateDouble#
                                                                                     wild30)
                                                                                  wild33)
                                                                               wild34 } in
                                                                       case _nearStart1 of {
                                                                         False ->
                                                                           case tagToEnum#
                                                                                  (>=## x12 0.0##)
                                                                           of {
                                                                             False -> [];
                                                                             True ->
                                                                               case tagToEnum#
                                                                                      (<=##
                                                                                         x12
                                                                                         1.0001##)
                                                                               of {
                                                                                 False -> [];
                                                                                 True ->
                                                                                   : (D# x12) []
                                                                               }
                                                                           };
                                                                         True ->
                                                                           case tagToEnum#
                                                                                  (>=##
                                                                                     x12 1.0e-4##)
                                                                           of {
                                                                             False -> [];
                                                                             True ->
                                                                               case tagToEnum#
                                                                                      (<=##
                                                                                         x12
                                                                                         1.0001##)
                                                                               of {
                                                                                 False -> [];
                                                                                 True ->
                                                                                   : (D# x12) []
                                                                               }
                                                                           }
                                                                       }
                                                                       }
                                                                       }
                                                                   };
                                                                 True ->
                                                                   let {
                                                                     x10 :: Double#
                                                                     x10
                                                                       = sqrtDouble#
                                                                           (negateDouble#
                                                                              (*##
                                                                                 (*##
                                                                                    27.0##
                                                                                    (*## x8 x8))
                                                                                 x9)) } in
                                                                   let {
                                                                     x11 :: Double#
                                                                     x11
                                                                       = fabsDouble#
                                                                           (+## x10 xx) } in
                                                                   let {
                                                                     x12 :: Double#
                                                                     x12 = negateDouble# x10 } in
                                                                   let {
                                                                     y9 :: Double#
                                                                     y9
                                                                       = fabsDouble#
                                                                           (+## x12 xx) } in
                                                                   case tagToEnum# (<## x11 y9) of {
                                                                     False ->
                                                                       case tagToEnum# (==## x11 y9)
                                                                       of {
                                                                         False ->
                                                                           let {
                                                                             x13 :: Double#
                                                                             x13
                                                                               = *##
                                                                                   0.5##
                                                                                   (+## x10 xx) } in
                                                                           case tagToEnum#
                                                                                  (<## x13 0.0##)
                                                                           of {
                                                                             False ->
                                                                               let {
                                                                                 x14 :: Double#
                                                                                 x14
                                                                                   = **##
                                                                                       x13
                                                                                       0.3333333333333333## } in
                                                                               case /##
                                                                                      x14
                                                                                      (*## 3.0## x8)
                                                                               of wild35
                                                                               { __DEFAULT ->
                                                                               case /##
                                                                                      disc
                                                                                      (*##
                                                                                         (*##
                                                                                            3.0##
                                                                                            x8)
                                                                                         x14)
                                                                               of wild36
                                                                               { __DEFAULT ->
                                                                               let {
                                                                                 x15 :: Double#
                                                                                 x15
                                                                                   = +##
                                                                                       (-##
                                                                                          (negateDouble#
                                                                                             wild30)
                                                                                          wild35)
                                                                                       wild36 } in
                                                                               case _nearStart1 of {
                                                                                 False ->
                                                                                   case tagToEnum#
                                                                                          (>=##
                                                                                             x15
                                                                                             0.0##)
                                                                                   of {
                                                                                     False -> [];
                                                                                     True ->
                                                                                       case tagToEnum#
                                                                                              (<=##
                                                                                                 x15
                                                                                                 1.0001##)
                                                                                       of {
                                                                                         False ->
                                                                                           [];
                                                                                         True ->
                                                                                           : (D#
                                                                                                x15)
                                                                                             []
                                                                                       }
                                                                                   };
                                                                                 True ->
                                                                                   case tagToEnum#
                                                                                          (>=##
                                                                                             x15
                                                                                             1.0e-4##)
                                                                                   of {
                                                                                     False -> [];
                                                                                     True ->
                                                                                       case tagToEnum#
                                                                                              (<=##
                                                                                                 x15
                                                                                                 1.0001##)
                                                                                       of {
                                                                                         False ->
                                                                                           [];
                                                                                         True ->
                                                                                           : (D#
                                                                                                x15)
                                                                                             []
                                                                                       }
                                                                                   }
                                                                               }
                                                                               }
                                                                               };
                                                                             True ->
                                                                               let {
                                                                                 x14 :: Double#
                                                                                 x14
                                                                                   = negateDouble#
                                                                                       (**##
                                                                                          (negateDouble#
                                                                                             x13)
                                                                                          0.3333333333333333##) } in
                                                                               case /##
                                                                                      x14
                                                                                      (*## 3.0## x8)
                                                                               of wild35
                                                                               { __DEFAULT ->
                                                                               case /##
                                                                                      disc
                                                                                      (*##
                                                                                         (*##
                                                                                            3.0##
                                                                                            x8)
                                                                                         x14)
                                                                               of wild36
                                                                               { __DEFAULT ->
                                                                               let {
                                                                                 x15 :: Double#
                                                                                 x15
                                                                                   = +##
                                                                                       (-##
                                                                                          (negateDouble#
                                                                                             wild30)
                                                                                          wild35)
                                                                                       wild36 } in
                                                                               case _nearStart1 of {
                                                                                 False ->
                                                                                   case tagToEnum#
                                                                                          (>=##
                                                                                             x15
                                                                                             0.0##)
                                                                                   of {
                                                                                     False -> [];
                                                                                     True ->
                                                                                       case tagToEnum#
                                                                                              (<=##
                                                                                                 x15
                                                                                                 1.0001##)
                                                                                       of {
                                                                                         False ->
                                                                                           [];
                                                                                         True ->
                                                                                           : (D#
                                                                                                x15)
                                                                                             []
                                                                                       }
                                                                                   };
                                                                                 True ->
                                                                                   case tagToEnum#
                                                                                          (>=##
                                                                                             x15
                                                                                             1.0e-4##)
                                                                                   of {
                                                                                     False -> [];
                                                                                     True ->
                                                                                       case tagToEnum#
                                                                                              (<=##
                                                                                                 x15
                                                                                                 1.0001##)
                                                                                       of {
                                                                                         False ->
                                                                                           [];
                                                                                         True ->
                                                                                           : (D#
                                                                                                x15)
                                                                                             []
                                                                                       }
                                                                                   }
                                                                               }
                                                                               }
                                                                               }
                                                                           };
                                                                         True ->
                                                                           let {
                                                                             x13 :: Double#
                                                                             x13
                                                                               = *##
                                                                                   0.5##
                                                                                   (+## x12 xx) } in
                                                                           case tagToEnum#
                                                                                  (<## x13 0.0##)
                                                                           of {
                                                                             False ->
                                                                               let {
                                                                                 x14 :: Double#
                                                                                 x14
                                                                                   = **##
                                                                                       x13
                                                                                       0.3333333333333333## } in
                                                                               case /##
                                                                                      x14
                                                                                      (*## 3.0## x8)
                                                                               of wild35
                                                                               { __DEFAULT ->
                                                                               case /##
                                                                                      disc
                                                                                      (*##
                                                                                         (*##
                                                                                            3.0##
                                                                                            x8)
                                                                                         x14)
                                                                               of wild36
                                                                               { __DEFAULT ->
                                                                               let {
                                                                                 x15 :: Double#
                                                                                 x15
                                                                                   = +##
                                                                                       (-##
                                                                                          (negateDouble#
                                                                                             wild30)
                                                                                          wild35)
                                                                                       wild36 } in
                                                                               case _nearStart1 of {
                                                                                 False ->
                                                                                   case tagToEnum#
                                                                                          (>=##
                                                                                             x15
                                                                                             0.0##)
                                                                                   of {
                                                                                     False -> [];
                                                                                     True ->
                                                                                       case tagToEnum#
                                                                                              (<=##
                                                                                                 x15
                                                                                                 1.0001##)
                                                                                       of {
                                                                                         False ->
                                                                                           [];
                                                                                         True ->
                                                                                           : (D#
                                                                                                x15)
                                                                                             []
                                                                                       }
                                                                                   };
                                                                                 True ->
                                                                                   case tagToEnum#
                                                                                          (>=##
                                                                                             x15
                                                                                             1.0e-4##)
                                                                                   of {
                                                                                     False -> [];
                                                                                     True ->
                                                                                       case tagToEnum#
                                                                                              (<=##
                                                                                                 x15
                                                                                                 1.0001##)
                                                                                       of {
                                                                                         False ->
                                                                                           [];
                                                                                         True ->
                                                                                           : (D#
                                                                                                x15)
                                                                                             []
                                                                                       }
                                                                                   }
                                                                               }
                                                                               }
                                                                               };
                                                                             True ->
                                                                               let {
                                                                                 x14 :: Double#
                                                                                 x14
                                                                                   = negateDouble#
                                                                                       (**##
                                                                                          (negateDouble#
                                                                                             x13)
                                                                                          0.3333333333333333##) } in
                                                                               case /##
                                                                                      x14
                                                                                      (*## 3.0## x8)
                                                                               of wild35
                                                                               { __DEFAULT ->
                                                                               case /##
                                                                                      disc
                                                                                      (*##
                                                                                         (*##
                                                                                            3.0##
                                                                                            x8)
                                                                                         x14)
                                                                               of wild36
                                                                               { __DEFAULT ->
                                                                               let {
                                                                                 x15 :: Double#
                                                                                 x15
                                                                                   = +##
                                                                                       (-##
                                                                                          (negateDouble#
                                                                                             wild30)
                                                                                          wild35)
                                                                                       wild36 } in
                                                                               case _nearStart1 of {
                                                                                 False ->
                                                                                   case tagToEnum#
                                                                                          (>=##
                                                                                             x15
                                                                                             0.0##)
                                                                                   of {
                                                                                     False -> [];
                                                                                     True ->
                                                                                       case tagToEnum#
                                                                                              (<=##
                                                                                                 x15
                                                                                                 1.0001##)
                                                                                       of {
                                                                                         False ->
                                                                                           [];
                                                                                         True ->
                                                                                           : (D#
                                                                                                x15)
                                                                                             []
                                                                                       }
                                                                                   };
                                                                                 True ->
                                                                                   case tagToEnum#
                                                                                          (>=##
                                                                                             x15
                                                                                             1.0e-4##)
                                                                                   of {
                                                                                     False -> [];
                                                                                     True ->
                                                                                       case tagToEnum#
                                                                                              (<=##
                                                                                                 x15
                                                                                                 1.0001##)
                                                                                       of {
                                                                                         False ->
                                                                                           [];
                                                                                         True ->
                                                                                           : (D#
                                                                                                x15)
                                                                                             []
                                                                                       }
                                                                                   }
                                                                               }
                                                                               }
                                                                               }
                                                                           }
                                                                       };
                                                                     True ->
                                                                       let {
                                                                         x13 :: Double#
                                                                         x13
                                                                           = *##
                                                                               0.5##
                                                                               (+## x12 xx) } in
                                                                       case tagToEnum#
                                                                              (<## x13 0.0##)
                                                                       of {
                                                                         False ->
                                                                           let {
                                                                             x14 :: Double#
                                                                             x14
                                                                               = **##
                                                                                   x13
                                                                                   0.3333333333333333## } in
                                                                           case /##
                                                                                  x14 (*## 3.0## x8)
                                                                           of wild34
                                                                           { __DEFAULT ->
                                                                           case /##
                                                                                  disc
                                                                                  (*##
                                                                                     (*## 3.0## x8)
                                                                                     x14)
                                                                           of wild35
                                                                           { __DEFAULT ->
                                                                           let {
                                                                             x15 :: Double#
                                                                             x15
                                                                               = +##
                                                                                   (-##
                                                                                      (negateDouble#
                                                                                         wild30)
                                                                                      wild34)
                                                                                   wild35 } in
                                                                           case _nearStart1 of {
                                                                             False ->
                                                                               case tagToEnum#
                                                                                      (>=##
                                                                                         x15 0.0##)
                                                                               of {
                                                                                 False -> [];
                                                                                 True ->
                                                                                   case tagToEnum#
                                                                                          (<=##
                                                                                             x15
                                                                                             1.0001##)
                                                                                   of {
                                                                                     False -> [];
                                                                                     True ->
                                                                                       : (D# x15) []
                                                                                   }
                                                                               };
                                                                             True ->
                                                                               case tagToEnum#
                                                                                      (>=##
                                                                                         x15
                                                                                         1.0e-4##)
                                                                               of {
                                                                                 False -> [];
                                                                                 True ->
                                                                                   case tagToEnum#
                                                                                          (<=##
                                                                                             x15
                                                                                             1.0001##)
                                                                                   of {
                                                                                     False -> [];
                                                                                     True ->
                                                                                       : (D# x15) []
                                                                                   }
                                                                               }
                                                                           }
                                                                           }
                                                                           };
                                                                         True ->
                                                                           let {
                                                                             x14 :: Double#
                                                                             x14
                                                                               = negateDouble#
                                                                                   (**##
                                                                                      (negateDouble#
                                                                                         x13)
                                                                                      0.3333333333333333##) } in
                                                                           case /##
                                                                                  x14 (*## 3.0## x8)
                                                                           of wild34
                                                                           { __DEFAULT ->
                                                                           case /##
                                                                                  disc
                                                                                  (*##
                                                                                     (*## 3.0## x8)
                                                                                     x14)
                                                                           of wild35
                                                                           { __DEFAULT ->
                                                                           let {
                                                                             x15 :: Double#
                                                                             x15
                                                                               = +##
                                                                                   (-##
                                                                                      (negateDouble#
                                                                                         wild30)
                                                                                      wild34)
                                                                                   wild35 } in
                                                                           case _nearStart1 of {
                                                                             False ->
                                                                               case tagToEnum#
                                                                                      (>=##
                                                                                         x15 0.0##)
                                                                               of {
                                                                                 False -> [];
                                                                                 True ->
                                                                                   case tagToEnum#
                                                                                          (<=##
                                                                                             x15
                                                                                             1.0001##)
                                                                                   of {
                                                                                     False -> [];
                                                                                     True ->
                                                                                       : (D# x15) []
                                                                                   }
                                                                               };
                                                                             True ->
                                                                               case tagToEnum#
                                                                                      (>=##
                                                                                         x15
                                                                                         1.0e-4##)
                                                                               of {
                                                                                 False -> [];
                                                                                 True ->
                                                                                   case tagToEnum#
                                                                                          (<=##
                                                                                             x15
                                                                                             1.0001##)
                                                                                   of {
                                                                                     False -> [];
                                                                                     True ->
                                                                                       : (D# x15) []
                                                                                   }
                                                                               }
                                                                           }
                                                                           }
                                                                           }
                                                                       }
                                                                   }
                                                               }
                                                               } } in
                                                         case tagToEnum# (==## x9 0.0##) of {
                                                           False -> jump $j2;
                                                           True ->
                                                             case tagToEnum# (==## disc 0.0##) of {
                                                               False ->
                                                                 let {
                                                                   r :: [Double]
                                                                   r = case /##
                                                                              (+##
                                                                                 (-##
                                                                                    (*##
                                                                                       (*##
                                                                                          9.0##
                                                                                          (*##
                                                                                             x8 x8))
                                                                                       ds1)
                                                                                    (*##
                                                                                       (*##
                                                                                          (*##
                                                                                             4.0##
                                                                                             x8)
                                                                                          b)
                                                                                       c1))
                                                                                 y8)
                                                                              (*## x8 disc)
                                                                       of wild31
                                                                       { __DEFAULT ->
                                                                       case _nearStart1 of {
                                                                         False ->
                                                                           case tagToEnum#
                                                                                  (>=##
                                                                                     wild31 0.0##)
                                                                           of {
                                                                             False -> [];
                                                                             True ->
                                                                               case tagToEnum#
                                                                                      (<=##
                                                                                         wild31
                                                                                         1.0001##)
                                                                               of {
                                                                                 False -> [];
                                                                                 True ->
                                                                                   : (D# wild31) []
                                                                               }
                                                                           };
                                                                         True ->
                                                                           case tagToEnum#
                                                                                  (>=##
                                                                                     wild31
                                                                                     1.0e-4##)
                                                                           of {
                                                                             False -> [];
                                                                             True ->
                                                                               case tagToEnum#
                                                                                      (<=##
                                                                                         wild31
                                                                                         1.0001##)
                                                                               of {
                                                                                 False -> [];
                                                                                 True ->
                                                                                   : (D# wild31) []
                                                                               }
                                                                           }
                                                                       }
                                                                       } } in
                                                                 case /##
                                                                        (-##
                                                                           (*## b c1)
                                                                           (*## (*## 9.0## x8) ds1))
                                                                        (+## disc disc)
                                                                 of wild31
                                                                 { __DEFAULT ->
                                                                 case _nearStart1 of {
                                                                   False ->
                                                                     case tagToEnum#
                                                                            (>=## wild31 0.0##)
                                                                     of {
                                                                       False -> r;
                                                                       True ->
                                                                         case tagToEnum#
                                                                                (<=##
                                                                                   wild31 1.0001##)
                                                                         of {
                                                                           False -> r;
                                                                           True -> : (D# wild31) r
                                                                         }
                                                                     };
                                                                   True ->
                                                                     case tagToEnum#
                                                                            (>=## wild31 1.0e-4##)
                                                                     of {
                                                                       False -> r;
                                                                       True ->
                                                                         case tagToEnum#
                                                                                (<=##
                                                                                   wild31 1.0001##)
                                                                         of {
                                                                           False -> r;
                                                                           True -> : (D# wild31) r
                                                                         }
                                                                     }
                                                                 }
                                                                 };
                                                               True -> jump $j2
                                                             }
                                                         } } in
                                                   case tagToEnum# (==## x9 0.0##) of {
                                                     False -> jump $j1;
                                                     True ->
                                                       case tagToEnum# (==## disc 0.0##) of {
                                                         False -> jump $j1;
                                                         True ->
                                                           case /## b (*## 3.0## x8) of wild32
                                                           { __DEFAULT ->
                                                           let {
                                                             x10 :: Double#
                                                             x10 = negateDouble# wild32 } in
                                                           case _nearStart1 of {
                                                             False ->
                                                               case tagToEnum# (>=## x10 0.0##) of {
                                                                 False -> [];
                                                                 True ->
                                                                   case tagToEnum#
                                                                          (<=## x10 1.0001##)
                                                                   of {
                                                                     False -> [];
                                                                     True -> : (D# x10) []
                                                                   }
                                                               };
                                                             True ->
                                                               case tagToEnum# (>=## x10 1.0e-4##)
                                                               of {
                                                                 False -> [];
                                                                 True ->
                                                                   case tagToEnum#
                                                                          (<=## x10 1.0001##)
                                                                   of {
                                                                     False -> [];
                                                                     True -> : (D# x10) []
                                                                   }
                                                               }
                                                           }
                                                           }
                                                       }
                                                   };
                                                 True ->
                                                   case /## disc (*## 3.0## (*## x8 x8)) of wild30
                                                   { __DEFAULT ->
                                                   let {
                                                     y9 :: Double#
                                                     y9
                                                       = sqrtDouble#
                                                           (negateDouble# (/## wild30 3.0##)) } in
                                                   case /## xx (*## 27.0## (*## (*## x8 x8) x8))
                                                   of wild31
                                                   { __DEFAULT ->
                                                   case /## (*## 3.0## wild31) (+## wild30 wild30)
                                                   of wild32
                                                   { __DEFAULT ->
                                                   case /## 3.0## wild30 of wild33 { __DEFAULT ->
                                                   case acosDouble#
                                                          (*##
                                                             wild32
                                                             (sqrtDouble# (negateDouble# wild33)))
                                                   of wild34
                                                   { __DEFAULT ->
                                                   let {
                                                     x10 :: Double#
                                                     x10 = *## 0.3333333333333333## wild34 } in
                                                   case /## b (*## 3.0## x8) of wild35
                                                   { __DEFAULT ->
                                                   let {
                                                     x11 :: Double#
                                                     x11
                                                       = -##
                                                           (*##
                                                              (+## y9 y9)
                                                              (cosDouble#
                                                                 (-## x10 4.1887902047863905##)))
                                                           wild35 } in
                                                   let {
                                                     r :: [Double]
                                                     r = case _nearStart1 of {
                                                           False ->
                                                             case tagToEnum# (>=## x11 0.0##) of {
                                                               False -> [];
                                                               True ->
                                                                 case tagToEnum# (<=## x11 1.0001##)
                                                                 of {
                                                                   False -> [];
                                                                   True -> : (D# x11) []
                                                                 }
                                                             };
                                                           True ->
                                                             case tagToEnum# (>=## x11 1.0e-4##)
                                                             of {
                                                               False -> [];
                                                               True ->
                                                                 case tagToEnum# (<=## x11 1.0001##)
                                                                 of {
                                                                   False -> [];
                                                                   True -> : (D# x11) []
                                                                 }
                                                             }
                                                         } } in
                                                   let {
                                                     x12 :: Double#
                                                     x12
                                                       = -##
                                                           (*##
                                                              (+## y9 y9)
                                                              (cosDouble#
                                                                 (-## x10 2.0943951023931953##)))
                                                           wild35 } in
                                                   let {
                                                     r1 :: [Double]
                                                     r1
                                                       = case _nearStart1 of {
                                                           False ->
                                                             case tagToEnum# (>=## x12 0.0##) of {
                                                               False -> r;
                                                               True ->
                                                                 case tagToEnum# (<=## x12 1.0001##)
                                                                 of {
                                                                   False -> r;
                                                                   True -> : (D# x12) r
                                                                 }
                                                             };
                                                           True ->
                                                             case tagToEnum# (>=## x12 1.0e-4##)
                                                             of {
                                                               False -> r;
                                                               True ->
                                                                 case tagToEnum# (<=## x12 1.0001##)
                                                                 of {
                                                                   False -> r;
                                                                   True -> : (D# x12) r
                                                                 }
                                                             }
                                                         } } in
                                                   let {
                                                     x13 :: Double#
                                                     x13
                                                       = -##
                                                           (*## (+## y9 y9) (cosDouble# x10))
                                                           wild35 } in
                                                   case _nearStart1 of {
                                                     False ->
                                                       case tagToEnum# (>=## x13 0.0##) of {
                                                         False -> r1;
                                                         True ->
                                                           case tagToEnum# (<=## x13 1.0001##) of {
                                                             False -> r1;
                                                             True -> : (D# x13) r1
                                                           }
                                                       };
                                                     True ->
                                                       case tagToEnum# (>=## x13 1.0e-4##) of {
                                                         False -> r1;
                                                         True ->
                                                           case tagToEnum# (<=## x13 1.0001##) of {
                                                             False -> r1;
                                                             True -> : (D# x13) r1
                                                           }
                                                       }
                                                   }
                                                   }
                                                   }
                                                   }
                                                   }
                                                   }
                                                   }
                                               };
                                             True ->
                                               join {
                                                 $j1 :: [Double]
                                                 $j1
                                                   = join {
                                                       $j2 :: [Double]
                                                       $j2
                                                         = case tagToEnum# (==## b 0.0##) of {
                                                             False ->
                                                               let {
                                                                 x9 :: Double#
                                                                 x9
                                                                   = -##
                                                                       (*## c1 c1)
                                                                       (*## (*## 4.0## b) ds1) } in
                                                               case tagToEnum# (<## x9 0.0##) of {
                                                                 False ->
                                                                   case tagToEnum# (==## c1 0.0##)
                                                                   of {
                                                                     False ->
                                                                       case tagToEnum#
                                                                              (==## x9 0.0##)
                                                                       of {
                                                                         False ->
                                                                           join {
                                                                             $w$j1
                                                                               :: Double#
                                                                                  -> [Double]
                                                                             $w$j1 (w :: Double#)
                                                                               = let {
                                                                                   r :: [Double]
                                                                                   r = case /##
                                                                                              ds1 w
                                                                                       of wild33
                                                                                       { __DEFAULT ->
                                                                                       case _nearStart1
                                                                                       of {
                                                                                         False ->
                                                                                           case tagToEnum#
                                                                                                  (>=##
                                                                                                     wild33
                                                                                                     0.0##)
                                                                                           of {
                                                                                             False ->
                                                                                               [];
                                                                                             True ->
                                                                                               case tagToEnum#
                                                                                                      (<=##
                                                                                                         wild33
                                                                                                         1.0001##)
                                                                                               of {
                                                                                                 False ->
                                                                                                   [];
                                                                                                 True ->
                                                                                                   : (D#
                                                                                                        wild33)
                                                                                                     []
                                                                                               }
                                                                                           };
                                                                                         True ->
                                                                                           case tagToEnum#
                                                                                                  (>=##
                                                                                                     wild33
                                                                                                     1.0e-4##)
                                                                                           of {
                                                                                             False ->
                                                                                               [];
                                                                                             True ->
                                                                                               case tagToEnum#
                                                                                                      (<=##
                                                                                                         wild33
                                                                                                         1.0001##)
                                                                                               of {
                                                                                                 False ->
                                                                                                   [];
                                                                                                 True ->
                                                                                                   : (D#
                                                                                                        wild33)
                                                                                                     []
                                                                                               }
                                                                                           }
                                                                                       }
                                                                                       } } in
                                                                                 case /## w b
                                                                                 of wild33
                                                                                 { __DEFAULT ->
                                                                                 case _nearStart1
                                                                                 of {
                                                                                   False ->
                                                                                     case tagToEnum#
                                                                                            (>=##
                                                                                               wild33
                                                                                               0.0##)
                                                                                     of {
                                                                                       False -> r;
                                                                                       True ->
                                                                                         case tagToEnum#
                                                                                                (<=##
                                                                                                   wild33
                                                                                                   1.0001##)
                                                                                         of {
                                                                                           False ->
                                                                                             r;
                                                                                           True ->
                                                                                             : (D#
                                                                                                  wild33)
                                                                                               r
                                                                                         }
                                                                                     };
                                                                                   True ->
                                                                                     case tagToEnum#
                                                                                            (>=##
                                                                                               wild33
                                                                                               1.0e-4##)
                                                                                     of {
                                                                                       False -> r;
                                                                                       True ->
                                                                                         case tagToEnum#
                                                                                                (<=##
                                                                                                   wild33
                                                                                                   1.0001##)
                                                                                         of {
                                                                                           False ->
                                                                                             r;
                                                                                           True ->
                                                                                             : (D#
                                                                                                  wild33)
                                                                                               r
                                                                                         }
                                                                                     }
                                                                                 }
                                                                                 } } in
                                                                           case tagToEnum#
                                                                                  (>## c1 0.0##)
                                                                           of {
                                                                             False ->
                                                                               case tagToEnum#
                                                                                      (<## c1 0.0##)
                                                                               of {
                                                                                 False ->
                                                                                   jump $w$j1
                                                                                     (negateDouble#
                                                                                        (*##
                                                                                           0.5##
                                                                                           (+##
                                                                                              c1
                                                                                              (*##
                                                                                                 c1
                                                                                                 (sqrtDouble#
                                                                                                    x9)))));
                                                                                 True ->
                                                                                   jump $w$j1
                                                                                     (negateDouble#
                                                                                        (*##
                                                                                           0.5##
                                                                                           (+##
                                                                                              c1
                                                                                              (*##
                                                                                                 -1.0##
                                                                                                 (sqrtDouble#
                                                                                                    x9)))))
                                                                               };
                                                                             True ->
                                                                               jump $w$j1
                                                                                 (negateDouble#
                                                                                    (*##
                                                                                       0.5##
                                                                                       (+##
                                                                                          c1
                                                                                          (sqrtDouble#
                                                                                             x9))))
                                                                           };
                                                                         True ->
                                                                           case /## c1 (+## b b)
                                                                           of wild33
                                                                           { __DEFAULT ->
                                                                           let {
                                                                             x10 :: Double#
                                                                             x10
                                                                               = negateDouble#
                                                                                   wild33 } in
                                                                           case _nearStart1 of {
                                                                             False ->
                                                                               case tagToEnum#
                                                                                      (>=##
                                                                                         x10 0.0##)
                                                                               of {
                                                                                 False -> [];
                                                                                 True ->
                                                                                   case tagToEnum#
                                                                                          (<=##
                                                                                             x10
                                                                                             1.0001##)
                                                                                   of {
                                                                                     False -> [];
                                                                                     True ->
                                                                                       : (D# x10) []
                                                                                   }
                                                                               };
                                                                             True ->
                                                                               case tagToEnum#
                                                                                      (>=##
                                                                                         x10
                                                                                         1.0e-4##)
                                                                               of {
                                                                                 False -> [];
                                                                                 True ->
                                                                                   case tagToEnum#
                                                                                          (<=##
                                                                                             x10
                                                                                             1.0001##)
                                                                                   of {
                                                                                     False -> [];
                                                                                     True ->
                                                                                       : (D# x10) []
                                                                                   }
                                                                               }
                                                                           }
                                                                           }
                                                                       };
                                                                     True ->
                                                                       case /## ds1 b of wild32
                                                                       { __DEFAULT ->
                                                                       let {
                                                                         x10 :: Double#
                                                                         x10
                                                                           = sqrtDouble#
                                                                               (negateDouble#
                                                                                  wild32) } in
                                                                       let {
                                                                         x11 :: Double#
                                                                         x11
                                                                           = negateDouble# x10 } in
                                                                       let {
                                                                         r :: [Double]
                                                                         r = case _nearStart1 of {
                                                                               False ->
                                                                                 case tagToEnum#
                                                                                        (>=##
                                                                                           x11
                                                                                           0.0##)
                                                                                 of {
                                                                                   False -> [];
                                                                                   True ->
                                                                                     case tagToEnum#
                                                                                            (<=##
                                                                                               x11
                                                                                               1.0001##)
                                                                                     of {
                                                                                       False -> [];
                                                                                       True ->
                                                                                         : (D# x11)
                                                                                           []
                                                                                     }
                                                                                 };
                                                                               True ->
                                                                                 case tagToEnum#
                                                                                        (>=##
                                                                                           x11
                                                                                           1.0e-4##)
                                                                                 of {
                                                                                   False -> [];
                                                                                   True ->
                                                                                     case tagToEnum#
                                                                                            (<=##
                                                                                               x11
                                                                                               1.0001##)
                                                                                     of {
                                                                                       False -> [];
                                                                                       True ->
                                                                                         : (D# x11)
                                                                                           []
                                                                                     }
                                                                                 }
                                                                             } } in
                                                                       case _nearStart1 of {
                                                                         False ->
                                                                           case tagToEnum#
                                                                                  (>=## x10 0.0##)
                                                                           of {
                                                                             False -> r;
                                                                             True ->
                                                                               case tagToEnum#
                                                                                      (<=##
                                                                                         x10
                                                                                         1.0001##)
                                                                               of {
                                                                                 False -> r;
                                                                                 True ->
                                                                                   : (D# x10) r
                                                                               }
                                                                           };
                                                                         True ->
                                                                           case tagToEnum#
                                                                                  (>=##
                                                                                     x10 1.0e-4##)
                                                                           of {
                                                                             False -> r;
                                                                             True ->
                                                                               case tagToEnum#
                                                                                      (<=##
                                                                                         x10
                                                                                         1.0001##)
                                                                               of {
                                                                                 False -> r;
                                                                                 True ->
                                                                                   : (D# x10) r
                                                                               }
                                                                           }
                                                                       }
                                                                       }
                                                                   };
                                                                 True -> []
                                                               };
                                                             True ->
                                                               case /## ds1 c1 of wild30
                                                               { __DEFAULT ->
                                                               let {
                                                                 x9 :: Double#
                                                                 x9 = negateDouble# wild30 } in
                                                               case _nearStart1 of {
                                                                 False ->
                                                                   case tagToEnum# (>=## x9 0.0##)
                                                                   of {
                                                                     False -> [];
                                                                     True ->
                                                                       case tagToEnum#
                                                                              (<=## x9 1.0001##)
                                                                       of {
                                                                         False -> [];
                                                                         True -> : (D# x9) []
                                                                       }
                                                                   };
                                                                 True ->
                                                                   case tagToEnum#
                                                                          (>=## x9 1.0e-4##)
                                                                   of {
                                                                     False -> [];
                                                                     True ->
                                                                       case tagToEnum#
                                                                              (<=## x9 1.0001##)
                                                                       of {
                                                                         False -> [];
                                                                         True -> : (D# x9) []
                                                                       }
                                                                   }
                                                               }
                                                               }
                                                           } } in
                                                     case tagToEnum# (==## b 0.0##) of {
                                                       False -> jump $j2;
                                                       True ->
                                                         case tagToEnum# (==## c1 0.0##) of {
                                                           False -> jump $j2;
                                                           True -> []
                                                         }
                                                     } } in
                                               case tagToEnum# (==## b 0.0##) of {
                                                 False -> jump $j1;
                                                 True ->
                                                   case tagToEnum# (==## c1 0.0##) of {
                                                     False -> jump $j1;
                                                     True ->
                                                       case tagToEnum# (==## ds1 0.0##) of {
                                                         False -> jump $j1;
                                                         True ->
                                                           case _nearStart1 of {
                                                             False -> lvl53;
                                                             True -> []
                                                           }
                                                       }
                                                   }
                                               }
                                           } } in
                                     ((V2 (D# (+## x6 y6)) (D# (+## x7 y7))) `cast` <Co:37>, go tcs,
                                      ($fAlternativeSeq2
                                         (nt2 `cast` <Co:3>)
                                         (($fIsListSeq_mkTree
                                             ((map
                                                 (\ (x8 :: Double) ->
                                                    case x8 of { D# y8 ->
                                                    let {
                                                      y9 :: Double#
                                                      y9 = -## 1.0## y8 } in
                                                    D#
                                                      (+##
                                                         (+##
                                                            (+##
                                                               (*##
                                                                  (*## (*## (*## 3.0## y9) y9) y8)
                                                                  ds6)
                                                               (*##
                                                                  (*## (*## (*## 3.0## y9) y8) y8)
                                                                  ds5))
                                                            (*## (*## (*## y8 y8) y8) ds4))
                                                         ds7)
                                                    })
                                                 tcs)
                                              `cast` <Co:15>))
                                          `cast` <Co:15>))
                                      `cast` <Co:3>))
                                  }
                                  }
                                  }
                                  }
                                  }
                                  }
                                  }
                                  }
                                  }
                              }
                              }
                              }
                              }
                              }
                              }
                              })
                           `cast` <Co:86>)
                        `cast` <Co:84>)
                       (id `cast` <Co:27>)
                       (ww `cast` <Co:4>))
                    `cast` <Co:25>)
                     (id `cast` <Co:9>))
                  `cast` <Co:8>)
                   lvl51
            of
            { (a3, b4, c1) ->
            c1
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            } } in
      case tagToEnum# (>## ww3 0.0##) of {
        False ->
          join {
            $j1 :: Seq Double
            $j1
              = join {
                  $j2 :: Seq Double
                  $j2
                    = join {
                        $j3 :: Seq Double
                        $j3
                          = case tagToEnum# (==## ww4 0.0##) of {
                              False -> jump $w$j (+## ww3 ww4);
                              True ->
                                case tagToEnum# (<## ww3 0.0##) of {
                                  False ->
                                    case tagToEnum# (==## ww3 0.0##) of {
                                      False -> jump $w$j (+## ww3 ww4);
                                      True -> jump $w$j ww4
                                    };
                                  True -> jump $w$j 3.141592653589793##
                                }
                            } } in
                      case tagToEnum# (<=## ww3 0.0##) of {
                        False -> jump $j3;
                        True ->
                          case tagToEnum# (<## ww4 0.0##) of {
                            False -> jump $j3;
                            True ->
                              case tagToEnum# (==## ww3 0.0##) of {
                                False ->
                                  case /## (negateDouble# ww4) ww3 of wild7 { __DEFAULT ->
                                  jump $w$j
                                    (negateDouble# (+## 3.141592653589793## (atanDouble# wild7)))
                                  };
                                True -> jump $w$j -1.5707963267948966##
                              }
                          }
                      } } in
                case tagToEnum# (<## ww3 0.0##) of {
                  False -> jump $j2;
                  True ->
                    case tagToEnum# (>## ww4 0.0##) of {
                      False -> jump $j2;
                      True ->
                        case /## ww4 ww3 of wild4 { __DEFAULT ->
                        jump $w$j (+## 3.141592653589793## (atanDouble# wild4))
                        }
                    }
                } } in
          case tagToEnum# (==## ww3 0.0##) of {
            False -> jump $j1;
            True ->
              case tagToEnum# (>## ww4 0.0##) of {
                False -> jump $j1;
                True -> jump $w$j 1.5707963267948966##
              }
          };
        True ->
          case /## ww4 ww3 of wild4 { __DEFAULT ->
          jump $w$j (atanDouble# wild4)
          }
      }

-- RHS size: {terms: 30, types: 33, coercions: 3, joins: 0/0}
lineTrace_$slineTrace
  :: Line V2 Double -> Point V2 Double -> V2 Double -> Seq Double
lineTrace_$slineTrace
  = \ (w :: Line V2 Double)
      (w1 :: Point V2 Double)
      (w2 :: V2 Double) ->
      case w of { Line ww1 ww2 ->
      case w1 `cast` <Co:3> of { V2 ww4 ww5 ->
      case ww4 of { D# ww7 ->
      case ww5 of { D# ww9 ->
      case w2 of { V2 ww11 ww12 ->
      case ww11 of { D# ww14 ->
      case ww12 of { D# ww16 -> $w$slineTrace ww1 ww7 ww9 ww14 ww16 }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 1,827,
              types: 1,073,
              coercions: 632,
              joins: 12/100}
$wlineTrace
  :: forall n.
     OrderedField n =>
     Seq (Segment V2 n) -> n -> n -> n -> n -> Seq n
$wlineTrace
  = \ (@ n)
      (w :: OrderedField n)
      (ww
         :: Seq (Segment V2 n)
         Unf=OtherCon [])
      (ww1
         :: n
         Unf=OtherCon [])
      (ww2
         :: n
         Unf=OtherCon [])
      (ww3
         :: n
         Unf=OtherCon [])
      (ww4
         :: n
         Unf=OtherCon []) ->
      let {
        $dOrd1 :: Ord n
        $dOrd1 = $p2(%,%) w } in
      let {
        $dFloating1 :: Floating n
        $dFloating1 = $p1(%,%) w } in
      let {
        $dFractional1 :: Fractional n
        $dFractional1 = $p1Floating $dFloating1 } in
      let {
        $dNum1 :: Num n
        $dNum1 = $p1Fractional $dFractional1 } in
      join {
        $j :: n -> Seq n
        $j (nt :: n)
          = let {
              theta :: n
              theta = negate $dNum1 nt } in
            case cos $dFloating1 theta of dt7 { __DEFAULT ->
            let {
              s1 :: n
              s1 = sin $dFloating1 theta } in
            case negate $dNum1 s1 of dt8 { __DEFAULT ->
            case s1 of dt9 { __DEFAULT ->
            case fromInteger $dNum1 lvl4 of dt10 { __DEFAULT ->
            case fromInteger $dNum1 lineVertices3 of dt11 { __DEFAULT ->
            let {
              s :: n
              s = / $dFractional1
                    dt11
                    (sqrt $dFloating1 ($w$cquadrance $dNum1 ww3 ww4)) } in
            let {
              f3 :: n -> n
              f3 = * $dNum1 s } in
            case f3 dt11 of dt12 { __DEFAULT ->
            case f3 dt10 of dt13 { __DEFAULT ->
            case / $dFractional1 dt11 s of dt14 { __DEFAULT ->
            case / $dFractional1 dt10 s of dt15 { __DEFAULT ->
            case negate $dNum1 ww1 of dt16 { __DEFAULT ->
            case negate $dNum1 ww2 of dt17 { __DEFAULT ->
            case $wtappend
                   $fAdditiveV2
                   $fFoldableV2
                   $dNum1
                   (V2 (V2 dt7 dt8) (V2 dt9 dt7))
                   (V2 (V2 dt7 dt9) (V2 dt8 dt7))
                   (V2 dt10 dt10)
                   (V2 (V2 dt11 dt10) (V2 dt10 dt11))
                   (V2 (V2 dt11 dt10) (V2 dt10 dt11))
                   (V2 dt16 dt17)
            of
            { (# ww9, ww10, ww11 #) ->
            case $wtappend
                   $fAdditiveV2
                   $fFoldableV2
                   $dNum1
                   (V2 (V2 dt12 dt13) (V2 dt13 dt12))
                   (V2 (V2 dt14 dt15) (V2 dt15 dt14))
                   (V2 dt10 dt10)
                   ww9
                   ww10
                   ww11
            of
            { (# ww6, ww7, ww14 #) ->
            case ww6 of { V2 a5 b3 ->
            case a5 of { V2 ww16 ww17 ->
            case b3 of { V2 ww19 ww20 ->
            case ww14 of { V2 d e ->
            let {
              $dEq :: Eq n
              $dEq = $p1Ord $dOrd1 } in
            let {
              lvl77 :: n
              lvl77 = fromInteger $dNum1 lvl20 } in
            let {
              lvl78 :: n
              lvl78 = fromInteger $dNum1 lvl } in
            let {
              lvl79 :: n
              lvl79 = fromInteger $dNum1 lvl65 } in
            let {
              lvl80 :: n
              lvl80 = fromInteger $dNum1 lvl62 } in
            let {
              lvl81 :: n
              lvl81 = / $dFractional1 dt11 lvl77 } in
            let {
              lvl82 :: n
              lvl82 = / $dFractional1 dt11 lvl78 } in
            let {
              lvl83 :: n
              lvl83 = fromInteger $dNum1 lvl63 } in
            let {
              lvl84 :: n
              lvl84 = fromInteger $dNum1 lvl64 } in
            let {
              lvl85 :: n
              lvl85 = tau $dFloating1 } in
            let {
              lvl86 :: [n]
              lvl86 = : dt10 [] } in
            let {
              lvl87 :: n
              lvl87 = fromInteger $dNum1 lvl61 } in
            let {
              lvl88 :: n
              lvl88 = fromRational $dFractional1 lvl56 } in
            let {
              lvl89 :: n
              lvl89 = fromRational $dFractional1 lvl58 } in
            let {
              toler :: n
              toler = fromRational $dFractional1 lvl60 } in
            let {
              lvl90 :: n
              lvl90 = fromRational $dFractional1 lvl67 } in
            let {
              ds9 :: n
              ds9 = fromRational $dFractional1 lvl69 } in
            let {
              ds8 :: n
              ds8 = fromRational $dFractional1 lvl71 } in
            case (((($fEq1Seq_$cfoldr
                       ((\ (a1 :: Segment V2 n)
                           (fa
                              :: Const (Endo (Endo (Point V2 n, Bool, Seq n))) (Segment V2 n))
                           (eta :: Endo (Point V2 n, Bool, Seq n)) ->
                           let {
                             ds :: Endo (Point V2 n, Bool, Seq n)
                             ds = (fa `cast` <Co:25>) eta } in
                           (\ (z :: (Point V2 n, Bool, Seq n)) ->
                              case z of { (q, _nearStart, ts) ->
                              case q `cast` <Co:3> of { V2 ipv3 ipv4 ->
                              case _nearStart of _nearStart1 { __DEFAULT ->
                              case ts `cast` <Co:2> of nt2 { __DEFAULT ->
                              case a1 of {
                                Linear w1 ->
                                  case w1 of { V2 x5 y2 ->
                                  let {
                                    x4 :: n
                                    x4 = - $dNum1 (* $dNum1 ww3 y2) (* $dNum1 ww4 x5) } in
                                  let {
                                    pq :: V2 n
                                    pq
                                      = case $w$c^-^ $dNum1 ipv3 ipv4 ww1 ww2 of
                                        { (# ww22, ww23 #) ->
                                        V2 ww22 ww23
                                        } } in
                                  let {
                                    x3 :: n
                                    x3
                                      = case pq of { V2 x1 y1 ->
                                        - $dNum1 (* $dNum1 x1 ww4) (* $dNum1 y1 ww3)
                                        } } in
                                  join {
                                    $j1 :: (Point V2 n, Bool, Seq n)
                                    $j1
                                      = (ds `cast` <Co:8>)
                                          (case + $dNum1 ipv3 of dt18 { __DEFAULT ->
                                           case + $dNum1 ipv4 of dt19 { __DEFAULT ->
                                           case dt18 x5 of dt20 { __DEFAULT ->
                                           case dt19 y2 of dt21 { __DEFAULT ->
                                           (V2 dt20 dt21) `cast` <Co:37>
                                           }
                                           }
                                           }
                                           },
                                           False, nt2 `cast` <Co:3>) } in
                                  join {
                                    $j2 :: (Point V2 n, Bool, Seq n)
                                    $j2
                                      = let {
                                          tw :: n
                                          tw = / $dFractional1 x3 x4 } in
                                        case >= $dOrd1 tw dt10 of {
                                          False -> jump $j1;
                                          True ->
                                            case <= $dOrd1 tw lvl89 of {
                                              False -> jump $j1;
                                              True ->
                                                (ds `cast` <Co:8>)
                                                  (case + $dNum1 ipv3 of dt18 { __DEFAULT ->
                                                   case + $dNum1 ipv4 of dt19 { __DEFAULT ->
                                                   case dt18 x5 of dt20 { __DEFAULT ->
                                                   case dt19 y2 of dt21 { __DEFAULT ->
                                                   (V2 dt20 dt21) `cast` <Co:37>
                                                   }
                                                   }
                                                   }
                                                   },
                                                   > $dOrd1 tw lvl88,
                                                   ($b:|>_$ssnocTree
                                                      nt2
                                                      ((/ $dFractional1
                                                          (case pq of { V2 x1 y1 ->
                                                           - $dNum1
                                                             (* $dNum1 x1 y2)
                                                             (* $dNum1 y1 x5)
                                                           })
                                                          x4)
                                                       `cast` <Co:20>))
                                                   `cast` <Co:130>)
                                            }
                                        } } in
                                  case == $dEq x4 dt10 of {
                                    False -> jump $j2;
                                    True ->
                                      case /= $dEq x3 dt10 of {
                                        False -> jump $j2;
                                        True -> jump $j1
                                      }
                                  }
                                  };
                                Cubic ipv5 ipv6 ipv7 ->
                                  case ipv7 of { V2 d1 e1 ->
                                  case ipv6 of { V2 d2 e2 ->
                                  case ipv5 of { V2 d3 e3 ->
                                  (ds `cast` <Co:8>)
                                    (let {
                                       ds4 :: (V2 n, n)
                                       ds4
                                         = let {
                                             $wf3 :: n -> n -> Sum n
                                             $wf3
                                               = \ (ww21
                                                      :: n
                                                      Unf=OtherCon [])
                                                   (ww22
                                                      :: n
                                                      Unf=OtherCon []) ->
                                                   case * $dNum1 ww21 of dt18 { __DEFAULT ->
                                                   case * $dNum1 ww22 of dt19 { __DEFAULT ->
                                                   case dt18 d1 of dt20 { __DEFAULT ->
                                                   case dt19 e1 of dt21 { __DEFAULT ->
                                                   (+ $dNum1 dt20 dt21) `cast` <Co:3>
                                                   }
                                                   }
                                                   }
                                                   } } in
                                           case ($wf3 ww16 ww17) `cast` <Co:2> of dt18
                                           { __DEFAULT ->
                                           case ($wf3 ww19 ww20) `cast` <Co:2> of dt19
                                           { __DEFAULT ->
                                           (V2 dt18 dt19, dt19)
                                           }
                                           } } in
                                     let {
                                       ds5 :: (V2 n, n)
                                       ds5
                                         = let {
                                             $wf3 :: n -> n -> Sum n
                                             $wf3
                                               = \ (ww21
                                                      :: n
                                                      Unf=OtherCon [])
                                                   (ww22
                                                      :: n
                                                      Unf=OtherCon []) ->
                                                   case * $dNum1 ww21 of dt18 { __DEFAULT ->
                                                   case * $dNum1 ww22 of dt19 { __DEFAULT ->
                                                   case dt18 d2 of dt20 { __DEFAULT ->
                                                   case dt19 e2 of dt21 { __DEFAULT ->
                                                   (+ $dNum1 dt20 dt21) `cast` <Co:3>
                                                   }
                                                   }
                                                   }
                                                   } } in
                                           case ($wf3 ww16 ww17) `cast` <Co:2> of dt18
                                           { __DEFAULT ->
                                           case ($wf3 ww19 ww20) `cast` <Co:2> of dt19
                                           { __DEFAULT ->
                                           (V2 dt18 dt19, dt19)
                                           }
                                           } } in
                                     let {
                                       ds6 :: (V2 n, n)
                                       ds6
                                         = let {
                                             $wf3 :: n -> n -> Sum n
                                             $wf3
                                               = \ (ww21
                                                      :: n
                                                      Unf=OtherCon [])
                                                   (ww22
                                                      :: n
                                                      Unf=OtherCon []) ->
                                                   case * $dNum1 ww21 of dt18 { __DEFAULT ->
                                                   case * $dNum1 ww22 of dt19 { __DEFAULT ->
                                                   case dt18 d3 of dt20 { __DEFAULT ->
                                                   case dt19 e3 of dt21 { __DEFAULT ->
                                                   (+ $dNum1 dt20 dt21) `cast` <Co:3>
                                                   }
                                                   }
                                                   }
                                                   } } in
                                           case ($wf3 ww16 ww17) `cast` <Co:2> of dt18
                                           { __DEFAULT ->
                                           case ($wf3 ww19 ww20) `cast` <Co:2> of dt19
                                           { __DEFAULT ->
                                           (V2 dt18 dt19, dt19)
                                           }
                                           } } in
                                     let {
                                       ds7 :: (n, n)
                                       ds7
                                         = let {
                                             $wf4 :: n -> n -> Sum n
                                             $wf4
                                               = \ (ww21
                                                      :: n
                                                      Unf=OtherCon [])
                                                   (ww22
                                                      :: n
                                                      Unf=OtherCon []) ->
                                                   case * $dNum1 ww21 of dt18 { __DEFAULT ->
                                                   case * $dNum1 ww22 of dt19 { __DEFAULT ->
                                                   case dt18 ipv3 of dt20 { __DEFAULT ->
                                                   case dt19 ipv4 of dt21 { __DEFAULT ->
                                                   (+ $dNum1 dt20 dt21) `cast` <Co:3>
                                                   }
                                                   }
                                                   }
                                                   } } in
                                           case ($wf4 ww16 ww17) `cast` <Co:2> of dt18
                                           { __DEFAULT ->
                                           case ($wf4 ww19 ww20) `cast` <Co:2> of dt19
                                           { __DEFAULT ->
                                           case + $dNum1 dt18 of dt20 { __DEFAULT ->
                                           case + $dNum1 dt19 of dt21 { __DEFAULT ->
                                           case dt20 d of dt22 { __DEFAULT ->
                                           case dt21 e of dt23 { __DEFAULT -> (dt22, dt23) }
                                           }
                                           }
                                           }
                                           }
                                           } } in
                                     let {
                                       tcs :: [n]
                                       tcs
                                         = let {
                                             y1 :: n
                                             y1 = case ds6 of { (c1', y4) -> y4 } } in
                                           let {
                                             y2 :: n
                                             y2 = case ds5 of { (c2', y4) -> y4 } } in
                                           let {
                                             a :: n
                                             a = + $dNum1
                                                   (- $dNum1
                                                      (* $dNum1 lvl77 y1)
                                                      (* $dNum1 lvl77 y2))
                                                   (case ds4 of { (c3', y3) -> y3 }) } in
                                           let {
                                             d4 :: n
                                             d4 = case ds7 of { (qx, qy) -> qy } } in
                                           let {
                                             b :: n
                                             b = + $dNum1
                                                   (negate $dNum1 (* $dNum1 lvl87 y1))
                                                   (* $dNum1 lvl77 y2) } in
                                           let {
                                             c1 :: n
                                             c1 = * $dNum1 lvl77 y1 } in
                                           let {
                                             ds1 :: n
                                             ds1
                                               = case _nearStart1 of {
                                                   False -> dt10;
                                                   True -> lvl90
                                                 } } in
                                           let {
                                             arg :: n -> Bool
                                             arg
                                               = \ (x3 :: n) ->
                                                   case >= $dOrd1 x3 ds1 of {
                                                     False -> False;
                                                     True -> <= $dOrd1 x3 ds9
                                                   } } in
                                           case < $dOrd1 (abs $dNum1 a) toler of {
                                             False ->
                                               let {
                                                 delta :: n
                                                 delta
                                                   = - $dNum1
                                                       (- $dNum1
                                                          (+ $dNum1
                                                             (- $dNum1
                                                                (* $dNum1
                                                                   (* $dNum1
                                                                      (* $dNum1
                                                                         (* $dNum1 lvl84 a)
                                                                         b)
                                                                      c1)
                                                                   d4)
                                                                (* $dNum1
                                                                   (* $dNum1
                                                                      lvl79
                                                                      (* $dNum1 (* $dNum1 b b) b))
                                                                   d4))
                                                             (* $dNum1
                                                                (* $dNum1 b b)
                                                                (* $dNum1 c1 c1)))
                                                          (* $dNum1
                                                             (* $dNum1 lvl79 a)
                                                             (* $dNum1 (* $dNum1 c1 c1) c1)))
                                                       (* $dNum1
                                                          (* $dNum1 lvl83 (* $dNum1 a a))
                                                          (* $dNum1 d4 d4)) } in
                                               let {
                                                 xx :: n
                                                 xx
                                                   = + $dNum1
                                                       (- $dNum1
                                                          (* $dNum1
                                                             lvl78
                                                             (* $dNum1 (* $dNum1 b b) b))
                                                          (* $dNum1
                                                             (* $dNum1 (* $dNum1 lvl80 a) b)
                                                             c1))
                                                       (* $dNum1
                                                          (* $dNum1 lvl83 (* $dNum1 a a))
                                                          d4) } in
                                               let {
                                                 disc :: n
                                                 disc
                                                   = - $dNum1
                                                       (* $dNum1 (* $dNum1 lvl77 a) c1)
                                                       (* $dNum1 b b) } in
                                               case > $dOrd1 delta dt10 of {
                                                 False ->
                                                   join {
                                                     $j1 :: [n]
                                                     $j1
                                                       = join {
                                                           $j2 :: [n]
                                                           $j2
                                                             = let {
                                                                 x :: n
                                                                 x = let {
                                                                       cc :: n
                                                                       cc
                                                                         = let {
                                                                             x3 :: n
                                                                             x3
                                                                               = * $dNum1
                                                                                   lvl82
                                                                                   (+ $dNum1
                                                                                      (let {
                                                                                         qq :: n
                                                                                         qq
                                                                                           = sqrt
                                                                                               $dFloating1
                                                                                               (negate
                                                                                                  $dNum1
                                                                                                  (* $dNum1
                                                                                                     (* $dNum1
                                                                                                        lvl83
                                                                                                        (* $dNum1
                                                                                                           a
                                                                                                           a))
                                                                                                     delta)) } in
                                                                                       case < $dOrd1
                                                                                              (abs
                                                                                                 $dNum1
                                                                                                 disc)
                                                                                              toler
                                                                                       of {
                                                                                         False ->
                                                                                           qq;
                                                                                         True ->
                                                                                           let {
                                                                                             xs :: n
                                                                                             xs
                                                                                               = negate
                                                                                                   $dNum1
                                                                                                   qq } in
                                                                                           case compare
                                                                                                  $dOrd1
                                                                                                  (abs
                                                                                                     $dNum1
                                                                                                     (+ $dNum1
                                                                                                        qq
                                                                                                        xx))
                                                                                                  (abs
                                                                                                     $dNum1
                                                                                                     (+ $dNum1
                                                                                                        xs
                                                                                                        xx))
                                                                                           of {
                                                                                             __DEFAULT ->
                                                                                               xs;
                                                                                             GT ->
                                                                                               qq
                                                                                           }
                                                                                       })
                                                                                      xx) } in
                                                                           case < $dOrd1 x3 dt10
                                                                           of {
                                                                             False ->
                                                                               **
                                                                                 $dFloating1
                                                                                 x3
                                                                                 lvl81;
                                                                             True ->
                                                                               negate
                                                                                 $dNum1
                                                                                 (**
                                                                                    $dFloating1
                                                                                    (negate
                                                                                       $dNum1 x3)
                                                                                    lvl81)
                                                                           } } in
                                                                     + $dNum1
                                                                       (- $dNum1
                                                                          (negate
                                                                             $dNum1
                                                                             (/ $dFractional1
                                                                                b
                                                                                (* $dNum1 lvl77 a)))
                                                                          (/ $dFractional1
                                                                             cc
                                                                             (* $dNum1 lvl77 a)))
                                                                       (/ $dFractional1
                                                                          disc
                                                                          (* $dNum1
                                                                             (* $dNum1 lvl77 a)
                                                                             cc)) } in
                                                               case arg x of {
                                                                 False -> [];
                                                                 True -> : x []
                                                               } } in
                                                         case == $dEq delta dt10 of {
                                                           False -> jump $j2;
                                                           True ->
                                                             case /= $dEq disc dt10 of {
                                                               False -> jump $j2;
                                                               True ->
                                                                 let {
                                                                   x :: n
                                                                   x = / $dFractional1
                                                                         (- $dNum1
                                                                            (* $dNum1 b c1)
                                                                            (* $dNum1
                                                                               (* $dNum1 lvl80 a)
                                                                               d4))
                                                                         (* $dNum1 lvl78 disc) } in
                                                                 let {
                                                                   r :: [n]
                                                                   r = let {
                                                                         x1 :: n
                                                                         x1
                                                                           = / $dFractional1
                                                                               (+ $dNum1
                                                                                  (- $dNum1
                                                                                     (* $dNum1
                                                                                        (* $dNum1
                                                                                           lvl80
                                                                                           (* $dNum1
                                                                                              a
                                                                                              a))
                                                                                        d4)
                                                                                     (* $dNum1
                                                                                        (* $dNum1
                                                                                           (* $dNum1
                                                                                              lvl79
                                                                                              a)
                                                                                           b)
                                                                                        c1))
                                                                                  (* $dNum1
                                                                                     (* $dNum1 b b)
                                                                                     b))
                                                                               (* $dNum1
                                                                                  a
                                                                                  disc) } in
                                                                       case arg x1 of {
                                                                         False -> [];
                                                                         True -> : x1 []
                                                                       } } in
                                                                 case arg x of {
                                                                   False -> r;
                                                                   True -> : x r
                                                                 }
                                                             }
                                                         } } in
                                                   case == $dEq delta dt10 of {
                                                     False -> jump $j1;
                                                     True ->
                                                       case == $dEq disc dt10 of {
                                                         False -> jump $j1;
                                                         True ->
                                                           let {
                                                             x :: n
                                                             x = negate
                                                                   $dNum1
                                                                   (/ $dFractional1
                                                                      b
                                                                      (* $dNum1 lvl77 a)) } in
                                                           case arg x of {
                                                             False -> [];
                                                             True -> : x []
                                                           }
                                                       }
                                                   };
                                                 True ->
                                                   let {
                                                     lvl91 :: n
                                                     lvl91
                                                       = / $dFractional1 b (* $dNum1 lvl77 a) } in
                                                   let {
                                                     p1 :: n
                                                     p1
                                                       = / $dFractional1
                                                           disc
                                                           (* $dNum1 lvl77 (* $dNum1 a a)) } in
                                                   let {
                                                     lvl92 :: n
                                                     lvl92
                                                       = * $dNum1
                                                           lvl78
                                                           (sqrt
                                                              $dFloating1
                                                              (negate
                                                                 $dNum1
                                                                 (/ $dFractional1 p1 lvl77))) } in
                                                   let {
                                                     phi :: n
                                                     phi
                                                       = * $dNum1
                                                           lvl81
                                                           (acos
                                                              $dFloating1
                                                              (* $dNum1
                                                                 (/ $dFractional1
                                                                    (* $dNum1
                                                                       lvl77
                                                                       (/ $dFractional1
                                                                          xx
                                                                          (* $dNum1
                                                                             lvl83
                                                                             (* $dNum1
                                                                                (* $dNum1 a a)
                                                                                a))))
                                                                    (* $dNum1 lvl78 p1))
                                                                 (sqrt
                                                                    $dFloating1
                                                                    (negate
                                                                       $dNum1
                                                                       (/ $dFractional1
                                                                          lvl77
                                                                          p1))))) } in
                                                   let {
                                                     c3 :: n -> n
                                                     c3
                                                       = \ (k :: n) ->
                                                           - $dNum1
                                                             (* $dNum1
                                                                lvl92
                                                                (cos
                                                                   $dFloating1
                                                                   (- $dNum1
                                                                      phi
                                                                      (/ $dFractional1
                                                                         (* $dNum1 k lvl85)
                                                                         lvl77))))
                                                             lvl91 } in
                                                   let {
                                                     x :: n
                                                     x = c3 dt10 } in
                                                   let {
                                                     r :: [n]
                                                     r = let {
                                                           x1 :: n
                                                           x1 = c3 dt11 } in
                                                         let {
                                                           r1 :: [n]
                                                           r1
                                                             = let {
                                                                 x2 :: n
                                                                 x2 = c3 lvl78 } in
                                                               case arg x2 of {
                                                                 False -> [];
                                                                 True -> : x2 []
                                                               } } in
                                                         case arg x1 of {
                                                           False -> r1;
                                                           True -> : x1 r1
                                                         } } in
                                                   case arg x of {
                                                     False -> r;
                                                     True -> : x r
                                                   }
                                               };
                                             True ->
                                               join {
                                                 $j1 :: [n]
                                                 $j1
                                                   = join {
                                                       $j2 :: [n]
                                                       $j2
                                                         = case == $dEq b dt10 of {
                                                             False ->
                                                               let {
                                                                 d5 :: n
                                                                 d5
                                                                   = - $dNum1
                                                                       (* $dNum1 c1 c1)
                                                                       (* $dNum1
                                                                          (* $dNum1 lvl79 b)
                                                                          d4) } in
                                                               case < $dOrd1 d5 dt10 of {
                                                                 False ->
                                                                   case == $dEq c1 dt10 of {
                                                                     False ->
                                                                       case == $dEq d5 dt10 of {
                                                                         False ->
                                                                           let {
                                                                             q1 :: n
                                                                             q1
                                                                               = negate
                                                                                   $dNum1
                                                                                   (* $dNum1
                                                                                      lvl82
                                                                                      (+ $dNum1
                                                                                         c1
                                                                                         (* $dNum1
                                                                                            (signum
                                                                                               $dNum1
                                                                                               c1)
                                                                                            (sqrt
                                                                                               $dFloating1
                                                                                               d5)))) } in
                                                                           let {
                                                                             x :: n
                                                                             x = / $dFractional1
                                                                                   q1
                                                                                   b } in
                                                                           let {
                                                                             r :: [n]
                                                                             r = let {
                                                                                   x1 :: n
                                                                                   x1
                                                                                     = / $dFractional1
                                                                                         d4
                                                                                         q1 } in
                                                                                 case arg x1 of {
                                                                                   False -> [];
                                                                                   True -> : x1 []
                                                                                 } } in
                                                                           case arg x of {
                                                                             False -> r;
                                                                             True -> : x r
                                                                           };
                                                                         True ->
                                                                           let {
                                                                             x :: n
                                                                             x = negate
                                                                                   $dNum1
                                                                                   (/ $dFractional1
                                                                                      c1
                                                                                      (* $dNum1
                                                                                         lvl78
                                                                                         b)) } in
                                                                           case arg x of {
                                                                             False -> [];
                                                                             True -> : x []
                                                                           }
                                                                       };
                                                                     True ->
                                                                       let {
                                                                         x :: n
                                                                         x = sqrt
                                                                               $dFloating1
                                                                               (negate
                                                                                  $dNum1
                                                                                  (/ $dFractional1
                                                                                     d4
                                                                                     b)) } in
                                                                       let {
                                                                         r :: [n]
                                                                         r = let {
                                                                               x1 :: n
                                                                               x1
                                                                                 = negate
                                                                                     $dNum1 x } in
                                                                             case arg x1 of {
                                                                               False -> [];
                                                                               True -> : x1 []
                                                                             } } in
                                                                       case arg x of {
                                                                         False -> r;
                                                                         True -> : x r
                                                                       }
                                                                   };
                                                                 True -> []
                                                               };
                                                             True ->
                                                               let {
                                                                 x :: n
                                                                 x = negate
                                                                       $dNum1
                                                                       (/ $dFractional1 d4 c1) } in
                                                               case arg x of {
                                                                 False -> [];
                                                                 True -> : x []
                                                               }
                                                           } } in
                                                     case == $dEq b dt10 of {
                                                       False -> jump $j2;
                                                       True ->
                                                         case == $dEq c1 dt10 of {
                                                           False -> jump $j2;
                                                           True -> []
                                                         }
                                                     } } in
                                               case == $dEq b dt10 of {
                                                 False -> jump $j1;
                                                 True ->
                                                   case == $dEq c1 dt10 of {
                                                     False -> jump $j1;
                                                     True ->
                                                       case == $dEq d4 dt10 of {
                                                         False -> jump $j1;
                                                         True ->
                                                           case arg dt10 of {
                                                             False -> [];
                                                             True -> lvl86
                                                           }
                                                       }
                                                   }
                                               }
                                           } } in
                                     (case + $dNum1 ipv3 of dt18 { __DEFAULT ->
                                      case + $dNum1 ipv4 of dt19 { __DEFAULT ->
                                      case dt18 d1 of dt20 { __DEFAULT ->
                                      case dt19 e1 of dt21 { __DEFAULT ->
                                      (V2 dt20 dt21) `cast` <Co:37>
                                      }
                                      }
                                      }
                                      },
                                      joinrec {
                                        go1 :: [n] -> Bool
                                        go1 (ds1 :: [n])
                                          = case ds1 of {
                                              [] -> False;
                                              : y ys ->
                                                case > $dOrd1 y ds8 of {
                                                  False -> jump go1 ys;
                                                  True -> True
                                                }
                                            }; } in
                                      jump go1 tcs,
                                      ($fAlternativeSeq2
                                         (nt2 `cast` <Co:3>)
                                         (($fIsListSeq_mkTree
                                             ((map
                                                 (let {
                                                    ds1 :: n
                                                    ds1 = case ds7 of { (qx, qy) -> qx } } in
                                                  let {
                                                    g :: Segment V2 n
                                                    g = case ds6 of { (c1', y4) ->
                                                        case ds5 of { (c2', y5) ->
                                                        case ds4 of { (c3', y3) ->
                                                        case c1' of dt18 { V2 ipv ipv1 ->
                                                        case c2' of dt19 { V2 ipv2 ipv9 ->
                                                        case c3' of dt20 { V2 ipv10 ipv11 ->
                                                        Cubic dt18 dt19 dt20
                                                        }
                                                        }
                                                        }
                                                        }
                                                        }
                                                        } } in
                                                  \ (x3 :: n) ->
                                                    + $dNum1
                                                      (case g of {
                                                         Linear x4 ->
                                                           case x4 of { V2 a2 b1 ->
                                                           let {
                                                             f4 :: n -> n
                                                             f4 = * $dNum1 x3 } in
                                                           case f4 a2 of dt18 { __DEFAULT ->
                                                           case f4 b1 of { __DEFAULT -> dt18 }
                                                           }
                                                           };
                                                         Cubic c2 c3 x4 ->
                                                           case x4 of { V2 a2 b1 ->
                                                           case c3 of { V2 a3 b2 ->
                                                           case c2 of { V2 a4 b4 ->
                                                           let {
                                                             t' :: n
                                                             t' = - $dNum1 dt11 x3 } in
                                                           let {
                                                             f4 :: n -> n
                                                             f4
                                                               = * $dNum1
                                                                   (* $dNum1
                                                                      (* $dNum1
                                                                         (* $dNum1 lvl77 t')
                                                                         t')
                                                                      x3) } in
                                                           case f4 a4 of dt18 { __DEFAULT ->
                                                           case f4 b4 of dt19 { __DEFAULT ->
                                                           case + $dNum1 dt18 of dt20 { __DEFAULT ->
                                                           case + $dNum1 dt19 of dt21 { __DEFAULT ->
                                                           let {
                                                             f5 :: n -> n
                                                             f5
                                                               = * $dNum1
                                                                   (* $dNum1
                                                                      (* $dNum1
                                                                         (* $dNum1 lvl77 t')
                                                                         x3)
                                                                      x3) } in
                                                           case f5 a3 of dt22 { __DEFAULT ->
                                                           case f5 b2 of dt23 { __DEFAULT ->
                                                           case dt20 dt22 of dt24 { __DEFAULT ->
                                                           case dt21 dt23 of dt25 { __DEFAULT ->
                                                           case + $dNum1 dt24 of dt26 { __DEFAULT ->
                                                           case + $dNum1 dt25 of dt27 { __DEFAULT ->
                                                           let {
                                                             f6 :: n -> n
                                                             f6
                                                               = * $dNum1
                                                                   (* $dNum1
                                                                      (* $dNum1 x3 x3)
                                                                      x3) } in
                                                           case f6 a2 of dt28 { __DEFAULT ->
                                                           case f6 b1 of dt29 { __DEFAULT ->
                                                           case dt26 dt28 of dt30 { __DEFAULT ->
                                                           case dt27 dt29 of { __DEFAULT -> dt30 }
                                                           }
                                                           }
                                                           }
                                                           }
                                                           }
                                                           }
                                                           }
                                                           }
                                                           }
                                                           }
                                                           }
                                                           }
                                                           }
                                                           }
                                                           }
                                                           }
                                                       })
                                                      ds1)
                                                 tcs)
                                              `cast` <Co:15>))
                                          `cast` <Co:15>))
                                      `cast` <Co:3>))
                                  }
                                  }
                                  }
                              }
                              }
                              }
                              }
                              })
                           `cast` <Co:86>)
                        `cast` <Co:84>)
                       (id `cast` <Co:27>)
                       (ww `cast` <Co:4>))
                    `cast` <Co:25>)
                     (id `cast` <Co:9>))
                  `cast` <Co:8>)
                   ((V2 dt10 dt10) `cast` <Co:4>, False, EmptyT `cast` <Co:3>)
            of
            { (a1, b1, c1) ->
            c1
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            }
            } } in
      case > $dOrd1 ww3 (fromInteger $dNum1 lvl4) of {
        False ->
          let {
            $dEq1 :: Eq n
            $dEq1 = $p1Ord $dOrd1 } in
          join {
            $j1 :: Seq n
            $j1
              = join {
                  $j2 :: Seq n
                  $j2
                    = join {
                        $j3 :: Seq n
                        $j3
                          = join {
                              $j4 :: Seq n
                              $j4
                                = case == $dEq1 ww3 (fromInteger $dNum1 lvl4) of {
                                    False ->
                                      case + $dNum1 ww3 ww4 of nt { __DEFAULT -> jump $j nt };
                                    True ->
                                      case == $dEq1 ww4 (fromInteger $dNum1 lvl4) of {
                                        False ->
                                          case + $dNum1 ww3 ww4 of nt { __DEFAULT -> jump $j nt };
                                        True -> jump $j ww4
                                      }
                                  } } in
                            case == $dEq1 ww4 (fromInteger $dNum1 lvl4) of {
                              False -> jump $j4;
                              True ->
                                case < $dOrd1 ww3 (fromInteger $dNum1 lvl4) of {
                                  False -> jump $j4;
                                  True -> case pi $dFloating1 of nt { __DEFAULT -> jump $j nt }
                                }
                            } } in
                      case <= $dOrd1 ww3 (fromInteger $dNum1 lvl4) of {
                        False -> jump $j3;
                        True ->
                          case < $dOrd1 ww4 (fromInteger $dNum1 lvl4) of {
                            False -> jump $j3;
                            True ->
                              case negate
                                     $dNum1
                                     (case negate $dNum1 ww4 of y2 { __DEFAULT ->
                                      case == $dEq1 ww3 (fromInteger $dNum1 lvl4) of {
                                        False ->
                                          + $dNum1
                                            (pi $dFloating1)
                                            (atan $dFloating1 (/ $dFractional1 y2 ww3));
                                        True ->
                                          / $dFractional1 (pi $dFloating1) (fromInteger $dNum1 lvl)
                                      }
                                      })
                              of nt
                              { __DEFAULT ->
                              jump $j nt
                              }
                          }
                      } } in
                case < $dOrd1 ww3 (fromInteger $dNum1 lvl4) of {
                  False -> jump $j2;
                  True ->
                    case > $dOrd1 ww4 (fromInteger $dNum1 lvl4) of {
                      False -> jump $j2;
                      True ->
                        case + $dNum1
                               (pi $dFloating1)
                               (atan $dFloating1 (/ $dFractional1 ww4 ww3))
                        of nt
                        { __DEFAULT ->
                        jump $j nt
                        }
                    }
                } } in
          case == $dEq1 ww3 (fromInteger $dNum1 lvl4) of {
            False -> jump $j1;
            True ->
              case > $dOrd1 ww4 (fromInteger $dNum1 lvl4) of {
                False -> jump $j1;
                True ->
                  case / $dFractional1 (pi $dFloating1) (fromInteger $dNum1 lvl)
                  of nt
                  { __DEFAULT ->
                  jump $j nt
                  }
              }
          };
        True ->
          case atan $dFloating1 (/ $dFractional1 ww4 ww3) of nt
          { __DEFAULT ->
          jump $j nt
          }
      }

-- RHS size: {terms: 21, types: 30, coercions: 3, joins: 0/0}
lineTrace
  :: forall n.
     OrderedField n =>
     Line V2 n -> Point V2 n -> V2 n -> Seq n
lineTrace
  = \ (@ n)
      (w :: OrderedField n)
      (w1 :: Line V2 n)
      (w2 :: Point V2 n)
      (w3 :: V2 n) ->
      case w1 of { Line ww1 ww2 ->
      case w2 `cast` <Co:3> of { V2 ww4 ww5 ->
      case w3 of { V2 ww7 ww8 -> $wlineTrace w ww1 ww4 ww5 ww7 ww8 }
      }
      }

-- RHS size: {terms: 8, types: 12, coercions: 33, joins: 0/0}
$fTracedLine :: forall n. OrderedField n => Traced (Line V2 n)
$fTracedLine
  = \ (@ n) ($d(%,%) :: OrderedField n) ->
      C:Traced
        ($fAdditiveV2 `cast` <Co:5>)
        (($p2(%,%) $d(%,%)) `cast` <Co:5>)
        ((lineTrace $d(%,%)) `cast` <Co:23>)

-- RHS size: {terms: 76, types: 84, coercions: 6, joins: 0/0}
trailTrace_$strailTrace
  :: Trail V2 Double -> Point V2 Double -> V2 Double -> Seq Double
trailTrace_$strailTrace
  = \ (t :: Trail V2 Double)
      (p :: Point V2 Double)
      (v :: V2 Double) ->
      case t of {
        OpenTrail l ->
          case l of { Line ww1 ww2 ->
          case p `cast` <Co:3> of { V2 ww4 ww5 ->
          case ww4 of { D# ww7 ->
          case ww5 of { D# ww9 ->
          case v of { V2 ww11 ww12 ->
          case ww11 of { D# ww14 ->
          case ww12 of { D# ww16 -> $w$slineTrace ww1 ww7 ww9 ww14 ww16 }
          }
          }
          }
          }
          }
          };
        ClosedTrail l ->
          case l of { Loop ww1 ww2 ->
          case ww1 of { Line ww4 ww5 ->
          case ww5 of { V2 ww7 ww8 ->
          case ww7 of { D# ww10 ->
          case ww8 of { D# ww12 ->
          case p `cast` <Co:3> of { V2 ww14 ww15 ->
          case ww14 of { D# ww17 ->
          case ww15 of { D# ww19 ->
          case v of { V2 ww21 ww22 ->
          case ww21 of { D# ww24 ->
          case ww22 of { D# ww26 ->
          $w$sloopTrace ww4 ww10 ww12 ww2 ww17 ww19 ww24 ww26
          }
          }
          }
          }
          }
          }
          }
          }
          }
          }
          }
      }

-- RHS size: {terms: 40, types: 53, coercions: 0, joins: 0/0}
$wtrailTrace
  :: forall n.
     OrderedField n =>
     Trail V2 n -> n -> n -> n -> n -> Seq n
$wtrailTrace
  = \ (@ n)
      (w :: OrderedField n)
      (w1 :: Trail V2 n)
      (ww
         :: n
         Unf=OtherCon [])
      (ww1
         :: n
         Unf=OtherCon [])
      (ww2
         :: n
         Unf=OtherCon [])
      (ww3
         :: n
         Unf=OtherCon []) ->
      case w1 of {
        OpenTrail l ->
          case l of { Line ww5 ww6 -> $wlineTrace w ww5 ww ww1 ww2 ww3 };
        ClosedTrail l ->
          case l of { Loop ww5 ww6 ->
          case ww5 of { Line ww8 ww9 ->
          case ww9 of { V2 ww11 ww12 ->
          $wloopTrace w ww8 ww11 ww12 ww6 ww ww1 ww2 ww3
          }
          }
          }
      }

-- RHS size: {terms: 18, types: 21, coercions: 3, joins: 0/0}
trailTrace
  :: forall n.
     OrderedField n =>
     Trail V2 n -> Point V2 n -> V2 n -> Seq n
trailTrace
  = \ (@ n)
      (w :: OrderedField n)
      (w1 :: Trail V2 n)
      (w2 :: Point V2 n)
      (w3 :: V2 n) ->
      case w2 `cast` <Co:3> of { V2 ww1 ww2 ->
      case w3 of { V2 ww4 ww5 -> $wtrailTrace w w1 ww1 ww2 ww4 ww5 }
      }

-- RHS size: {terms: 8, types: 12, coercions: 23, joins: 0/0}
$fTracedTrail :: forall n. OrderedField n => Traced (Trail V2 n)
$fTracedTrail
  = \ (@ n) ($d(%,%) :: OrderedField n) ->
      C:Traced
        ($fAdditiveV2 `cast` <Co:5>)
        (($p2(%,%) $d(%,%)) `cast` <Co:5>)
        ((trailTrace $d(%,%)) `cast` <Co:13>)

-- RHS size: {terms: 4, types: 1, coercions: 0, joins: 0/0}
lineEnv3 :: V3 Double
lineEnv3 = V3 lineEnv_a1 lineEnv_a1 lineEnv_a1

-- RHS size: {terms: 3, types: 1, coercions: 0, joins: 0/0}
lineEnv2 :: Interval Double
lineEnv2 = I lineEnv_a1 lineEnv_a1

-- RHS size: {terms: 3, types: 5, coercions: 4, joins: 0/0}
lineEnv1 :: Pair (Point V3 Double) (Interval Double)
lineEnv1 = Pair (lineEnv3 `cast` <Co:4>) lineEnv2

-- RHS size: {terms: 226, types: 190, coercions: 130, joins: 3/11}
$w$slineEnv
  :: Seq (Segment V3 Double)
     -> Double# -> Double# -> Double# -> Interval Double
$w$slineEnv
  = \ (ww
         :: Seq (Segment V3 Double)
         Unf=OtherCon [])
      (ww1 :: Double#)
      (ww2 :: Double#)
      (ww3 :: Double#) ->
      let {
        ipv :: Double
        ipv = D# ww3 } in
      let {
        ipv1 :: Double
        ipv1 = D# ww2 } in
      let {
        ipv2 :: Double
        ipv2 = D# ww1 } in
      let {
        w :: V3 Double
        w = V3 ipv2 ipv1 ipv } in
      case $fFoldableFingerTree_$cfoldl'
             ((\ (ds :: Pair (Point V3 Double) (Interval Double))
                 (seg :: Segment V3 Double) ->
                 case ds of { Pair p e ->
                 case p `cast` <Co:33> of { V3 a1 b1 c ->
                 case a1 of { D# x ->
                 case b1 of { D# x1 ->
                 case c of { D# x2 ->
                 case e of { I a2 b ->
                 case a2 of wild6 { D# x3 ->
                 case b of wild7 { D# x4 ->
                 join {
                   $w$j
                     :: Double#
                        -> Double# -> Double# -> Pair (Point V3 Double) (Interval Double)
                   $w$j (ww4 :: Double#) (ww5 :: Double#) (ww6 :: Double#)
                     = join {
                         $w$j1
                           :: Double# -> Double# -> Pair (Point V3 Double) (Interval Double)
                         $w$j1 (ww7 :: Double#) (ww8 :: Double#)
                           = let {
                               y :: Double#
                               y = +## (+## (*## x ww1) (*## x1 ww2)) (*## x2 ww3) } in
                             let {
                               dt7 :: Double#
                               dt7 = +## ww7 y } in
                             join {
                               $j :: Double -> Pair (Point V3 Double) (Interval Double)
                               $j (dt8 :: Double)
                                 = let {
                                     dt9 :: Double#
                                     dt9 = +## ww8 y } in
                                   case tagToEnum# (<=## x4 dt9) of {
                                     False ->
                                       Pair
                                         ((V3 (D# (+## x ww4)) (D# (+## x1 ww5)) (D# (+## x2 ww6)))
                                          `cast` <Co:37>)
                                         (I dt8 wild7);
                                     True ->
                                       Pair
                                         ((V3 (D# (+## x ww4)) (D# (+## x1 ww5)) (D# (+## x2 ww6)))
                                          `cast` <Co:37>)
                                         (I dt8 (D# dt9))
                                   } } in
                             case tagToEnum# (<=## x3 dt7) of {
                               False -> jump $j (D# dt7);
                               True -> jump $j wild6
                             } } in
                       case seg of {
                         Linear l ->
                           case l of { V3 ww8 ww9 ww10 ->
                           case ww8 of { D# x5 ->
                           case ww9 of { D# x6 ->
                           case ww10 of { D# x7 ->
                           let {
                             ipv3 :: Double#
                             ipv3 = +## (+## (*## x5 ww1) (*## x6 ww2)) (*## x7 ww3) } in
                           case tagToEnum# (<## ipv3 0.0##) of {
                             False -> jump $w$j1 0.0## ipv3;
                             True -> jump $w$j1 ipv3 0.0##
                           }
                           }
                           }
                           }
                           };
                         Cubic c1 c2 c3 ->
                           case cubicEnvelope_$scubicEnvelope c1 c2 c3 w of { I a b2 ->
                           case a of { D# ww8 ->
                           case b2 of { D# ww10 -> jump $w$j1 ww8 ww10 }
                           }
                           }
                       } } in
                 case seg of {
                   Linear v1 ->
                     case v1 of { V3 d e1 f3 ->
                     case d of { D# ww5 ->
                     case e1 of { D# ww7 ->
                     case f3 of { D# ww9 -> jump $w$j ww5 ww7 ww9 }
                     }
                     }
                     };
                   Cubic ds1 ds2 v1 ->
                     case v1 of { V3 d e1 f3 ->
                     case d of { D# ww5 ->
                     case e1 of { D# ww7 ->
                     case f3 of { D# ww9 -> jump $w$j ww5 ww7 ww9 }
                     }
                     }
                     }
                 }
                 }
                 }
                 }
                 }
                 }
                 }
                 }
                 })
              `cast` <Co:19>)
             lineEnv1
             (ww `cast` <Co:4>)
      of
      { Pair ds b ->
      b
      }

-- RHS size: {terms: 22, types: 25, coercions: 0, joins: 0/0}
lineEnv_$slineEnv :: Line V3 Double -> V3 Double -> Interval Double
lineEnv_$slineEnv
  = \ (w :: Line V3 Double) (w1 :: V3 Double) ->
      case w of { Line ww1 ww2 ->
      case w1 of { V3 ww4 ww5 ww6 ->
      case ww4 of { D# ww8 ->
      case ww5 of { D# ww10 ->
      case ww6 of { D# ww12 -> $w$slineEnv ww1 ww8 ww10 ww12 }
      }
      }
      }
      }

-- RHS size: {terms: 150, types: 174, coercions: 67, joins: 1/8}
lineEnv
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Line v n -> v n -> Interval n
lineEnv
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n)
      (eta :: Line v n)
      (eta1 :: v n) ->
      case eta of { Line t ds ->
      case eta1 of w { __DEFAULT ->
      let {
        $dFloating :: Floating n
        $dFloating = $p1(%,%) $d(%,%) } in
      let {
        $dFractional :: Fractional n
        $dFractional = $p1Floating $dFloating } in
      let {
        $dNum :: Num n
        $dNum = $p1Fractional $dFractional } in
      let {
        lvl77 :: n
        lvl77 = fromInteger $dNum lvl4 } in
      let {
        $dOrd :: Ord n
        $dOrd = $p2(%,%) $d(%,%) } in
      let {
        $dAdditive :: Additive v
        $dAdditive = $p1Metric $dMetric } in
      case $fFoldableFingerTree_$cfoldl'
             ((\ (ds1 :: Pair (Point v n) (Interval n)) (seg :: Segment v n) ->
                 case ds1 of { Pair p e ->
                 case e of { I a1 b ->
                 case ^+^
                        $dAdditive
                        $dNum
                        (p `cast` <Co:33>)
                        (case seg of {
                           Linear v1 -> v1;
                           Cubic ds2 ds3 v1 -> v1
                         })
                 of nt
                 { __DEFAULT ->
                 join {
                   $j :: n -> n -> Pair (Point v n) (Interval n)
                   $j (a :: n
                         Unf=OtherCon [])
                      (b1
                         :: n
                         Unf=OtherCon [])
                     = let {
                         n1 :: n
                         n1 = dot $dMetric $dNum (p `cast` <Co:3>) w } in
                       case + $dNum a n1 of dt7 { __DEFAULT ->
                       case + $dNum b1 n1 of dt8 { __DEFAULT ->
                       case min $dOrd a1 dt7 of dt9 { __DEFAULT ->
                       case max $dOrd b dt8 of dt10 { __DEFAULT ->
                       Pair (nt `cast` <Co:4>) (I dt9 dt10)
                       }
                       }
                       }
                       } } in
                 case seg of {
                   Linear l ->
                     case dot $dMetric $dNum l w of x { __DEFAULT ->
                     case < $dOrd x lvl77 of {
                       False -> case lvl77 of dt7 { __DEFAULT -> jump $j dt7 x };
                       True -> case lvl77 of dt7 { __DEFAULT -> jump $j x dt7 }
                     }
                     };
                   Cubic c1 c2 c3 ->
                     case $wcubicEnvelope $dMetric $dFloating $dOrd c1 c2 c3 w of
                     { (# ww1, ww2 #) ->
                     jump $j ww1 ww2
                     }
                 }
                 }
                 }
                 })
              `cast` <Co:19>)
             (case zero $dAdditive $dNum of nt { __DEFAULT ->
              case lvl77 of dt7 { __DEFAULT ->
              Pair (nt `cast` <Co:4>) (I dt7 dt7)
              }
              })
             (t `cast` <Co:4>)
      of
      { Pair ds1 b ->
      b
      }
      }
      }

-- RHS size: {terms: 280, types: 255, coercions: 70, joins: 2/11}
loopEnv
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Loop v n -> Direction v n -> Interval n
loopEnv
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n)
      (eta :: Loop v n)
      (eta1 :: Direction v n) ->
      let {
        $dFloating :: Floating n
        $dFloating = $p1(%,%) $d(%,%) } in
      let {
        $dFractional :: Fractional n
        $dFractional = $p1Floating $dFloating } in
      let {
        $dNum :: Num n
        $dNum = $p1Fractional $dFractional } in
      let {
        lvl77 :: n
        lvl77 = fromInteger $dNum lvl4 } in
      let {
        lvl78 :: Ord n
        lvl78 = $p2(%,%) $d(%,%) } in
      case eta of { Loop t c ->
      case t of { Line ds o ->
      case eta1 `cast` <Co:3> of w { __DEFAULT ->
      let {
        $dAdditive :: Additive v
        $dAdditive = $p1Metric $dMetric } in
      case $fFoldableFingerTree_$cfoldl'
             ((\ (ds1 :: Pair (Point v n) (Interval n)) (seg :: Segment v n) ->
                 case ds1 of { Pair p e ->
                 case e of { I a1 b ->
                 case ^+^
                        $dAdditive
                        $dNum
                        (p `cast` <Co:33>)
                        (case seg of {
                           Linear v1 -> v1;
                           Cubic ds2 ds3 v1 -> v1
                         })
                 of nt
                 { __DEFAULT ->
                 join {
                   $j :: n -> n -> Pair (Point v n) (Interval n)
                   $j (a :: n
                         Unf=OtherCon [])
                      (b1
                         :: n
                         Unf=OtherCon [])
                     = let {
                         n1 :: n
                         n1 = dot $dMetric $dNum (p `cast` <Co:3>) w } in
                       case + $dNum a n1 of dt7 { __DEFAULT ->
                       case + $dNum b1 n1 of dt8 { __DEFAULT ->
                       case min lvl78 a1 dt7 of dt9 { __DEFAULT ->
                       case max lvl78 b dt8 of dt10 { __DEFAULT ->
                       Pair (nt `cast` <Co:4>) (I dt9 dt10)
                       }
                       }
                       }
                       } } in
                 case seg of {
                   Linear l ->
                     case dot $dMetric $dNum l w of x { __DEFAULT ->
                     case < lvl78 x lvl77 of {
                       False -> case lvl77 of dt7 { __DEFAULT -> jump $j dt7 x };
                       True -> case lvl77 of dt7 { __DEFAULT -> jump $j x dt7 }
                     }
                     };
                   Cubic c1 c2 c3 ->
                     case $wcubicEnvelope $dMetric $dFloating lvl78 c1 c2 c3 w of
                     { (# ww1, ww2 #) ->
                     jump $j ww1 ww2
                     }
                 }
                 }
                 }
                 })
              `cast` <Co:19>)
             (case zero $dAdditive $dNum of nt { __DEFAULT ->
              case lvl77 of dt7 { __DEFAULT ->
              Pair (nt `cast` <Co:4>) (I dt7 dt7)
              }
              })
             (ds `cast` <Co:4>)
      of
      { Pair ds1 b ->
      case b of { I a1 b1 ->
      case c of {
        LinearClosing ->
          case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
          { __DEFAULT ->
          join {
            $j :: n -> n -> Interval n
            $j (a :: n
                  Unf=OtherCon [])
               (b2
                  :: n
                  Unf=OtherCon [])
              = let {
                  n1 :: n
                  n1 = dot $dMetric $dNum o w } in
                case + $dNum a n1 of dt8 { __DEFAULT ->
                case + $dNum b2 n1 of dt9 { __DEFAULT ->
                case min lvl78 a1 dt8 of dt10 { __DEFAULT ->
                case max lvl78 b1 dt9 of dt11 { __DEFAULT -> I dt10 dt11 }
                }
                }
                } } in
          case dot $dMetric $dNum dt7 w of x { __DEFAULT ->
          case < lvl78 x lvl77 of {
            False -> case lvl77 of dt8 { __DEFAULT -> jump $j dt8 x };
            True -> case lvl77 of dt8 { __DEFAULT -> jump $j x dt8 }
          }
          }
          };
        CubicClosing c1 c2 ->
          case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
          { __DEFAULT ->
          case $wcubicEnvelope $dMetric $dFloating lvl78 c1 c2 dt7 w of
          { (# ww1, ww2 #) ->
          let {
            n1 :: n
            n1 = dot $dMetric $dNum o w } in
          case + $dNum ww1 n1 of dt8 { __DEFAULT ->
          case + $dNum ww2 n1 of dt9 { __DEFAULT ->
          case min lvl78 a1 dt8 of dt10 { __DEFAULT ->
          case max lvl78 b1 dt9 of dt11 { __DEFAULT -> I dt10 dt11 }
          }
          }
          }
          }
          }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 10, types: 17, coercions: 0, joins: 0/0}
$cgetEnvelope
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Loop v n -> Envelope v n
$cgetEnvelope
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n)
      (x :: Loop v n) ->
      Envelope (loopEnv $dMetric $d(%,%) x)

-- RHS size: {terms: 1, types: 0, coercions: 28, joins: 0/0}
$fEnvelopedLoop_$cgetEnvelope
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Loop v n -> Envelope (V (Loop v n)) (N (Loop v n))
$fEnvelopedLoop_$cgetEnvelope = $cgetEnvelope `cast` <Co:28>

-- RHS size: {terms: 70, types: 301, coercions: 121, joins: 0/9}
$fEnvelopedLoop_$cboundingBox
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n, HasBasis (V (Loop v n))) =>
     Loop v n -> BoundingBox (V (Loop v n)) (N (Loop v n))
$fEnvelopedLoop_$cboundingBox
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n)
      (eta :: HasBasis (V (Loop v n)))
      (eta1 :: Loop v n) ->
      case HEq_sc (($p3(%,,%) eta) `cast` <Co:12>) of cobox
      { __DEFAULT ->
      let {
        $dAdditive :: Additive (V (Loop v n))
        $dAdditive = $p1Metric ($dMetric `cast` <Co:5>) } in
      let {
        $dFunctor :: Functor (V (Loop v n))
        $dFunctor = $p1Additive $dAdditive } in
      let {
        bounds :: V (Loop v n) (Interval (N (Loop v n)))
        bounds
          = fmap
              $dFunctor
              ((\ (v1 :: V (Loop v n) (N (Loop v n))) ->
                  loopEnv $dMetric $d(%,%) eta1 (v1 `cast` <Co:10>))
               `cast` <Co:15>)
              (let {
                 $dFloating :: Floating (N (Loop v n))
                 $dFloating = $p1(%,%) ($d(%,%) `cast` <Co:11>) } in
               let {
                 $dFractional :: Fractional (N (Loop v n))
                 $dFractional = $p1Floating $dFloating } in
               let {
                 $dNum :: Num (N (Loop v n))
                 $dNum = $p1Fractional $dFractional } in
               let {
                 b1 :: N (Loop v n)
                 b1 = fromInteger $dNum lineVertices3 } in
               let {
                 lvl77 :: N (Loop v n) -> N (Loop v n)
                 lvl77 = \ _ -> b1 } in
               let {
                 lvl78 :: V (Loop v n) (N (Loop v n))
                 lvl78 = zero ($p1(%,,%) eta) $dNum } in
               tabulate
                 ($p2(%,,%) eta)
                 ((\ (ds :: Rep (V (Loop v n))) ->
                     (ds `cast` <Co:8>) $fFunctorIdentity (lvl77 `cast` <Co:11>) lvl78)
                  `cast` <Co:15>)) } in
      case (fmap $dFunctor inf bounds) `cast` <Co:7> of nt { __DEFAULT ->
      case (fmap $dFunctor sup bounds) `cast` <Co:7> of nt1
      { __DEFAULT ->
      BoundingBox (nt `cast` <Co:10>) (nt1 `cast` <Co:10>)
      }
      }
      }

-- RHS size: {terms: 13, types: 17, coercions: 16, joins: 0/0}
$fEnvelopedLoop
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Enveloped (Loop v n)
$fEnvelopedLoop
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n) ->
      C:Enveloped
        ($dMetric `cast` <Co:5>)
        ($d(%,%) `cast` <Co:11>)
        ($fEnvelopedLoop_$cgetEnvelope $dMetric $d(%,%))
        ($fEnvelopedLoop_$cboundingBox $dMetric $d(%,%))

-- RHS size: {terms: 412, types: 402, coercions: 134, joins: 3/14}
trailEnv
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Trail v n -> v n -> Interval n
trailEnv
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n)
      (eta :: Trail v n)
      (eta1 :: v n) ->
      let {
        $dFloating :: Floating n
        $dFloating = $p1(%,%) $d(%,%) } in
      let {
        $dFractional :: Fractional n
        $dFractional = $p1Floating $dFloating } in
      let {
        $dNum :: Num n
        $dNum = $p1Fractional $dFractional } in
      let {
        lvl77 :: n
        lvl77 = fromInteger $dNum lvl4 } in
      let {
        lvl78 :: Ord n
        lvl78 = $p2(%,%) $d(%,%) } in
      case eta of {
        OpenTrail l ->
          case l of { Line t ds ->
          case eta1 of w { __DEFAULT ->
          let {
            $dAdditive :: Additive v
            $dAdditive = $p1Metric $dMetric } in
          case $fFoldableFingerTree_$cfoldl'
                 ((\ (ds1 :: Pair (Point v n) (Interval n)) (seg :: Segment v n) ->
                     case ds1 of { Pair p e ->
                     case e of { I a1 b ->
                     case ^+^
                            $dAdditive
                            $dNum
                            (p `cast` <Co:33>)
                            (case seg of {
                               Linear v1 -> v1;
                               Cubic ds2 ds3 v1 -> v1
                             })
                     of nt
                     { __DEFAULT ->
                     join {
                       $j :: n -> n -> Pair (Point v n) (Interval n)
                       $j (a :: n
                             Unf=OtherCon [])
                          (b1
                             :: n
                             Unf=OtherCon [])
                         = let {
                             n1 :: n
                             n1 = dot $dMetric $dNum (p `cast` <Co:3>) w } in
                           case + $dNum a n1 of dt7 { __DEFAULT ->
                           case + $dNum b1 n1 of dt8 { __DEFAULT ->
                           case min lvl78 a1 dt7 of dt9 { __DEFAULT ->
                           case max lvl78 b dt8 of dt10 { __DEFAULT ->
                           Pair (nt `cast` <Co:4>) (I dt9 dt10)
                           }
                           }
                           }
                           } } in
                     case seg of {
                       Linear l1 ->
                         case dot $dMetric $dNum l1 w of x { __DEFAULT ->
                         case < lvl78 x lvl77 of {
                           False -> case lvl77 of dt7 { __DEFAULT -> jump $j dt7 x };
                           True -> case lvl77 of dt7 { __DEFAULT -> jump $j x dt7 }
                         }
                         };
                       Cubic c1 c2 c3 ->
                         case $wcubicEnvelope $dMetric $dFloating lvl78 c1 c2 c3 w of
                         { (# ww1, ww2 #) ->
                         jump $j ww1 ww2
                         }
                     }
                     }
                     }
                     })
                  `cast` <Co:19>)
                 (case zero $dAdditive $dNum of nt { __DEFAULT ->
                  case lvl77 of dt7 { __DEFAULT ->
                  Pair (nt `cast` <Co:4>) (I dt7 dt7)
                  }
                  })
                 (t `cast` <Co:4>)
          of
          { Pair ds1 b ->
          b
          }
          }
          };
        ClosedTrail l ->
          case l of { Loop t c ->
          case t of { Line ds o ->
          case eta1 of w { __DEFAULT ->
          let {
            $dAdditive :: Additive v
            $dAdditive = $p1Metric $dMetric } in
          case $fFoldableFingerTree_$cfoldl'
                 ((\ (ds1 :: Pair (Point v n) (Interval n)) (seg :: Segment v n) ->
                     case ds1 of { Pair p e ->
                     case e of { I a1 b ->
                     case ^+^
                            $dAdditive
                            $dNum
                            (p `cast` <Co:33>)
                            (case seg of {
                               Linear v1 -> v1;
                               Cubic ds2 ds3 v1 -> v1
                             })
                     of nt
                     { __DEFAULT ->
                     join {
                       $j :: n -> n -> Pair (Point v n) (Interval n)
                       $j (a :: n
                             Unf=OtherCon [])
                          (b1
                             :: n
                             Unf=OtherCon [])
                         = let {
                             n1 :: n
                             n1 = dot $dMetric $dNum (p `cast` <Co:3>) w } in
                           case + $dNum a n1 of dt7 { __DEFAULT ->
                           case + $dNum b1 n1 of dt8 { __DEFAULT ->
                           case min lvl78 a1 dt7 of dt9 { __DEFAULT ->
                           case max lvl78 b dt8 of dt10 { __DEFAULT ->
                           Pair (nt `cast` <Co:4>) (I dt9 dt10)
                           }
                           }
                           }
                           } } in
                     case seg of {
                       Linear l1 ->
                         case dot $dMetric $dNum l1 w of x { __DEFAULT ->
                         case < lvl78 x lvl77 of {
                           False -> case lvl77 of dt7 { __DEFAULT -> jump $j dt7 x };
                           True -> case lvl77 of dt7 { __DEFAULT -> jump $j x dt7 }
                         }
                         };
                       Cubic c1 c2 c3 ->
                         case $wcubicEnvelope $dMetric $dFloating lvl78 c1 c2 c3 w of
                         { (# ww1, ww2 #) ->
                         jump $j ww1 ww2
                         }
                     }
                     }
                     }
                     })
                  `cast` <Co:19>)
                 (case zero $dAdditive $dNum of nt { __DEFAULT ->
                  case lvl77 of dt7 { __DEFAULT ->
                  Pair (nt `cast` <Co:4>) (I dt7 dt7)
                  }
                  })
                 (ds `cast` <Co:4>)
          of
          { Pair ds1 b ->
          case b of { I a1 b1 ->
          case c of {
            LinearClosing ->
              case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
              { __DEFAULT ->
              join {
                $j :: n -> n -> Interval n
                $j (a :: n
                      Unf=OtherCon [])
                   (b2
                      :: n
                      Unf=OtherCon [])
                  = let {
                      n1 :: n
                      n1 = dot $dMetric $dNum o w } in
                    case + $dNum a n1 of dt8 { __DEFAULT ->
                    case + $dNum b2 n1 of dt9 { __DEFAULT ->
                    case min lvl78 a1 dt8 of dt10 { __DEFAULT ->
                    case max lvl78 b1 dt9 of dt11 { __DEFAULT -> I dt10 dt11 }
                    }
                    }
                    } } in
              case dot $dMetric $dNum dt7 w of x { __DEFAULT ->
              case < lvl78 x lvl77 of {
                False -> case lvl77 of dt8 { __DEFAULT -> jump $j dt8 x };
                True -> case lvl77 of dt8 { __DEFAULT -> jump $j x dt8 }
              }
              }
              };
            CubicClosing c1 c2 ->
              case fmap ($p1Additive $dAdditive) (negate $dNum) o of dt7
              { __DEFAULT ->
              case $wcubicEnvelope $dMetric $dFloating lvl78 c1 c2 dt7 w of
              { (# ww1, ww2 #) ->
              let {
                n1 :: n
                n1 = dot $dMetric $dNum o w } in
              case + $dNum ww1 n1 of dt8 { __DEFAULT ->
              case + $dNum ww2 n1 of dt9 { __DEFAULT ->
              case min lvl78 a1 dt8 of dt10 { __DEFAULT ->
              case max lvl78 b1 dt9 of dt11 { __DEFAULT -> I dt10 dt11 }
              }
              }
              }
              }
              }
          }
          }
          }
          }
          }
          }
      }

-- RHS size: {terms: 12, types: 20, coercions: 3, joins: 0/0}
$cgetEnvelope1
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Trail v n -> Envelope v n
$cgetEnvelope1
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n)
      (eta :: Trail v n) ->
      Envelope
        (\ (ds :: Direction v n) ->
           trailEnv $dMetric $d(%,%) eta (ds `cast` <Co:3>))

-- RHS size: {terms: 1, types: 0, coercions: 28, joins: 0/0}
$fEnvelopedTrail_$cgetEnvelope
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Trail v n -> Envelope (V (Trail v n)) (N (Trail v n))
$fEnvelopedTrail_$cgetEnvelope = $cgetEnvelope1 `cast` <Co:28>

-- RHS size: {terms: 70, types: 301, coercions: 118, joins: 0/9}
$fEnvelopedTrail_$cboundingBox
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n, HasBasis (V (Trail v n))) =>
     Trail v n -> BoundingBox (V (Trail v n)) (N (Trail v n))
$fEnvelopedTrail_$cboundingBox
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n)
      (eta :: HasBasis (V (Trail v n)))
      (eta1 :: Trail v n) ->
      case HEq_sc (($p3(%,,%) eta) `cast` <Co:12>) of cobox
      { __DEFAULT ->
      let {
        $dAdditive :: Additive (V (Trail v n))
        $dAdditive = $p1Metric ($dMetric `cast` <Co:5>) } in
      let {
        $dFunctor :: Functor (V (Trail v n))
        $dFunctor = $p1Additive $dAdditive } in
      let {
        bounds :: V (Trail v n) (Interval (N (Trail v n)))
        bounds
          = fmap
              $dFunctor
              ((\ (v1 :: V (Trail v n) (N (Trail v n))) ->
                  trailEnv $dMetric $d(%,%) eta1 (v1 `cast` <Co:7>))
               `cast` <Co:15>)
              (let {
                 $dFloating :: Floating (N (Trail v n))
                 $dFloating = $p1(%,%) ($d(%,%) `cast` <Co:11>) } in
               let {
                 $dFractional :: Fractional (N (Trail v n))
                 $dFractional = $p1Floating $dFloating } in
               let {
                 $dNum :: Num (N (Trail v n))
                 $dNum = $p1Fractional $dFractional } in
               let {
                 b1 :: N (Trail v n)
                 b1 = fromInteger $dNum lineVertices3 } in
               let {
                 lvl77 :: N (Trail v n) -> N (Trail v n)
                 lvl77 = \ _ -> b1 } in
               let {
                 lvl78 :: V (Trail v n) (N (Trail v n))
                 lvl78 = zero ($p1(%,,%) eta) $dNum } in
               tabulate
                 ($p2(%,,%) eta)
                 ((\ (ds :: Rep (V (Trail v n))) ->
                     (ds `cast` <Co:8>) $fFunctorIdentity (lvl77 `cast` <Co:11>) lvl78)
                  `cast` <Co:15>)) } in
      case (fmap $dFunctor inf bounds) `cast` <Co:7> of nt { __DEFAULT ->
      case (fmap $dFunctor sup bounds) `cast` <Co:7> of nt1
      { __DEFAULT ->
      BoundingBox (nt `cast` <Co:10>) (nt1 `cast` <Co:10>)
      }
      }
      }

-- RHS size: {terms: 13, types: 17, coercions: 16, joins: 0/0}
$fEnvelopedTrail
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Enveloped (Trail v n)
$fEnvelopedTrail
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n) ->
      C:Enveloped
        ($dMetric `cast` <Co:5>)
        ($d(%,%) `cast` <Co:11>)
        ($fEnvelopedTrail_$cgetEnvelope $dMetric $d(%,%))
        ($fEnvelopedTrail_$cboundingBox $dMetric $d(%,%))

-- RHS size: {terms: 153, types: 187, coercions: 70, joins: 1/9}
$w$cgetEnvelope
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Line v n -> (# Direction v n -> Interval n #)
$w$cgetEnvelope
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Metric v)
      (w1 :: OrderedField n)
      (w2 :: Line v n) ->
      let {
        $dFloating :: Floating n
        $dFloating = $p1(%,%) w1 } in
      let {
        $dFractional :: Fractional n
        $dFractional = $p1Floating $dFloating } in
      let {
        $dNum :: Num n
        $dNum = $p1Fractional $dFractional } in
      let {
        lvl77 :: n
        lvl77 = fromInteger $dNum lvl4 } in
      let {
        $dOrd :: Ord n
        $dOrd = $p2(%,%) w1 } in
      let {
        $dAdditive :: Additive v
        $dAdditive = $p1Metric w } in
      let {
        lvl78 :: Pair (Point v n) (Interval n)
        lvl78
          = case zero $dAdditive $dNum of nt { __DEFAULT ->
            case lvl77 of dt7 { __DEFAULT ->
            Pair (nt `cast` <Co:4>) (I dt7 dt7)
            }
            } } in
      (# \ (ds :: Direction v n) ->
           case w2 of { Line t ds1 ->
           case ds `cast` <Co:3> of w3 { __DEFAULT ->
           case $fFoldableFingerTree_$cfoldl'
                  ((\ (ds2 :: Pair (Point v n) (Interval n)) (seg :: Segment v n) ->
                      case ds2 of { Pair p e ->
                      case e of { I a1 b ->
                      case ^+^
                             $dAdditive
                             $dNum
                             (p `cast` <Co:33>)
                             (case seg of {
                                Linear v1 -> v1;
                                Cubic ds3 ds4 v1 -> v1
                              })
                      of nt
                      { __DEFAULT ->
                      join {
                        $j :: n -> n -> Pair (Point v n) (Interval n)
                        $j (a :: n
                              Unf=OtherCon [])
                           (b1
                              :: n
                              Unf=OtherCon [])
                          = let {
                              n1 :: n
                              n1 = dot w $dNum (p `cast` <Co:3>) w3 } in
                            case + $dNum a n1 of dt7 { __DEFAULT ->
                            case + $dNum b1 n1 of dt8 { __DEFAULT ->
                            case min $dOrd a1 dt7 of dt9 { __DEFAULT ->
                            case max $dOrd b dt8 of dt10 { __DEFAULT ->
                            Pair (nt `cast` <Co:4>) (I dt9 dt10)
                            }
                            }
                            }
                            } } in
                      case seg of {
                        Linear l ->
                          case dot w $dNum l w3 of x { __DEFAULT ->
                          case < $dOrd x lvl77 of {
                            False -> case lvl77 of dt7 { __DEFAULT -> jump $j dt7 x };
                            True -> case lvl77 of dt7 { __DEFAULT -> jump $j x dt7 }
                          }
                          };
                        Cubic c1 c2 c3 ->
                          case $wcubicEnvelope w $dFloating $dOrd c1 c2 c3 w3 of
                          { (# ww1, ww2 #) ->
                          jump $j ww1 ww2
                          }
                      }
                      }
                      }
                      })
                   `cast` <Co:19>)
                  lvl78
                  (t `cast` <Co:4>)
           of
           { Pair ds2 b ->
           b
           }
           }
           } #)

-- RHS size: {terms: 13, types: 29, coercions: 0, joins: 0/0}
$cgetEnvelope2
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Line v n -> Envelope v n
$cgetEnvelope2
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Metric v)
      (w1 :: OrderedField n)
      (w2 :: Line v n) ->
      case $w$cgetEnvelope w w1 w2 of { (# ww1 #) -> Envelope ww1 }

-- RHS size: {terms: 1, types: 0, coercions: 28, joins: 0/0}
$fEnvelopedLine_$cgetEnvelope
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Line v n -> Envelope (V (Line v n)) (N (Line v n))
$fEnvelopedLine_$cgetEnvelope = $cgetEnvelope2 `cast` <Co:28>

-- RHS size: {terms: 211, types: 464, coercions: 185, joins: 1/18}
$fEnvelopedLine_$cboundingBox
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n, HasBasis (V (Line v n))) =>
     Line v n -> BoundingBox (V (Line v n)) (N (Line v n))
$fEnvelopedLine_$cboundingBox
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n)
      (eta :: HasBasis (V (Line v n)))
      (eta1 :: Line v n) ->
      let {
        $dFloating :: Floating n
        $dFloating = $p1(%,%) $d(%,%) } in
      let {
        $dFractional :: Fractional n
        $dFractional = $p1Floating $dFloating } in
      let {
        $dNum :: Num n
        $dNum = $p1Fractional $dFractional } in
      let {
        lvl77 :: n
        lvl77 = fromInteger $dNum lvl4 } in
      let {
        $dOrd :: Ord n
        $dOrd = $p2(%,%) $d(%,%) } in
      case HEq_sc (($p3(%,,%) eta) `cast` <Co:12>) of cobox
      { __DEFAULT ->
      let {
        $dAdditive :: Additive (V (Line v n))
        $dAdditive = $p1Metric ($dMetric `cast` <Co:5>) } in
      let {
        $dFunctor :: Functor (V (Line v n))
        $dFunctor = $p1Additive $dAdditive } in
      let {
        bounds :: V (Line v n) (Interval (N (Line v n)))
        bounds
          = let {
              $dAdditive1 :: Additive v
              $dAdditive1 = $p1Metric $dMetric } in
            let {
              lvl78 :: Pair (Point v n) (Interval n)
              lvl78
                = case zero $dAdditive1 $dNum of nt { __DEFAULT ->
                  case lvl77 of dt7 { __DEFAULT ->
                  Pair (nt `cast` <Co:4>) (I dt7 dt7)
                  }
                  } } in
            fmap
              $dFunctor
              ((\ (v1 :: V (Line v n) (N (Line v n))) ->
                  case eta1 of { Line t ds ->
                  case v1 `cast` <Co:7> of w { __DEFAULT ->
                  case $fFoldableFingerTree_$cfoldl'
                         ((\ (ds1 :: Pair (Point v n) (Interval n)) (seg :: Segment v n) ->
                             case ds1 of { Pair p e ->
                             case e of { I a1 b ->
                             case ^+^
                                    $dAdditive1
                                    $dNum
                                    (p `cast` <Co:33>)
                                    (case seg of {
                                       Linear v2 -> v2;
                                       Cubic ds2 ds3 v2 -> v2
                                     })
                             of nt
                             { __DEFAULT ->
                             join {
                               $j :: n -> n -> Pair (Point v n) (Interval n)
                               $j (a :: n
                                     Unf=OtherCon [])
                                  (b1
                                     :: n
                                     Unf=OtherCon [])
                                 = let {
                                     n1 :: n
                                     n1 = dot $dMetric $dNum (p `cast` <Co:3>) w } in
                                   case + $dNum a n1 of dt7 { __DEFAULT ->
                                   case + $dNum b1 n1 of dt8 { __DEFAULT ->
                                   case min $dOrd a1 dt7 of dt9 { __DEFAULT ->
                                   case max $dOrd b dt8 of dt10 { __DEFAULT ->
                                   Pair (nt `cast` <Co:4>) (I dt9 dt10)
                                   }
                                   }
                                   }
                                   } } in
                             case seg of {
                               Linear l ->
                                 case dot $dMetric $dNum l w of x { __DEFAULT ->
                                 case < $dOrd x lvl77 of {
                                   False -> case lvl77 of dt7 { __DEFAULT -> jump $j dt7 x };
                                   True -> case lvl77 of dt7 { __DEFAULT -> jump $j x dt7 }
                                 }
                                 };
                               Cubic c1 c2 c3 ->
                                 case $wcubicEnvelope $dMetric $dFloating $dOrd c1 c2 c3 w of
                                 { (# ww1, ww2 #) ->
                                 jump $j ww1 ww2
                                 }
                             }
                             }
                             }
                             })
                          `cast` <Co:19>)
                         lvl78
                         (t `cast` <Co:4>)
                  of
                  { Pair ds1 b ->
                  b
                  }
                  }
                  })
               `cast` <Co:15>)
              (let {
                 $dFloating1 :: Floating (N (Line v n))
                 $dFloating1 = $p1(%,%) ($d(%,%) `cast` <Co:11>) } in
               let {
                 $dFractional1 :: Fractional (N (Line v n))
                 $dFractional1 = $p1Floating $dFloating1 } in
               let {
                 $dNum1 :: Num (N (Line v n))
                 $dNum1 = $p1Fractional $dFractional1 } in
               let {
                 b1 :: N (Line v n)
                 b1 = fromInteger $dNum1 lineVertices3 } in
               let {
                 lvl79 :: N (Line v n) -> N (Line v n)
                 lvl79 = \ _ -> b1 } in
               let {
                 lvl80 :: V (Line v n) (N (Line v n))
                 lvl80 = zero ($p1(%,,%) eta) $dNum1 } in
               tabulate
                 ($p2(%,,%) eta)
                 ((\ (ds :: Rep (V (Line v n))) ->
                     (ds `cast` <Co:8>) $fFunctorIdentity (lvl79 `cast` <Co:11>) lvl80)
                  `cast` <Co:15>)) } in
      case (fmap $dFunctor inf bounds) `cast` <Co:7> of nt { __DEFAULT ->
      case (fmap $dFunctor sup bounds) `cast` <Co:7> of nt1
      { __DEFAULT ->
      BoundingBox (nt `cast` <Co:10>) (nt1 `cast` <Co:10>)
      }
      }
      }

-- RHS size: {terms: 13, types: 17, coercions: 16, joins: 0/0}
$fEnvelopedLine
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n) =>
     Enveloped (Line v n)
$fEnvelopedLine
  = \ (@ (v :: * -> *))
      (@ n)
      ($dMetric :: Metric v)
      ($d(%,%) :: OrderedField n) ->
      C:Enveloped
        ($dMetric `cast` <Co:5>)
        ($d(%,%) `cast` <Co:11>)
        ($fEnvelopedLine_$cgetEnvelope $dMetric $d(%,%))
        ($fEnvelopedLine_$cboundingBox $dMetric $d(%,%))

-- RHS size: {terms: 158, types: 166, coercions: 65, joins: 0/0}
$fTransformableLoop_$s$ctransform
  :: Transformation (V (Loop V2 Double)) (N (Loop V2 Double))
     -> Loop V2 Double -> Loop V2 Double
$fTransformableLoop_$s$ctransform
  = \ (w :: Transformation (V (Loop V2 Double)) (N (Loop V2 Double)))
      (w1 :: Loop V2 Double) ->
      case w of { T ww1 ww2 ww3 ->
      case ww1 `cast` <Co:10> of { V2 ww5 ww6 ->
      case ww5 of { V2 ww8 ww9 ->
      case ww8 of { D# ww11 ->
      case ww9 of { D# ww13 ->
      case ww6 of { V2 ww15 ww16 ->
      case ww15 of { D# ww18 ->
      case ww16 of { D# ww20 ->
      case w1 of { Loop ww22 ww23 ->
      case ww22 of { Line ww25 ww26 ->
      case ww26 of { V2 ww28 ww29 ->
      case ww28 of { D# ww31 ->
      case ww29 of { D# ww33 ->
      case $fFunctorSeq_$cfmap
             (($fTransformableLine_$s$fTransformableSegment_$ctransform1
                 ((T ((V2 (V2 (D# ww11) (D# ww13)) (V2 (D# ww18) (D# ww20)))
                      `cast` <Co:13>)
                     $fTransformableLine2
                     $fTransformableLine1)
                  `cast` <Co:17>))
              `cast` <Co:11>)
             (ww25 `cast` <Co:4>)
      of nt
      { __DEFAULT ->
      case ww23 of {
        LinearClosing ->
          Loop
            (Line
               (nt `cast` <Co:5>)
               (V2
                  (D# (+## (*## ww11 ww31) (*## ww13 ww33)))
                  (D# (+## (*## ww18 ww31) (*## ww20 ww33)))))
            LinearClosing;
        CubicClosing c1 c2 ->
          case c1 of { V2 d e ->
          case c2 of { V2 d1 e1 ->
          case d of { D# y ->
          case e of { D# y1 ->
          case d1 of { D# y2 ->
          case e1 of { D# y3 ->
          Loop
            (Line
               (nt `cast` <Co:5>)
               (V2
                  (D# (+## (*## ww11 ww31) (*## ww13 ww33)))
                  (D# (+## (*## ww18 ww31) (*## ww20 ww33)))))
            (CubicClosing
               (V2
                  (D# (+## (*## ww11 y) (*## ww13 y1)))
                  (D# (+## (*## ww18 y) (*## ww20 y1))))
               (V2
                  (D# (+## (*## ww11 y2) (*## ww13 y3)))
                  (D# (+## (*## ww18 y2) (*## ww20 y3)))))
          }
          }
          }
          }
          }
          }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl72 :: Addr#
lvl72 = "ww V (Loop v n) (V (Loop v n) (N (Loop v n)))"#

-- RHS size: {terms: 4, types: 19, coercions: 0, joins: 0/0}
$fTransformableLoop2
  :: forall (v :: * -> *) n.
     V (Loop v n) (V (Loop v n) (N (Loop v n)))
$fTransformableLoop2
  = \ (@ (v :: * -> *)) (@ n) -> absentError lvl72

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl73 :: Addr#
lvl73 = "ww V (Loop v n) (N (Loop v n))"#

-- RHS size: {terms: 4, types: 15, coercions: 0, joins: 0/0}
$fTransformableLoop1
  :: forall (v :: * -> *) n. V (Loop v n) (N (Loop v n))
$fTransformableLoop1
  = \ (@ (v :: * -> *)) (@ n) -> absentError lvl73

-- RHS size: {terms: 79, types: 124, coercions: 72, joins: 0/4}
$w$ctransform1
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n, Foldable v) =>
     V (Loop v n) (V (Loop v n) (N (Loop v n)))
     -> Seq (Segment v n)
     -> v n
     -> ClosingSegment v n
     -> (# Line v n, ClosingSegment v n #)
$w$ctransform1
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Metric v)
      (w1 :: OrderedField n)
      (w2 :: Foldable v)
      (ww
         :: V (Loop v n) (V (Loop v n) (N (Loop v n)))
         Unf=OtherCon [])
      (ww1
         :: Seq (Segment v n)
         Unf=OtherCon [])
      (ww2
         :: v n
         Unf=OtherCon [])
      (ww3
         :: ClosingSegment v n
         Unf=OtherCon []) ->
      let {
        $dAdditive :: Additive v
        $dAdditive = $p1Metric w } in
      let {
        $dNum :: Floating n
        $dNum = $p1(%,%) w1 } in
      let {
        $dNum1 :: Fractional n
        $dNum1 = $p1Floating $dNum } in
      let {
        $dNum2 :: Num n
        $dNum2 = $p1Fractional $dNum1 } in
      case $fFunctorSeq_$cfmap
             (($fTransformableSegment_$ctransform
                 $dAdditive
                 w2
                 $dNum2
                 ((T ww $fTransformableLoop2 $fTransformableLoop1) `cast` <Co:17>))
              `cast` <Co:11>)
             (ww1 `cast` <Co:4>)
      of nt
      { __DEFAULT ->
      case !*
             ($p1Additive $dAdditive)
             w2
             $dAdditive
             $dNum2
             (ww `cast` <Co:10>)
             ww2
      of dt7
      { __DEFAULT ->
      case ww3 of {
        LinearClosing -> (# Line (nt `cast` <Co:5>) dt7, LinearClosing #);
        CubicClosing c1 c2 ->
          case !*
                 ($p1Additive $dAdditive)
                 w2
                 $dAdditive
                 $dNum2
                 (ww `cast` <Co:10>)
                 c1
          of dt8
          { __DEFAULT ->
          case !*
                 ($p1Additive $dAdditive)
                 w2
                 $dAdditive
                 $dNum2
                 (ww `cast` <Co:10>)
                 c2
          of dt9
          { __DEFAULT ->
          (# Line (nt `cast` <Co:5>) dt7, CubicClosing dt8 dt9 #)
          }
          }
      }
      }
      }

-- RHS size: {terms: 29, types: 102, coercions: 0, joins: 0/0}
$fTransformableLoop_$ctransform
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n, Foldable v) =>
     Transformation (V (Loop v n)) (N (Loop v n))
     -> Loop v n -> Loop v n
$fTransformableLoop_$ctransform
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Metric v)
      (w1 :: OrderedField n)
      (w2 :: Foldable v)
      (w3 :: Transformation (V (Loop v n)) (N (Loop v n)))
      (w4 :: Loop v n) ->
      case w3 of { T ww1 ww2 ww3 ->
      case w4 of { Loop ww5 ww6 ->
      case ww5 of { Line ww8 ww9 ->
      case $w$ctransform1 w w1 w2 ww1 ww8 ww9 ww6 of
      { (# ww11, ww12 #) ->
      Loop ww11 ww12
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 22, joins: 0/0}
$fTransformableLoop
  :: forall (v :: * -> *) n.
     (Metric v, OrderedField n, Foldable v) =>
     Transformable (Loop v n)
$fTransformableLoop
  = $fTransformableLoop_$ctransform `cast` <Co:22>

-- RHS size: {terms: 194, types: 157, coercions: 105, joins: 0/0}
$w$s$ctransform
  :: Double#
     -> Double#
     -> Double#
     -> Double#
     -> Trail V2 Double
     -> Trail V2 Double
$w$s$ctransform
  = \ (ww :: Double#)
      (ww1 :: Double#)
      (ww2 :: Double#)
      (ww3 :: Double#)
      (w :: Trail V2 Double) ->
      case w of {
        OpenTrail l ->
          case l of { Line ww5 ww6 ->
          case ww6 of { V2 ww8 ww9 ->
          case ww8 of { D# ww11 ->
          case ww9 of { D# ww13 ->
          case $fFunctorSeq_$cfmap
                 (($fTransformableLine_$s$fTransformableSegment_$ctransform1
                     ((T ((V2 (V2 (D# ww) (D# ww1)) (V2 (D# ww2) (D# ww3)))
                          `cast` <Co:13>)
                         $fTransformableLine2
                         $fTransformableLine1)
                      `cast` <Co:17>))
                  `cast` <Co:11>)
                 (ww5 `cast` <Co:4>)
          of nt
          { __DEFAULT ->
          OpenTrail
            (Line
               (nt `cast` <Co:5>)
               (V2
                  (D# (+## (*## ww ww11) (*## ww1 ww13)))
                  (D# (+## (*## ww2 ww11) (*## ww3 ww13)))))
          }
          }
          }
          }
          };
        ClosedTrail l ->
          case l of { Loop ww5 ww6 ->
          case ww5 of { Line ww8 ww9 ->
          case ww9 of { V2 ww11 ww12 ->
          case ww11 of { D# ww14 ->
          case ww12 of { D# ww16 ->
          case $fFunctorSeq_$cfmap
                 (($fTransformableLine_$s$fTransformableSegment_$ctransform1
                     ((T ((V2 (V2 (D# ww) (D# ww1)) (V2 (D# ww2) (D# ww3)))
                          `cast` <Co:13>)
                         $fTransformableLine2
                         $fTransformableLine1)
                      `cast` <Co:17>))
                  `cast` <Co:11>)
                 (ww8 `cast` <Co:4>)
          of nt
          { __DEFAULT ->
          case ww6 of {
            LinearClosing ->
              ClosedTrail
                (Loop
                   (Line
                      (nt `cast` <Co:5>)
                      (V2
                         (D# (+## (*## ww ww14) (*## ww1 ww16)))
                         (D# (+## (*## ww2 ww14) (*## ww3 ww16)))))
                   LinearClosing);
            CubicClosing c1 c2 ->
              case c1 of { V2 d e ->
              case c2 of { V2 d1 e1 ->
              case d of { D# y ->
              case e of { D# y1 ->
              case d1 of { D# y2 ->
              case e1 of { D# y3 ->
              ClosedTrail
                (Loop
                   (Line
                      (nt `cast` <Co:5>)
                      (V2
                         (D# (+## (*## ww ww14) (*## ww1 ww16)))
                         (D# (+## (*## ww2 ww14) (*## ww3 ww16)))))
                   (CubicClosing
                      (V2
                         (D# (+## (*## ww y) (*## ww1 y1)))
                         (D# (+## (*## ww2 y) (*## ww3 y1))))
                      (V2
                         (D# (+## (*## ww y2) (*## ww1 y3)))
                         (D# (+## (*## ww2 y2) (*## ww3 y3))))))
              }
              }
              }
              }
              }
              }
          }
          }
          }
          }
          }
          }
          }
      }

-- RHS size: {terms: 32, types: 76, coercions: 10, joins: 0/0}
$fTransformableTrail_$s$ctransform
  :: Transformation (V (Trail V2 Double)) (N (Trail V2 Double))
     -> Trail V2 Double -> Trail V2 Double
$fTransformableTrail_$s$ctransform
  = \ (w :: Transformation
              (V (Trail V2 Double)) (N (Trail V2 Double)))
      (w1 :: Trail V2 Double) ->
      case w of { T ww1 ww2 ww3 ->
      case ww1 `cast` <Co:10> of { V2 ww5 ww6 ->
      case ww5 of { V2 ww8 ww9 ->
      case ww8 of { D# ww11 ->
      case ww9 of { D# ww13 ->
      case ww6 of { V2 ww15 ww16 ->
      case ww15 of { D# ww18 ->
      case ww16 of { D# ww20 -> $w$s$ctransform ww11 ww13 ww18 ww20 w1 }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl74 :: Addr#
lvl74 = "ww V (Trail v n) (V (Trail v n) (N (Trail v n)))"#

-- RHS size: {terms: 4, types: 19, coercions: 0, joins: 0/0}
$fTransformableTrail2
  :: forall (v :: * -> *) n.
     V (Trail v n) (V (Trail v n) (N (Trail v n)))
$fTransformableTrail2
  = \ (@ (v :: * -> *)) (@ n) -> absentError lvl74

-- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
lvl75 :: Addr#
lvl75 = "ww V (Trail v n) (N (Trail v n))"#

-- RHS size: {terms: 4, types: 15, coercions: 0, joins: 0/0}
$fTransformableTrail1
  :: forall (v :: * -> *) n. V (Trail v n) (N (Trail v n))
$fTransformableTrail1
  = \ (@ (v :: * -> *)) (@ n) -> absentError lvl75

-- RHS size: {terms: 72, types: 136, coercions: 73, joins: 0/4}
$w$ctransform2
  :: forall (v :: * -> *) n.
     (Metric v, Foldable v, OrderedField n) =>
     V (Trail v n) (V (Trail v n) (N (Trail v n)))
     -> Trail v n -> Trail v n
$w$ctransform2
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Metric v)
      (w1 :: Foldable v)
      (w2 :: OrderedField n)
      (ww
         :: V (Trail v n) (V (Trail v n) (N (Trail v n)))
         Unf=OtherCon [])
      (w3 :: Trail v n) ->
      case w3 of {
        OpenTrail l ->
          case l of { Line ss o ->
          let {
            $dAdditive :: Additive v
            $dAdditive = $p1Metric w } in
          let {
            $dNum :: Floating n
            $dNum = $p1(%,%) w2 } in
          let {
            $dNum1 :: Fractional n
            $dNum1 = $p1Floating $dNum } in
          let {
            $dNum2 :: Num n
            $dNum2 = $p1Fractional $dNum1 } in
          case $fFunctorSeq_$cfmap
                 (($fTransformableSegment_$ctransform
                     $dAdditive
                     w1
                     $dNum2
                     ((T ww $fTransformableTrail2 $fTransformableTrail1)
                      `cast` <Co:17>))
                  `cast` <Co:11>)
                 (ss `cast` <Co:4>)
          of nt
          { __DEFAULT ->
          case !*
                 ($p1Additive $dAdditive) w1 $dAdditive $dNum2 (ww `cast` <Co:10>) o
          of dt7
          { __DEFAULT ->
          OpenTrail (Line (nt `cast` <Co:5>) dt7)
          }
          }
          };
        ClosedTrail l ->
          case l of { Loop ww2 ww3 ->
          case ww2 of { Line ww5 ww6 ->
          case $w$ctransform1 w w2 w1 (ww `cast` <Co:26>) ww5 ww6 ww3 of
          { (# ww8, ww9 #) ->
          ClosedTrail (Loop ww8 ww9)
          }
          }
          }
      }

-- RHS size: {terms: 16, types: 67, coercions: 0, joins: 0/0}
$fTransformableTrail_$ctransform
  :: forall (v :: * -> *) n.
     (Metric v, Foldable v, OrderedField n) =>
     Transformation (V (Trail v n)) (N (Trail v n))
     -> Trail v n -> Trail v n
$fTransformableTrail_$ctransform
  = \ (@ (v :: * -> *))
      (@ n)
      (w :: Metric v)
      (w1 :: Foldable v)
      (w2 :: OrderedField n)
      (w3 :: Transformation (V (Trail v n)) (N (Trail v n)))
      (w4 :: Trail v n) ->
      case w3 of { T ww1 ww2 ww3 -> $w$ctransform2 w w1 w2 ww1 w4 }

-- RHS size: {terms: 1, types: 0, coercions: 22, joins: 0/0}
$fTransformableTrail
  :: forall (v :: * -> *) n.
     (Metric v, Foldable v, OrderedField n) =>
     Transformable (Trail v n)
$fTransformableTrail
  = $fTransformableTrail_$ctransform `cast` <Co:22>

-- RHS size: {terms: 4, types: 0, coercions: 0, joins: 0/0}
lvl76 :: LCD
lvl76 = LCD 0# 0.0## 0.0##

-- RHS size: {terms: 212, types: 112, coercions: 13, joins: 1/4}
$wloopCrossingsDouble
  :: Seq (Segment V2 Double)
     -> Double#
     -> Double#
     -> ClosingSegment V2 Double
     -> Double#
     -> Double#
     -> Int#
$wloopCrossingsDouble
  = \ (ww
         :: Seq (Segment V2 Double)
         Unf=OtherCon [])
      (ww1 :: Double#)
      (ww2 :: Double#)
      (ww3
         :: ClosingSegment V2 Double
         Unf=OtherCon [])
      (ww4 :: Double#)
      (ww5 :: Double#) ->
      case $fFoldableFingerTree_$cfoldl'
             ((\ (ds :: LCD) (s :: Segment V2 Double) ->
                 case ds of { LCD dt7 dt8 dt9 ->
                 case s of {
                   Linear v ->
                     case v of { V2 dx dy ->
                     case dx of { D# y ->
                     case dy of { D# y1 ->
                     case $w$slinearCrossings ww4 ww5 dt8 dt9 y y1 of ww21
                     { __DEFAULT ->
                     LCD (+# dt7 ww21) (+## dt8 y) (+## dt9 y1)
                     }
                     }
                     }
                     };
                   Cubic c1 c2 c3 ->
                     case c3 of { V2 dx dy ->
                     case dx of { D# y ->
                     case dy of { D# y1 ->
                     case c1 of { V2 ww15 ww16 ->
                     case ww15 of { D# ww18 ->
                     case ww16 of { D# ww20 ->
                     case c2 of { V2 ww22 ww23 ->
                     case ww22 of { D# ww25 ->
                     case ww23 of { D# ww27 ->
                     case $w$scubicCrossings ww4 ww5 dt8 dt9 ww18 ww20 ww25 ww27 y y1
                     of ww35
                     { __DEFAULT ->
                     LCD (+# dt7 ww35) (+## dt8 y) (+## dt9 y1)
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                     }
                 }
                 })
              `cast` <Co:9>)
             lvl76
             (ww `cast` <Co:4>)
      of
      { LCD dt7 dt8 dt9 ->
      case ww3 of {
        LinearClosing ->
          let {
            ww6 :: Double#
            ww6 = negateDouble# ww2 } in
          let {
            by :: Double#
            by = +## dt9 ww6 } in
          let {
            isLeft :: Bool
            isLeft
              = tagToEnum#
                  (>##
                     (-##
                        (*## (negateDouble# ww1) (+## ww5 (negateDouble# dt9)))
                        (*## ww6 (+## ww4 (negateDouble# dt8))))
                     0.0##) } in
          join {
            $j :: Int#
            $j
              = case tagToEnum# (<=## by ww5) of {
                  False -> dt7;
                  True ->
                    case tagToEnum# (>## dt9 ww5) of {
                      False -> dt7;
                      True ->
                        case isLeft of {
                          False -> +# dt7 -1#;
                          True -> dt7
                        }
                    }
                } } in
          case tagToEnum# (<=## dt9 ww5) of {
            False -> jump $j;
            True ->
              case tagToEnum# (>## by ww5) of {
                False -> jump $j;
                True ->
                  case isLeft of {
                    False -> jump $j;
                    True -> +# dt7 1#
                  }
              }
          };
        CubicClosing c1 c2 ->
          case c1 of { V2 ww15 ww16 ->
          case ww15 of { D# ww18 ->
          case ww16 of { D# ww20 ->
          case c2 of { V2 ww22 ww23 ->
          case ww22 of { D# ww25 ->
          case ww23 of { D# ww27 ->
          case $w$scubicCrossings
                 ww4
                 ww5
                 dt8
                 dt9
                 ww18
                 ww20
                 ww25
                 ww27
                 (negateDouble# ww1)
                 (negateDouble# ww2)
          of ww35
          { __DEFAULT ->
          +# dt7 ww35
          }
          }
          }
          }
          }
          }
          }
      }
      }

-- RHS size: {terms: 37, types: 41, coercions: 5, joins: 0/0}
loopCrossingsDouble
  :: Loop V2 Double -> Point V2 Double -> Crossings
loopCrossingsDouble
  = \ (w :: Loop V2 Double) (w1 :: Point V2 Double) ->
      case w of { Loop ww1 ww2 ->
      case ww1 of { Line ww4 ww5 ->
      case ww5 of { V2 ww7 ww8 ->
      case ww7 of { D# ww10 ->
      case ww8 of { D# ww12 ->
      case w1 `cast` <Co:3> of { V2 ww14 ww15 ->
      case ww14 of { D# ww17 ->
      case ww15 of { D# ww19 ->
      case $wloopCrossingsDouble ww4 ww10 ww12 ww2 ww17 ww19 of ww20
      { __DEFAULT ->
      (I# ww20) `cast` <Co:2>
      }
      }
      }
      }
      }
      }
      }
      }
      }

-- RHS size: {terms: 182, types: 171, coercions: 193, joins: 1/5}
$wloopCrossings
  :: forall n.
     OrderedField n =>
     Seq (Segment V2 n)
     -> n -> n -> ClosingSegment V2 n -> n -> n -> Int#
$wloopCrossings
  = \ (@ n)
      (w :: OrderedField n)
      (ww
         :: Seq (Segment V2 n)
         Unf=OtherCon [])
      (ww1
         :: n
         Unf=OtherCon [])
      (ww2
         :: n
         Unf=OtherCon [])
      (ww3
         :: ClosingSegment V2 n
         Unf=OtherCon [])
      (ww4
         :: n
         Unf=OtherCon [])
      (ww5
         :: n
         Unf=OtherCon []) ->
      let {
        $dFloating :: Floating n
        $dFloating = $p1(%,%) w } in
      let {
        $dFractional :: Fractional n
        $dFractional = $p1Floating $dFloating } in
      let {
        $dNum :: Num n
        $dNum = $p1Fractional $dFractional } in
      let {
        eta :: V2 n
        eta = V2 ww4 ww5 } in
      case $fFoldableFingerTree_$cfoldl'
             ((\ (ds :: Pair (Point V2 n) Crossings) (s :: Segment V2 n) ->
                 case ds of { Pair a c ->
                 case a `cast` <Co:33> of wild1 { V2 a1 b1 ->
                 case c `cast` <Co:1> of { I# x ->
                 case + $dNum a1 of dt7 { __DEFAULT ->
                 case + $dNum b1 of dt8 { __DEFAULT ->
                 join {
                   $j :: n -> n -> Pair (Point V2 n) Crossings
                   $j (d :: n
                         Unf=OtherCon [])
                      (e :: n
                         Unf=OtherCon [])
                     = case dt7 d of dt9 { __DEFAULT ->
                       case dt8 e of dt10 { __DEFAULT ->
                       case s of {
                         Linear v ->
                           case v of { V2 ww7 ww8 ->
                           case $wlinearCrossings w ww4 ww5 a1 b1 ww7 ww8 of ww9
                           { __DEFAULT ->
                           Pair ((V2 dt9 dt10) `cast` <Co:37>) ((I# (+# x ww9)) `cast` <Co:2>)
                           }
                           };
                         Cubic c1 c2 c3 ->
                           case (cubicCrossings
                                   w (eta `cast` <Co:4>) (wild1 `cast` <Co:36>) c1 c2 c3)
                                `cast` <Co:1>
                           of
                           { I# y ->
                           Pair ((V2 dt9 dt10) `cast` <Co:37>) ((I# (+# x y)) `cast` <Co:2>)
                           }
                       }
                       }
                       } } in
                 case s of {
                   Linear v1 -> case v1 of { V2 d e -> jump $j d e };
                   Cubic ds1 ds2 v1 -> case v1 of { V2 d e -> jump $j d e }
                 }
                 }
                 }
                 }
                 }
                 })
              `cast` <Co:17>)
             (case fromInteger $dNum lvl4 of dt7 { __DEFAULT ->
              Pair ((V2 dt7 dt7) `cast` <Co:4>) ($fShow1Line1 `cast` <Co:2>)
              })
             (ww `cast` <Co:4>)
      of
      { Pair a c ->
      case c `cast` <Co:1> of { I# x ->
      case a `cast` <Co:3> of ww6 { V2 ww7 ww8 ->
      case ww3 of {
        LinearClosing ->
          case negate $dNum ww1 of dt7 { __DEFAULT ->
          case negate $dNum ww2 of dt8 { __DEFAULT ->
          case $wlinearCrossings w ww4 ww5 ww7 ww8 dt7 dt8 of ww9
          { __DEFAULT ->
          +# x ww9
          }
          }
          };
        CubicClosing c1 c2 ->
          case negate $dNum ww1 of dt7 { __DEFAULT ->
          case negate $dNum ww2 of dt8 { __DEFAULT ->
          case (cubicCrossings
                  w (eta `cast` <Co:4>) (ww6 `cast` <Co:4>) c1 c2 (V2 dt7 dt8))
               `cast` <Co:1>
          of
          { I# y ->
          +# x y
          }
          }
          }
      }
      }
      }
      }

-- RHS size: {terms: 28, types: 38, coercions: 5, joins: 0/0}
loopCrossings
  :: forall n. OrderedField n => Loop V2 n -> Point V2 n -> Crossings
loopCrossings
  = \ (@ n)
      (w :: OrderedField n)
      (w1 :: Loop V2 n)
      (w2 :: Point V2 n) ->
      case w1 of { Loop ww1 ww2 ->
      case ww1 of { Line ww4 ww5 ->
      case ww5 of { V2 ww7 ww8 ->
      case w2 `cast` <Co:3> of { V2 ww10 ww11 ->
      case $wloopCrossings w ww4 ww7 ww8 ww2 ww10 ww11 of ww12
      { __DEFAULT ->
      (I# ww12) `cast` <Co:2>
      }
      }
      }
      }
      }

-- RHS size: {terms: 1, types: 0, coercions: 20, joins: 0/0}
$fHasQueryLoopCrossings_$cgetQuery
  :: forall n.
     OrderedField n =>
     Loop V2 n -> Query (V (Loop V2 n)) (N (Loop V2 n)) Crossings
$fHasQueryLoopCrossings_$cgetQuery = loopCrossings `cast` <Co:20>

-- RHS size: {terms: 1, types: 0, coercions: 12, joins: 0/0}
$fHasQueryLoopCrossings
  :: forall n. OrderedField n => HasQuery (Loop V2 n) Crossings
$fHasQueryLoopCrossings
  = $fHasQueryLoopCrossings_$cgetQuery `cast` <Co:12>

-- RHS size: {terms: 33, types: 53, coercions: 30, joins: 0/0}
$cgetQuery
  :: forall n.
     OrderedField n =>
     Trail V2 n -> Point (V (Trail V2 n)) (N (Trail V2 n)) -> Crossings
$cgetQuery
  = \ (@ n)
      ($d(%,%) :: OrderedField n)
      (eta :: Trail V2 n)
      (eta1 :: Point (V (Trail V2 n)) (N (Trail V2 n))) ->
      case eta of {
        OpenTrail ds -> $fShow1Line1 `cast` <Co:20>;
        ClosedTrail l ->
          case l of { Loop ww1 ww2 ->
          case ww1 of { Line ww4 ww5 ->
          case ww5 of { V2 ww7 ww8 ->
          case eta1 `cast` <Co:8> of { V2 ww10 ww11 ->
          case $wloopCrossings $d(%,%) ww4 ww7 ww8 ww2 ww10 ww11 of ww12
          { __DEFAULT ->
          (I# ww12) `cast` <Co:2>
          }
          }
          }
          }
          }
      }

-- RHS size: {terms: 1, types: 0, coercions: 21, joins: 0/0}
$fHasQueryTrailCrossings_$cgetQuery
  :: forall n.
     OrderedField n =>
     Trail V2 n -> Query (V (Trail V2 n)) (N (Trail V2 n)) Crossings
$fHasQueryTrailCrossings_$cgetQuery = $cgetQuery `cast` <Co:21>

-- RHS size: {terms: 1, types: 0, coercions: 12, joins: 0/0}
$fHasQueryTrailCrossings
  :: forall n. OrderedField n => HasQuery (Trail V2 n) Crossings
$fHasQueryTrailCrossings
  = $fHasQueryTrailCrossings_$cgetQuery `cast` <Co:12>


------ Local rules for imported ids --------
"SPEC $ctransform"
    forall ($dFoldable :: Foldable V2)
           ($dNum :: Num Double)
           ($dAdditive :: Additive V2).
      $fTransformableLine_$ctransform $dAdditive $dNum $dFoldable
      = $fTransformableLine_$s$ctransform1
"SPEC $ctransform"
    forall ($dFoldable :: Foldable V3)
           ($dNum :: Num Double)
           ($dAdditive :: Additive V3).
      $fTransformableLine_$ctransform $dAdditive $dNum $dFoldable
      = $fTransformableLine_$s$ctransform
"SPEC loopTrace"
    forall ($d(%,%) :: OrderedField Double).
      loopTrace $d(%,%)
      = loopTrace_$sloopTrace
"SPEC lineTrace"
    forall ($d(%,%) :: OrderedField Double).
      lineTrace $d(%,%)
      = lineTrace_$slineTrace
"SPEC trailTrace"
    forall ($d(%,%) :: OrderedField Double).
      trailTrace $d(%,%)
      = trailTrace_$strailTrace
"lineEnv/Double"
    forall ($dMetric :: Metric V2) ($d(%,%) :: OrderedField Double).
      lineEnv $dMetric $d(%,%)
      = lineEnv2Double
"SPEC lineEnv" [0]
    forall ($d(%,%) :: OrderedField Double) ($dMetric :: Metric V3).
      lineEnv $dMetric $d(%,%)
      = lineEnv_$slineEnv
"SPEC $ctransform"
    forall ($dFoldable :: Foldable V2)
           ($d(%,%) :: OrderedField Double)
           ($dMetric :: Metric V2).
      $fTransformableLoop_$ctransform $dMetric $d(%,%) $dFoldable
      = $fTransformableLoop_$s$ctransform
"SPEC $ctransform"
    forall ($d(%,%) :: OrderedField Double)
           ($dFoldable :: Foldable V2)
           ($dMetric :: Metric V2).
      $fTransformableTrail_$ctransform $dMetric $dFoldable $d(%,%)
      = $fTransformableTrail_$s$ctransform
"loopCrossings/Double"
    forall ($d(%,%) :: OrderedField Double).
      loopCrossings $d(%,%)
      = loopCrossingsDouble
"SPEC/Geometry.Trail $fTransformableSegment_$ctransform @ V2 @ Double"
    forall ($dNum :: Num Double)
           ($dFoldable :: Foldable V2)
           ($dAdditive :: Additive V2).
      $fTransformableSegment_$ctransform $dAdditive $dFoldable $dNum
      = $fTransformableLine_$s$fTransformableSegment_$ctransform1
"SPEC/Geometry.Trail $fTransformableSegment_$ctransform @ V3 @ Double"
    forall ($dNum :: Num Double)
           ($dFoldable :: Foldable V3)
           ($dAdditive :: Additive V3).
      $fTransformableSegment_$ctransform $dAdditive $dFoldable $dNum
      = $fTransformableLine_$s$fTransformableSegment_$ctransform

